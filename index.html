<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/img/lufei.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/12/docker源码分析1-cli/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/12/docker源码分析1-cli/" itemprop="url">docker源码分析1-cli</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-12T20:41:10+08:00">
                2017-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Docker代码更新很快，网上各位大神的源码解析很多已经是几年前的版本了。实现上有了很大改变，加之Docker项目更名为<a href="https://github.com/moby/moby" target="_blank" rel="external">moby</a>，其中很多组件又从moby中拆分了出来，一开始看简直是一脸懵逼啊。在这里跟大家分享了一下最近看的<a href="https://github.com/docker/cli" target="_blank" rel="external">docker/cli</a>的源码，抛砖引玉，欢迎大家批评指正。<br><a href="https://github.com/docker/cli" target="_blank" rel="external">docker/cli</a></p>
<p>分析的<code>docker client</code>版本是<code>17.06.2-ce</code>。</p>
<p><code>docker client</code>是Docker的客户端程序，也就是我们敲的<code>docker * *</code> 命令，我们通过他与<code>docker deamon</code>程序进行交互。我们可以将他看成一个普通的客户端程序，docker的核心<code>namespace</code>和<code>cgroup</code>等技术都不在这里。</p>
<h2 id="搭建docker-client开发环境"><a href="#搭建docker-client开发环境" class="headerlink" title="搭建docker-client开发环境"></a>搭建docker-client开发环境</h2><p><code>docker_client</code>的开发环境也是在容器中，项目已经给我们做好了封装，具体可以参考项目Readme的<a href="https://github.com/docker/cli#development" target="_blank" rel="external">Development</a>章节。</p>
<p>问几个问题，大家可以思考一下：</p>
<p>####1. 开发是在容器中，可是容器里面连编辑器都没有，怎么开发？</p>
<p>答： 准确来说应该是在容器中调试，开发还是在本地开发，容器中看到的目录是我们本地目录mount进去的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> docker.Makefile文件</div><div class="line"></div><div class="line">......</div><div class="line">MOUNTS = -v "$(CURDIR)":/go/src/github.com/docker/cli</div><div class="line">......</div><div class="line"><span class="meta">#</span> start container in interactive mode for in-container development</div><div class="line">.PHONY: dev</div><div class="line">dev: build_docker_image</div><div class="line">    docker run -ti --security-opt=seccomp:unconfined $(ENVVARS) $(MOUNTS) \</div><div class="line">        -v /var/run/docker.sock:/var/run/docker.sock \</div><div class="line">        $(DEV_DOCKER_IMAGE_NAME) ash</div><div class="line"></div><div class="line">shell: dev</div><div class="line">......</div></pre></td></tr></table></figure>
<p>从shell里面还是很容器看出来的，run的时候mount了<code>$(CURDIR)</code></p>
<p>####2. 容器里面是不是还装了一个docker啊，为什么我在里面敲命令有响应？<br>答：不是的，里面只有你编译生成的docker client程序，是没有docker deamon程序，至于为什么能响应，还是看上面的shell脚本，<code>-v /var/run/docker.sock:/var/run/docker.sock</code>这一行将<code>docker.sock</code>文件也mount了进去，<code>docker.sock</code>是<code>docker deamon</code>默认监听的Unix套接字（Unix domain socket），容器中的进程可以通过他与docker deamon进行通信。所以这里docker client通信的是你本机的docker daemon。</p>
<p><img src="/img/docker_deamon_socket.png" alt="docker_deamon_socket"></p>
<p>所以我们的开发流程是：本地改代码–&gt;到container中编译–&gt;运行docker client看效果</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>是时候表演真正的技术了！</p>
<p>😆，开个玩笑，下面的分析如果有问题，还请大家不吝赐教！</p>
<p>我尽量把文件路径列出来，会贴一些代码，但主要还是路径，建议大家把代码clone下来照着看。</p>
<p>docker—client是基于<a href="https://github.com/spf13/cobra" target="_blank" rel="external">cobra</a>写的，建议大家先看一下cobra，至少写个<code>hello world</code>熟悉一下基本用法。</p>
<p>我们开始了！</p>
<p>入口文件在<code>cmd/docker/docker.go</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 日志输出采用了第三方库logrus</span></div><div class="line">    <span class="comment">// Set terminal emulation based on platform as required.</span></div><div class="line">    stdin, stdout, stderr := term.StdStreams()</div><div class="line">    logrus.SetOutput(stderr)</div><div class="line"></div><div class="line">    dockerCli := command.NewDockerCli(stdin, stdout, stderr)</div><div class="line">    </div><div class="line">    <span class="comment">// root命令，子命令都在这里面，重点看</span></div><div class="line">    cmd := newDockerCommand(dockerCli)</div><div class="line"></div><div class="line">    <span class="comment">// 命令执行	</span></div><div class="line">    <span class="keyword">if</span> err := cmd.Execute(); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">if</span> sterr, ok := err.(cli.StatusError); ok &#123;</div><div class="line">            <span class="keyword">if</span> sterr.Status != <span class="string">""</span> &#123;</div><div class="line">                fmt.Fprintln(stderr, sterr.Status)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// StatusError should only be used for errors, and all errors should</span></div><div class="line">            <span class="comment">// have a non-zero exit status, so never exit with 0</span></div><div class="line">            <span class="keyword">if</span> sterr.StatusCode == <span class="number">0</span> &#123;</div><div class="line">                os.Exit(<span class="number">1</span>)</div><div class="line">            &#125;</div><div class="line">            os.Exit(sterr.StatusCode)</div><div class="line">        &#125;</div><div class="line">        fmt.Fprintln(stderr, err)</div><div class="line">        os.Exit(<span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是这个文件，<code>newDockerCommand</code>函数调用了<code>commands.AddCommands(cmd, dockerCli)</code>来添加命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDockerCommand</span><span class="params">(dockerCli *command.DockerCli)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</div><div class="line">        opts := cliflags.NewClientOptions()</div><div class="line">        <span class="keyword">var</span> flags *pflag.FlagSet</div><div class="line"></div><div class="line">        cmd := &amp;cobra.Command&#123;</div><div class="line">                Use:              <span class="string">"docker [OPTIONS] COMMAND [ARG...]"</span>,</div><div class="line">                Short:            <span class="string">"A self-sufficient runtime for containers"</span>,</div><div class="line">                SilenceUsage:     <span class="literal">true</span>,</div><div class="line">                SilenceErrors:    <span class="literal">true</span>,</div><div class="line">                TraverseChildren: <span class="literal">true</span>,</div><div class="line">                Args:             noArgs,</div><div class="line">                RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">                        <span class="keyword">if</span> opts.Version &#123;</div><div class="line">                                showVersion()</div><div class="line">                                <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">return</span> command.ShowHelp(dockerCli.Err())(cmd, args)</div><div class="line">                &#125;,</div><div class="line">                PersistentPreRunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">                        <span class="comment">// daemon command is special, we redirect directly to another binary</span></div><div class="line">                        <span class="keyword">if</span> cmd.Name() == <span class="string">"daemon"</span> &#123;</div><div class="line">                                <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// flags must be the top-level command flags, not cmd.Flags()</span></div><div class="line">                        opts.Common.SetDefaultOptions(flags)</div><div class="line">                        dockerPreRun(opts)</div><div class="line">                        <span class="keyword">if</span> err := dockerCli.Initialize(opts); err != <span class="literal">nil</span> &#123;</div><div class="line">                                <span class="keyword">return</span> err</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">return</span> isSupported(cmd, dockerCli)</div><div class="line">                &#125;,</div><div class="line">        &#125;</div><div class="line">        cli.SetupRootCommand(cmd)</div><div class="line"></div><div class="line">        flags = cmd.Flags()</div><div class="line">        flags.BoolVarP(&amp;opts.Version, <span class="string">"version"</span>, <span class="string">"v"</span>, <span class="literal">false</span>, <span class="string">"Print version information and quit"</span>)</div><div class="line">        flags.StringVar(&amp;opts.ConfigDir, <span class="string">"config"</span>, cliconfig.Dir(), <span class="string">"Location of client config files"</span>)</div><div class="line">        opts.Common.InstallFlags(flags)</div><div class="line"></div><div class="line">        setFlagErrorFunc(dockerCli, cmd, flags, opts)</div><div class="line"></div><div class="line">        setHelpFunc(dockerCli, cmd, flags, opts)</div><div class="line"></div><div class="line">        cmd.SetOutput(dockerCli.Out())</div><div class="line">        cmd.AddCommand(newDaemonCommand())</div><div class="line">        # 添加子命令，cmd里现在是root命令</div><div class="line">        commands.AddCommands(cmd, dockerCli)</div><div class="line"></div><div class="line">        setValidateArgs(dockerCli, cmd, flags, opts)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cmd</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这行上面的<code>cmd.AddCommand(newDaemonCommand())</code>是为<code>docker daemon</code>命令进行的输出，<code>newDaemonCommand</code>定义在<code>cmd/docker/daemon_none.go</code>中，从他的<code>RunE</code>方法可以看出来，是输出了不能运行的提示，<code>runtime.GOOS</code>是输出当前系统的名称，比如mac是<code>Darwin</code>， ubuntu是<code>linux</code>，完整看来就是:</p>
<pre><code>`docker daemon` is not supported on Darwin. Please run `dockerd` directly
</code></pre><p>让我们来到<code>commands.AddCommands</code>定义的地方，<code>cli/command/commands/commands.go</code>文件，可以看到<code>cmd.AddCommand</code>的调用，这里就是在添加我们看到的二级命令，也就是紧跟着<code>docker</code>后面的命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddCommands</span><span class="params">(cmd *cobra.Command, dockerCli *command.DockerCli)</span></span> &#123;</div><div class="line">        cmd.AddCommand(</div><div class="line">                ......</div><div class="line"></div><div class="line">                <span class="comment">// container</span></div><div class="line">                container.NewContainerCommand(dockerCli),</div><div class="line">                container.NewRunCommand(dockerCli),</div><div class="line">                </div><div class="line">                ......</div><div class="line">                hide(container.NewPsCommand(dockerCli)),</div><div class="line">                hide(container.NewRenameCommand(dockerCli)),</div><div class="line">                ......</div></pre></td></tr></table></figure>
<p>我们从上看到下，整齐划一中发现最后好多命令被用hide包裹了。这些命令是一些旧命令，在新的版本中可以使用新的命令来代替，如果设置了环境变量<code>DOCKER_HIDE_LEGACY_COMMANDS</code>不为空，那么docker的提示将不会输出这些。</p>
<p>这里的命令太多了，我们通过<code>docker ps</code>命令来了解一下大致的执行流程。</p>
<p><code>docker ps</code>命令也是旧版的命令，<code>hide(container.NewPsCommand(dockerCli))</code>就是在处理他。在新版本中对应的是<code>docker container ls</code>命令。实现代码在<code>cli/command/container/list.go</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewPsCommand creates a new cobra.Command for `docker ps`</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPsCommand</span><span class="params">(dockerCli *command.DockerCli)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</div><div class="line">        options := psOptions&#123;filter: opts.NewFilterOpt()&#125;</div><div class="line"></div><div class="line">        cmd := &amp;cobra.Command&#123;</div><div class="line">                Use:   <span class="string">"ps [OPTIONS]"</span>,</div><div class="line">                Short: <span class="string">"List containers"</span>,</div><div class="line">                Args:  cli.NoArgs,</div><div class="line">                RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">                        <span class="keyword">return</span> runPs(dockerCli, &amp;options)</div><div class="line">                &#125;,</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        flags := cmd.Flags()</div><div class="line"></div><div class="line">        flags.BoolVarP(&amp;options.quiet, <span class="string">"quiet"</span>, <span class="string">"q"</span>, <span class="literal">false</span>, <span class="string">"Only display numeric IDs"</span>)</div><div class="line">        flags.BoolVarP(&amp;options.size, <span class="string">"size"</span>, <span class="string">"s"</span>, <span class="literal">false</span>, <span class="string">"Display total file sizes"</span>)</div><div class="line">        flags.BoolVarP(&amp;options.all, <span class="string">"all"</span>, <span class="string">"a"</span>, <span class="literal">false</span>, <span class="string">"Show all containers (default shows just running)"</span>)</div><div class="line">        flags.BoolVar(&amp;options.noTrunc, <span class="string">"no-trunc"</span>, <span class="literal">false</span>, <span class="string">"Don't truncate output"</span>)</div><div class="line">        flags.BoolVarP(&amp;options.nLatest, <span class="string">"latest"</span>, <span class="string">"l"</span>, <span class="literal">false</span>, <span class="string">"Show the latest created container (includes all states)"</span>)</div><div class="line">        flags.IntVarP(&amp;options.last, <span class="string">"last"</span>, <span class="string">"n"</span>, <span class="number">-1</span>, <span class="string">"Show n last created containers (includes all states)"</span>)</div><div class="line">        flags.StringVarP(&amp;options.format, <span class="string">"format"</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"Pretty-print containers using a Go template"</span>)</div><div class="line">        flags.VarP(&amp;options.filter, <span class="string">"filter"</span>, <span class="string">"f"</span>, <span class="string">"Filter output based on conditions provided"</span>)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cmd</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newListCommand</span><span class="params">(dockerCli *command.DockerCli)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</div><div class="line">        cmd := *NewPsCommand(dockerCli)</div><div class="line">        cmd.Aliases = []<span class="keyword">string</span>&#123;<span class="string">"ps"</span>, <span class="string">"list"</span>&#125;</div><div class="line">        cmd.Use = <span class="string">"ls [OPTIONS]"</span></div><div class="line">        <span class="keyword">return</span> &amp;cmd</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NewPsCommand</code>对应的是<code>docker ps</code>, <code>newListCommand</code>对应的是<code>docker container ls</code>，可以看出来， <code>newListCommand</code>里的command就是<code>NewPsCommand</code>返回的，只是加了一下说明而已。</p>
<blockquote>
<p>这里还漏了一点，docker container ls是3个命令，我们知道docker是root命令，按照cobra的写法，container和ls应该是分开的。他们的关系是这样的，在<code>cli/command/commands/commands.go</code>文件中<code>container.NewContainerCommand(dockerCli)</code>加入了<code>container</code>命令，<code>NewContainerCommand</code>的实现在<code>cli/command/container/cmd.go</code>中，在<code>NewContainerCommand</code>函数中通过<code>newListCommand(dockerCli)</code>加入了ls命令，可以看到还添加了很多别的方法，那些都是<code>container</code>支持的子命令。这样就回到了我们上面提到的内容了，没有魔法</p>
</blockquote>
<p>我们继续看<code>NewPsCommand</code>:</p>
<p>里面定义了<code>docker ps</code>（下面所有的内容对<code>docker container ls</code>都适用）支持的一些选项（flag）,选项被放在了psOptions这个结构体中，最终传给runPs函数.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">runPs</span><span class="params">(dockerCli *command.DockerCli, options *psOptions)</span> <span class="title">error</span></span> &#123;</div><div class="line">        ctx := context.Background()</div><div class="line"></div><div class="line">        listOptions, err := buildContainerListOptions(options)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        containers, err := dockerCli.Client().ContainerList(ctx, *listOptions)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        format := options.format</div><div class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(format) == <span class="number">0</span> &#123;</div><div class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(dockerCli.ConfigFile().PsFormat) &gt; <span class="number">0</span> &amp;&amp; !options.quiet &#123;</div><div class="line">                        format = dockerCli.ConfigFile().PsFormat</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        format = formatter.TableFormatKey</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        containerCtx := formatter.Context&#123;</div><div class="line">                Output: dockerCli.Out(),</div><div class="line">                Format: formatter.NewContainerFormat(format, options.quiet, listOptions.Size),</div><div class="line">                Trunc:  !options.noTrunc,</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> formatter.ContainerWrite(containerCtx, containers)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>listOptions, err := buildContainerListOptions(options)</code>对选项进行了处理，重点在<code>dockerCli.Client().ContainerList(ctx, *listOptions)</code>，<code>ContainerList</code>是一个interface。</p>
<p>实现在<code>vendor/github.com/docker/docker/client/container_list.go</code>（vendor在当前目录下，我是go新手，所以担心大家不知道，高手忽略）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">ContainerList</span><span class="params">(ctx context.Context, options types.ContainerListOptions)</span> <span class="params">([]types.Container, error)</span></span> &#123;</div><div class="line">        query := url.Values&#123;&#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.All &#123;</div><div class="line">                query.Set(<span class="string">"all"</span>, <span class="string">"1"</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.Limit != <span class="number">-1</span> &#123;</div><div class="line">                query.Set(<span class="string">"limit"</span>, strconv.Itoa(options.Limit))</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.Since != <span class="string">""</span> &#123;</div><div class="line">                query.Set(<span class="string">"since"</span>, options.Since)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.Before != <span class="string">""</span> &#123;</div><div class="line">                query.Set(<span class="string">"before"</span>, options.Before)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.Size &#123;</div><div class="line">                query.Set(<span class="string">"size"</span>, <span class="string">"1"</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.Filters.Len() &gt; <span class="number">0</span> &#123;</div><div class="line">                filterJSON, err := filters.ToParamWithVersion(cli.version, options.Filters)</div><div class="line"></div><div class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                query.Set(<span class="string">"filters"</span>, filterJSON)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        resp, err := cli.get(ctx, <span class="string">"/containers/json"</span>, query, <span class="literal">nil</span>)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> containers []types.Container</div><div class="line">        err = json.NewDecoder(resp.body).Decode(&amp;containers)</div><div class="line">        ensureReaderClosed(resp)</div><div class="line">        <span class="keyword">return</span> containers, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面是在拼请求的参数，<code>resp, err := cli.get(ctx, &quot;/containers/json&quot;, query, nil)</code>这里发起了请求，返回了container的列表。回到<code>cli/command/container/list.go</code>，接收到返回值之后，这时候还是json，下面进行了格式化输出，大家应该都做过打印<code>9*9乘法表</code>的经历，这里的格式化是同样的道理，不明白的同学可以继续往挖，我偷个懒，就不继续了。</p>
<p>至此<code>docker ps</code>的流程就走完了，大家可以对源码做一些修改，然后进到容器中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make binary</div></pre></td></tr></table></figure>
<p>就可以生产新的docker client，执行一下就能得到想要的输出啦。</p>
<p>谢谢大家，欢迎大家指正🙂</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/Moby-LinuxKit-初体验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/Moby-LinuxKit-初体验/" itemprop="url">Moby & LinuxKit 初体验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-07T21:14:16+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Docker的开源部分被改名成了<a href="https://github.com/moby/moby" target="_blank" rel="external">Moby</a>，同时Docker公司还开源了一个<a href="https://github.com/linuxkit/linuxkit" target="_blank" rel="external">LinuxKit</a>的项目，大家可以先去看一下readme。</p>
<p>Moby是一个组装容器系统的框架。它包含一个容器化组件库和一个将这些组件组装成独立的容器系统的框架。目前，Docker正在被拆分成模块化的组件，将来，Docker会从这些被Moby打包的组件中被组装出来。</p>
<p>LinuxKit是一个用来构造最小Linux发行版的工具集。它通过Moby来创建镜像（image），使用LinuxKit工具来运行这些镜像。</p>
<p>下面我们来体验一下，首先确保你已经安装了<a href="https://docs.Docker.com/engine/installation/linux/docker-ce/ubuntu/#recommended-extra-packages-for-trusty-1404" target="_blank" rel="external">Docker</a>和<a href="https://golang.org/doc/install" target="_blank" rel="external">Golang</a>。</p>
<h3 id="构建Moby"><a href="#构建Moby" class="headerlink" title="构建Moby"></a>构建Moby</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  git clone https://github.com/linuxkit/linuxkit.git</div><div class="line">➜  cd linuxkit</div><div class="line">➜  make &amp;&amp; sudo make install</div><div class="line">➜  moby version</div><div class="line">moby version 0.0</div><div class="line">commit: 1ff0e3beeeb1e741b9c5a54574f01ac5eee525a5</div></pre></td></tr></table></figure>
<h3 id="构建linux镜像"><a href="#构建linux镜像" class="headerlink" title="构建linux镜像"></a>构建linux镜像</h3><p>构建镜像是通过yaml文件（格式可以参考官方文档 <a href="https://github.com/moby/tool/blob/master/docs/yaml.md" target="_blank" rel="external">LinuxKit YAML</a>），linuxkit目录下有一个<code>linuxkit.yml</code>可以用，examples目录下也有很多可用的yaml文件，我们可以任选一个来构建，这里直接使用<code>linuxkit.yml</code>文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  linuxkit git:(master) moby build linuxkit.yml</div><div class="line">最后在当前目录下输出了3个文件</div><div class="line">Create outputs:</div><div class="line">  linuxkit-kernel linuxkit-initrd.img linuxkit-cmdline</div></pre></td></tr></table></figure>
<h3 id="运行LinuxKit镜像"><a href="#运行LinuxKit镜像" class="headerlink" title="运行LinuxKit镜像"></a>运行LinuxKit镜像</h3><p>运行通过linuxkit自带的linuxkit命令，命令在linuxkit/bin目录下，我们只是体验，也没必要写PATH，就直接写全路径吧。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜  linuxkit git:(master) bin/linuxkit run linuxkit</div><div class="line">...满屏满屏的输出，最后是熟悉的🐳</div><div class="line">Welcome to LinuxKit</div><div class="line"></div><div class="line">                        ##         .</div><div class="line">                  ## ## ##        ==</div><div class="line">               ## ## ## ## ##    ===</div><div class="line">           /"""""""""""""""""\___/ ===</div><div class="line">          &#123;                       /  ===-</div><div class="line">           \______ O           __/</div><div class="line">             \    \         __/</div><div class="line">              \____\_______/</div><div class="line">...</div></pre></td></tr></table></figure>
<p>现在我们就是在我们自己构建的linux最小发行版里面了，敲几个命令试试吧，退出是<code>halt</code>。</p>
<p>这个镜像只有54M，可以说是非常小了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  linuxkit git:(master) ls -alh | grep linuxkit</div><div class="line">-rw-r--r--  1 vagrant vagrant   42 Sep  7 11:52 linuxkit-cmdline</div><div class="line">-rw-r--r--  1 vagrant vagrant  54M Sep  7 11:52 linuxkit-initrd.img</div><div class="line">-rw-r--r--  1 vagrant vagrant 6.3M Sep  7 11:52 linuxkit-kernel</div><div class="line">drwxr-xr-x  2 vagrant vagrant 4.0K Sep  7 12:11 linuxkit-state</div><div class="line">-rw-rw-r--  1 vagrant vagrant 1.7K Sep  7 10:33 linuxkit.yml</div></pre></td></tr></table></figure>
<p>Moby和LinuxKit是非常不错的工具，但一般来说我们是用不上的。如果你需要构建定制的linux发行版，那他们可以节约很多时间。但如果你只是想将应用放在容器里跑起来，那还是直接用Docker吧！</p>
<p>另外，Moby和LinuxKit应该还没有成熟，命令一天一个变化（夸张了），如果你发现上面的命令失效了，建议google一下，或者联系我（知乎 or whaterver）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/浙江大学SEL实验室docker系列文章目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/浙江大学SEL实验室docker系列文章目录/" itemprop="url">浙江大学SEL实验室Docker系列文章目录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-07T17:24:33+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.sel.zju.edu.cn/?p=112" target="_blank" rel="external">DOCKER源码分析（一）：DOCKER架构</a>-2014.12.02</p>
<p><a href="http://www.sel.zju.edu.cn/?p=147" target="_blank" rel="external">DOCKER源码分析（二）：DOCKER CLIENT创建与命令执行</a>-2014.12.02</p>
<p><a href="http://www.sel.zju.edu.cn/?p=158" target="_blank" rel="external">DOCKER源码分析（三）：DOCKER DAEMON启动</a>-2014.12.02</p>
<p><a href="http://www.sel.zju.edu.cn/?p=165" target="_blank" rel="external">DOCKER源码分析（四）：DOCKER DAEMON之NEWDAEMON实现</a>-2014.12.02</p>
<p><a href="http://www.sel.zju.edu.cn/?p=259" target="_blank" rel="external">DOCKER源码分析（五）：DOCKER SERVER的创建</a>-2014.12.09</p>
<p><a href="http://www.sel.zju.edu.cn/?p=399" target="_blank" rel="external">DOCKER源码分析（六）：DOCKER DAEMON网络</a>-2015.01.05</p>
<p><a href="http://www.sel.zju.edu.cn/?p=508" target="_blank" rel="external">DOCKER源码分析（七）：DOCKER CONTAINER网络 （上）</a>-2015.01.26</p>
<p><a href="http://www.sel.zju.edu.cn/?p=537" target="_blank" rel="external">DOCKER源码分析（八）：DOCKER CONTAINER网络（下）</a>-2015.03.12</p>
<p><a href="http://www.sel.zju.edu.cn/?p=549" target="_blank" rel="external">DOCKER源码分析（九）：DOCKER镜像</a>-2015.03.12</p>
<p><a href="http://www.sel.zju.edu.cn/?p=444" target="_blank" rel="external">DOCKER网络详解及PIPEWORK源码解读与实践</a>-2015.01.16</p>
<p><a href="http://www.sel.zju.edu.cn/?p=556" target="_blank" rel="external">DOCKER背后的内核知识——NAMESPACE资源隔离</a>-2015.03.13</p>
<p><a href="http://www.sel.zju.edu.cn/?p=573" target="_blank" rel="external">DOCKER背后的内核知识——CGROUPS资源限制</a>-2015.04.22</p>
<p><a href="http://www.sel.zju.edu.cn/?p=577" target="_blank" rel="external">DOCKER背后的容器管理——LIBCONTAINER深度解析</a>-2015.06.03</p>
<p><a href="http://www.sel.zju.edu.cn/?p=296" target="_blank" rel="external">玩转DOCKER镜像</a>-2014.12.16</p>
<p><a href="http://www.sel.zju.edu.cn/?p=467" target="_blank" rel="external">深入理解ETCD技术分享PPT</a>-2015.01.20</p>
<p><a href="http://www.sel.zju.edu.cn/?p=523" target="_blank" rel="external">ETCD：从应用场景到实现原理的全方位解读</a>-2015.02.01</p>
<p><a href="http://www.sel.zju.edu.cn/?p=283" target="_blank" rel="external">GOOGLE KUBERNETES设计文档之安全篇</a>-2014.12.11</p>
<p><a href="http://www.sel.zju.edu.cn/?p=331" target="_blank" rel="external">GOOGLE KUBERNETES设计文档之POD篇</a>-2014.12.19</p>
<p><a href="http://www.sel.zju.edu.cn/?p=360" target="_blank" rel="external">GOOGLE KUBERNETES设计文档之服务篇</a>-2014.12.23</p>
<p><a href="http://www.sel.zju.edu.cn/?p=353" target="_blank" rel="external">GOOGLE KUBERNETES设计文档之网络篇</a>-2014.12.29</p>
<p><a href="http://www.sel.zju.edu.cn/?p=394" target="_blank" rel="external">GOOGLE KUBERNETES设计文档之VOLUMES</a>-2015.01.02</p>
<p><a href="http://www.sel.zju.edu.cn/?p=417" target="_blank" rel="external">KUBERNETES MINION NODE 组件 之 KUBELET</a>-2015.01.13</p>
<p><a href="http://www.sel.zju.edu.cn/?p=484" target="_blank" rel="external">KUBERNETES代码走读之MINION NODE 组件 KUBE-PROXY</a>-2015.01.22</p>
<p><a href="http://www.sel.zju.edu.cn/?p=588" target="_blank" rel="external">4S: SERVICES ACCOUNT, SECRET, SECURITY CONTEXT AND SECURITY IN KUBERNETES</a>-2015.07.30</p>
<p><a href="http://www.sel.zju.edu.cn/?p=595" target="_blank" rel="external">KUBERNETES NODE COMPONENTS – KUBELET</a>-2015.08.07</p>
<p><a href="http://www.sel.zju.edu.cn/?p=609" target="_blank" rel="external">KUBERNETES APISERVER源码分析——API请求的认证过程</a>-2015.08.09</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/02/python字符编码和字符串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/02/python字符编码和字符串/" itemprop="url">python字符编码和字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-02T22:35:33+08:00">
                2017-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>背景：我司代码都是基于python2</p>
<p>今天接到一个需求，用户提交的评论字数如果大于20个字要给用户发红包。毫不迟疑，我写下了下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> len(content) &gt; <span class="number">20</span>:</div><div class="line">	<span class="comment"># 发红包</span></div></pre></td></tr></table></figure>
<p>我转念一想，事情不大对，我这算的是字符数（这个表述是正确的，是字符）啊</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">len(<span class="string">"abcd"</span>)  <span class="comment"># 等于4</span></div><div class="line">len(<span class="string">"I love python"</span>)  <span class="comment"># 等于13</span></div></pre></td></tr></table></figure>
<p>上面的例子显而易见，小学生水平，再看下面的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">len(<span class="string">"我爱北京天安门"</span>)  <span class="comment"># 这个该是多少呢？</span></div><div class="line">len(<span class="string">u"我爱北京天安门"</span>)  <span class="comment"># 这个又该是多少呢？</span></div></pre></td></tr></table></figure>
<p>大家可以本地打开python试一下，结果是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">len(<span class="string">"我爱北京天安门"</span>)  <span class="comment"># 等于21</span></div><div class="line">len(<span class="string">u"我爱北京天安门"</span>)  <span class="comment"># 等于7</span></div></pre></td></tr></table></figure>
<p>其实我想要的是下面这个，但是我在代码里直接那么写，我操作的字符串前面到底有没有<code>u</code>呢，这个<code>u</code>我知道是<code>unicode</code>字符串，它和没有<code>u</code>的字符串到底区别在哪里？</p>
<p>几年前我曾经下决心弄懂这个问题，可能当时也确实明白了，但是现在差不多已经全忘了。我自己总结了一下，一是之前一直是用python3，python3做了一些修改。二是这个问题确实不应该交给程序员来解决（我承认我的记性确实不好）。</p>
<p>然而，旧的系统那么多，难保你下次跳槽的公司没有一些上了年纪的代码，我们还是来梳理一下吧。</p>
<h2 id="字符与字节"><a href="#字符与字节" class="headerlink" title="字符与字节"></a>字符与字节</h2><p>一个字符不等价于一个字节，字符是人类能够识别的符号，而这些符号要保存到计算机的存储中就需要用计算机能够识别的字节来表示。一个字符往往有多种表示方法，不同的表示方法会使用不同的字节数。这里所说的不同的表示方法就是指<code>字符编码</code>，比如字母A-Z都可以用<code>ASCII</code>码表示（占用一个字节），也可以用<code>UNICODE</code>表示（占两个字节），还可以用<code>UTF-8</code>表示（占用一个字节）。字符编码的作用就是将人类可识别的字符转换为机器可识别的字节码，以及反向过程。</p>
<p><strong>UNICDOE才是真正的字符串，而用ASCII、UTF-8、GBK等字符编码表示的是字节串</strong>。关于这点，我们可以在Python的官方文档中经常可以看到这样的描述<strong>“Unicode string”</strong> , <strong>“translating a Unicode string into a sequence of bytes”</strong>。（注意：英文中string是我们说的字符串，bytes是字节串）</p>
<p>我们写<code>代码</code>是写在<code>文件</code>中的，而<code>字符</code>是以<code>字节</code>形式保存在<code>文件</code>中的，因此当我们在文件中定义个<code>字符串</code>时被当做<code>字节串</code>也是可以理解的。但是，我们需要的是<code>字符串</code>，而不是<code>字节串</code>（我们写代码处理的是我们能想象的数据，也就是字符串，应该不会有人想象字节串吧）。一个优秀的编程语言，应该严格区分两者的关系并提供巧妙的完美的支持。JAVA语言就很好，我认识的JAVA程序员从来没有考虑过这些不应该由程序员来处理的问题（我一直这么认为）。遗憾的是，很多编程语言试图混淆<code>“字符串”</code>和<code>“字节串”</code>，他们<em>把字节串当做字符串来使用</em>，PHP和Python2都属于这种编程语言。最能说明这个问题的操作就是取一个包含中文字符的字符串的长度：</p>
<ul>
<li>对<code>字符串</code>取长度，结果应该是所有<code>字符</code>的个数，无论中文还是英文</li>
<li>对<code>字符串</code>对应的<code>字节串</code>取长度，就跟编码(encode)过程使用的<code>字符编码</code>有关了(比如：<code>UTF-8编码</code>，一个<code>中文字符</code>需要用<code>3个字节</code>来表示；<code>GBK编码</code>，一个<code>中文字符</code>需要<code>2个字节</code>来表示)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">7</span>]: a = <span class="string">u"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">9</span>]: <span class="keyword">print</span> len(a), type(a)</div><div class="line"><span class="number">2</span> &lt;type <span class="string">'unicode'</span>&gt;</div><div class="line"></div><div class="line">In [<span class="number">10</span>]: b = a.encode(<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line">In [<span class="number">11</span>]: <span class="keyword">print</span> len(b), type(b)</div><div class="line"><span class="number">6</span> &lt;type <span class="string">'str'</span>&gt;</div><div class="line"></div><div class="line">In [<span class="number">12</span>]: c = a.encode(<span class="string">'gbk'</span>)</div><div class="line"></div><div class="line">In [<span class="number">13</span>]: <span class="keyword">print</span> len(c), type(c)</div><div class="line"><span class="number">4</span> &lt;type <span class="string">'str'</span>&gt;</div></pre></td></tr></table></figure>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>UNICODE字符编码，也是一张字符与数字的映射，但是这里的数字被称为代码点(code point), 实际上就是十六进制的数字。</p>
<p><a href="https://docs.python.org/2/howto/unicode.html#encodings" target="_blank" rel="external">Python官方文档</a>中对Unicode字符串、字节串与编码之间的关系有这样一段描述：</p>
<pre><code>a Unicode string is a sequence of code points, which are numbers from 0 to 0x10ffff.
This sequence needs to be represented as a set of bytes (meaning, values from 0–255) in memory.
The rules for translating a Unicode string into a sequence of bytes are called an encoding.

Unicode字符串是一个代码点（code point）序列，代码点取值范围为0到0x10FFFF（对应的十进制为1114111）。
这个代码点序列在存储（包括内存和物理磁盘）中需要被表示为一组字节(0到255之间的值)，
而将Unicode字符串转换为字节序列的规则称为编码。
</code></pre><p>这里说的编码不是指字符编码，而是指<strong>编码的过程以及这个过程中所使用到的Unicode字符的代码点与字节的映射规则</strong>。这个映射不必是简单的一对一映射，因此编码过程也不必处理每个可能的Unicode字符，例如：</p>
<p>将<code>Unicode字符串</code>转换为<code>ASCII编码</code>的规则很简单–对于每个<code>代码点</code>：</p>
<ul>
<li>如果代码点数值&lt;128，则每个<code>字节</code>与代码点的值相同</li>
<li>如果代码点数值&gt;=128，则<code>Unicode字符</code>无法在此编码中进行表示（这种情况下，Python会引发一个<code>UnicodeEncodeError</code>异常）</li>
</ul>
<p>将<code>Unicode字符串</code>转换为<code>UTF-8编码</code>使用以下规则：</p>
<ul>
<li>如果代码点数值&lt;128，则由相应的<code>字节值</code>表示（与Unicode转ASCII字节一样）</li>
<li>如果代码点数值&gt;=128，则将其转换为一个2个字节，3个字节或4个字节的序列，该序列中的每个字节都在128到255之间。</li>
</ul>
<p>简单总结：</p>
<ul>
<li>编码(<code>encode</code>)：将<code>Unicode字符串</code>（中的代码点)转换特定<code>字符编码</code>对应的<code>字节串</code>的过程和规则</li>
<li>解码(decode)：将<strong>特定字符编码的字节串</strong>转换为对应的<strong>Unicode字符串</strong>(中的代码点)的过程和规则</li>
</ul>
<p>可见，无论是编码还是解码，都需要一个重要因素，就是特定的字符编码。因为一个字符用不同的字符编码进行编码后的字节值以及字节个数大部分情况下是不同的，反之亦然。</p>
<p>而且很容易看到，编码和解码都是基于<strong>Unicode字符串</strong>，<em>没有第二种字符串掺和</em>，其他都是编码方式，一定要深刻地认识到这一点。</p>
<h2 id="Python编码"><a href="#Python编码" class="headerlink" title="Python编码"></a>Python编码</h2><h3 id="Python源代码文件的执行过程"><a href="#Python源代码文件的执行过程" class="headerlink" title="Python源代码文件的执行过程"></a>Python源代码文件的执行过程</h3><p>我们都知道，磁盘上的文件都是以<code>二进制格式</code>存放的，其中<code>文本文件</code>都是以<code>某种特定编码</code>的<code>字节</code>形式存放的。对于程序源代码文件的字符编码是由编辑器指定的，比如我们使用vim来编写Python程序时会指定文件编码为UTF-8，那么Python代码被保存到磁盘时就会被转换为UTF-8编码对应的字节（encode过程）后写入磁盘。当执行Python代码文件中的代码时，Python解释器在读取Python代码文件中的字节串之后，需要将其转换为UNICODE字符串（decode过程）之后才执行后续操作。</p>
<p>上面已经解释过，这个转换过程（decode，解码）需要我们指定文件中保存的字节使用的字符编码是什么，才能知道这些字节在UNICODE这张万国码和统一码中找到其对应的代码点是什么。这里指定字符编码的方式大家都很熟悉，一图胜千言：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div></pre></td></tr></table></figure>
<p><img src="/img/python_source_file_execute.png" alt="python源文件文件的执行过程"></p>
<h3 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h3><p>那么，如果我们没有在代码文件开始的部分指定字符编码，Python解释器会使用哪种字符编码把从代码文件中读取到的字节转换为<strong>UNICODE代码点</strong>呢？就像我们配置某些软件时，有很多默认选项一样，Python解释器内部设置了默认的<code>字符编码</code>。因此大家所说的Python中文字符问题就可以总结为一句话：当无法通过<strong>默认的字符编码</strong>对字节进行转换时，就会出现解码错误(UnicodeEncodeError)。</p>
<p>Python2和Python3的解释器使用的默认编码是不一样的，我们可以通过<code>sys.getdefaultencoding()</code>来获取默认编码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># python2</span></div><div class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> sys</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: sys.getdefaultencoding()</div><div class="line">Out[<span class="number">3</span>]: <span class="string">'ascii'</span></div><div class="line"></div><div class="line"><span class="comment"># python3</span></div><div class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> sys</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: sys.getdefaultencoding()</div><div class="line">Out[<span class="number">3</span>]: <span class="string">'utf-8'</span></div></pre></td></tr></table></figure>
<p>因此，对于Python2来讲，Python解释器在读取到中文字符的字节码尝试解码操作时，会先查看当前代码文件头部是否有指明当前代码文件中保存的字节码对应的字符编码是什么。如果没有指定则使用默认字符编码”ASCII”进行解码导致解码失败，导致如下错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SyntaxError: Non-ASCII character <span class="string">'\xc4'</span> <span class="keyword">in</span> file xxx.py on line <span class="number">11</span>, but no encoding declared; see http://python.org/dev/peps/pep<span class="number">-0263</span>/ <span class="keyword">for</span> details</div></pre></td></tr></table></figure>
<p>对于Python3来讲，执行过程是一样的，只是Python3的解释器以”UTF-8”作为默认编码，但是这并不表示可以完全兼容中文问题。比如我们在Windows上进行开发时，Python工程及代码文件都使用的是默认的GBK编码，也就是说Python代码文件是被转换成GBK格式的字节码保存到磁盘中的。Python3的解释器执行该代码文件时，试图用UTF-8进行解码操作时，同样会解码失败，导致如下错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SyntaxError: Non-UTF<span class="number">-8</span> code starting <span class="keyword">with</span> <span class="string">'\xc4'</span> <span class="keyword">in</span> file xxx.py on line <span class="number">11</span>, but no encoding declared; see http://python.org/dev/peps/pep<span class="number">-0263</span>/ <span class="keyword">for</span> details</div></pre></td></tr></table></figure>
<h2 id="再谈python2和python3中的字符串"><a href="#再谈python2和python3中的字符串" class="headerlink" title="再谈python2和python3中的字符串"></a>再谈python2和python3中的字符串</h2><p>其实Python3中对字符串支持的改进，不仅仅是更改了默认编码，而是重新进行了字符串的实现，而且它已经实现了<strong>对UNICODE的内置支持</strong>，从这方面来讲Python已经和JAVA等语言一样优秀。下面我们来看下Python2与Python3中对字符串的支持有什么区别：</p>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>Python2中对字符串的支持由以下三个类提供</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">basestring</span><span class="params">(object)</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">str</span><span class="params">(basestring)</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">unicode</span><span class="params">(basestring)</span></span></div></pre></td></tr></table></figure>
<p>执行<code>help(str)</code>和<code>help(bytes)</code>会发现结果都是<code>str类</code>的定义，这也说明Python2中str就是<strong>字节串</strong>，而后来的<strong>unicode对象对应才是真正的字符串</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: a = <span class="string">"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">2</span>]: b = <span class="string">u"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">3</span>]: <span class="keyword">print</span> type(a), len(a)</div><div class="line">&lt;type <span class="string">'str'</span>&gt; <span class="number">6</span></div><div class="line"></div><div class="line">In [<span class="number">4</span>]: <span class="keyword">print</span> type(b), len(b)</div><div class="line">&lt;type <span class="string">'unicode'</span>&gt; <span class="number">2</span></div></pre></td></tr></table></figure>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><p>Python3中对字符串的支持进行了实现类层次的上简化，去掉了unicode类，添加了一个bytes类。从表面上来看，可以认为Python3中的str和unicode合二为一了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">bytes</span><span class="params">(object)</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">str</span><span class="params">(object)</span></span></div></pre></td></tr></table></figure>
<p>实际上，Python3中已经意识到之前的错误，开始明确的区分字符串与字节。因此Python3中的str已经是真正的字符串，而字节是用单独的bytes类来表示。也就是说，Python3默认定义的就是字符串，实现了对UNICODE的内置支持，减轻了程序员对字符串处理的负担。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: a = <span class="string">"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">2</span>]: b = <span class="string">u"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">3</span>]: c = a.encode(<span class="string">"gbk"</span>)</div><div class="line"></div><div class="line">In [<span class="number">4</span>]: print(type(a), len(a))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt; 2</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class"><span class="title">In</span> [5]:</span> print(type(b), len(b))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt; 2</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class"><span class="title">In</span> [6]:</span> print(type(c), len(c))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bytes</span>'&gt; 4</span></div></pre></td></tr></table></figure>
<h2 id="字符编码转换"><a href="#字符编码转换" class="headerlink" title="字符编码转换"></a>字符编码转换</h2><p>上面提到，UNICODE字符串可以与任意字符编码的字节进行相互转换，如图：</p>
<p><img src="/img/unicode_string.png" alt="unicode 字符串"></p>
<p>那么大家很容易想到一个问题，就是不同的字符编码的字节可以通过Unicode相互转换吗？答案是肯定的。</p>
<p><strong>Python2中的字符串进行字符编码转换过程是</strong>：</p>
<p>字节串–&gt;decode(‘原来的字符编码’)–&gt;Unicode字符串–&gt;encode(‘新的字符编码’)–&gt;字节串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: a = <span class="string">"中国"</span>  <span class="comment"># utf-8编码的字节串</span></div><div class="line"></div><div class="line">In [<span class="number">2</span>]: b = a.decode(<span class="string">'utf-8'</span>).encode(<span class="string">'gbk'</span>)  <span class="comment"># 先转换成unicode字符串，再进行gbk编码</span></div><div class="line"></div><div class="line">In [<span class="number">3</span>]: <span class="keyword">print</span> b.decode(<span class="string">'gbk'</span>)  <span class="comment"># 解码成unicode字符串</span></div><div class="line">中国</div></pre></td></tr></table></figure>
<p><strong>Python3中定义的字符串默认就是unicode，因此不需要先解码，可以直接编码成新的字符编码：</strong></p>
<p>字符串–&gt;encode(‘新的字符编码’)–&gt;字节串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: a = <span class="string">"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">2</span>]: b = a.encode(<span class="string">"gbk"</span>)</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: print(b.decode(<span class="string">"gbk"</span>))</div><div class="line">中国</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>python字符串编码差不多就是这些内容了，搞清楚原理其实记忆也不难。祝大家不会再掉到python字符编码的坑中，祝我司能尽快迁移到python3！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/30/go和python变量赋值的一个小问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/30/go和python变量赋值的一个小问题/" itemprop="url">go和python变量赋值的一个小问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-30T19:37:23+08:00">
                2017-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>平时写得多的是python，最近看了一点go，今天碰到了一个问题，和大家分享一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</div><div class="line">    Name <span class="keyword">string</span></div><div class="line">    Age  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pase_student</span><span class="params">()</span></span> &#123;</div><div class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</div><div class="line">    stus := []student&#123;</div><div class="line">        &#123;Name: <span class="string">"zhou"</span>, Age: <span class="number">24</span>&#125;,</div><div class="line">        &#123;Name: <span class="string">"li"</span>, Age: <span class="number">23</span>&#125;,</div><div class="line">        &#123;Name: <span class="string">"wang"</span>, Age: <span class="number">22</span>&#125;,</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</div><div class="line">        m[stu.Name] = &amp;stu</div><div class="line">    &#125;</div><div class="line">    fmt.Println(m[<span class="string">"zhou"</span>].Name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    pase_student()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单，大家可以思考一下会打印出什么。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">time.sleep(<span class="number">60</span>)  <span class="comment"># 思考</span></div></pre></td></tr></table></figure>
<p>结果是<code>wang</code>!，惊喜不惊喜！遍历赋值啊同学们，这么简单的操作都能出幺蛾子，WTF！</p>
<p>为什么是<code>wang</code>呢？<del>你tm给我</del>解释解释<del>什么是惊喜</del>：</p>
<p>for循环的时候，变量stu的指针是不变的，每次循环仅仅是对student结构体的<strong>值</strong>拷贝，上面的for循环和下面是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stu student </div><div class="line"><span class="keyword">for</span> _, stu = <span class="keyword">range</span> stus &#123;</div><div class="line">	m[stu.Name] = &amp;stu</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以<code>&amp;stu</code>自始至终都是一个地址，变化的是这个地址上存储的值。<code>&amp;stu</code>最终存储的值是<code>student{Name: &quot;wang&quot;, Age: 22}</code>结构体，所以拿出来的是<code>wang</code>。</p>
<p>可以将<code>m</code>打出来看一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">map</span>[zhou:<span class="number">0xc42000a260</span> li:<span class="number">0xc42000a260</span> wang:<span class="number">0xc42000a260</span>]</div></pre></td></tr></table></figure>
<p>验证了我们上面的想法，大家的value都是同一个地址。</p>
<p>看到这里，如果是一个日常写c，c++等强类型语言的同学可能会说，神经病啊！这有什么好说的！不就是这样的吗！请原谅我，我日常写python的 [捂脸]。</p>
<p>从上面的例子可以看出来，在go中，变量名是<code>存储地址的名字</code>。它在编译时绑定已经完成，运行时是不可以改变的，你只能改变地址中存储的值。</p>
<p>而在python中，变量是对象的名字，运行时变量可以绑定到任意的对象上。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">4</span>]: a = <span class="number">123456</span></div><div class="line"></div><div class="line">In [<span class="number">5</span>]: id(a)</div><div class="line">Out[<span class="number">5</span>]: <span class="number">4426596208</span></div><div class="line"></div><div class="line">In [<span class="number">6</span>]: a = <span class="number">1234567</span></div><div class="line"></div><div class="line">In [<span class="number">7</span>]: id(a)</div><div class="line">Out[<span class="number">7</span>]: <span class="number">4426592592</span></div></pre></td></tr></table></figure>
<p>注意：由于python对int类型实现了<strong>小整数对象池</strong>，不要用<strong>0-255</strong>的整数做实验，不然你得到id会是一样的。</p>
<p>也就是说，当你循环一个list的时候，每次得到的是不同对象，变量指向了不同的地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">9</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">2222</span>, <span class="number">2223</span>, <span class="number">2224</span>]:</div><div class="line">   ...:     print(id(i))</div><div class="line">   ...:</div><div class="line"><span class="number">4426596208</span></div><div class="line"><span class="number">4426592336</span></div><div class="line"><span class="number">4426596080</span></div></pre></td></tr></table></figure>
<p>上面这段代码，python为我们创建了3个<code>PyIntObject</code>，<strong>i</strong>只是他们的名字。而在go中，可以认为只有一个object，值变化了3次。</p>
<p>python中说的<code>赋值就是建立一个对象的引用</code>，是实话。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/ssl-traffic-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/13/ssl-traffic-analysis/" itemprop="url">SSL/TLS 会话流量分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T12:50:39+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="http://blog.fourthbit.com/2014/12/23/traffic-analysis-of-an-ssl-slash-tls-session" target="_blank" rel="external">http://blog.fourthbit.com/2014/12/23/traffic-analysis-of-an-ssl-slash-tls-session</a></p>
<p>在这篇文章中，我将会给大家展示当我们使用SSL/TLS的时候，在协议层面上发生了什么。为了便于分析，我将会使用一个基于OpenSSL实现的非阻塞TCP客户端和服务端。</p>
<p>我们要记住，SSL/TLS能让应用像底层基础设施（网络和主机）一样安全，确保通信安全是它唯一做的事。SSL/TLS是一个独立的协议，它处于应用层（一般来说是HTTP，其他同样也可以）和传输层（TCP）之间。如此，TLS不需要上下层协议有大的改动，对用户而言，它几乎是透明的，也就是说用户根本不需要知道这个协议的存在。当然，这也带来了一些弊端，它在一些基础方面对协议做了限制（比如不支持UDP）。</p>
<p>自SSL/TLS诞生以来，它已经有了相当大的改进。现在，SSL 2.0和3.0被认为是不安全的，他们已经被TLS 1.0/1.1/1.2 替换。这些协议的历史是一个很有趣的话题。</p>
<h2 id="协议描述"><a href="#协议描述" class="headerlink" title="协议描述"></a>协议描述</h2><p>就像上面提到的，TLS协议在应用层和传输层中间。它被分割成两个主要的子层。下面是这个协议的主要结构和它在网络协议栈中的位置。</p>
<p><img src="/img/protocol_description.png" alt="tls structure"></p>
<p>下面的子层在TCP之上，因为TCP是一个面向连接的可靠的协议。这一层主要包括TLS记录协议。简而言之，记录协议首先将上层协议的数据变成2^14bytes或更少的块，然后对数据进行压缩（可选），加上一个消息认证码（Message Authentication Code），最后，根据协商的加密细则对数据进行加密并添加一个SSL记录头。值得注意的是，每一个块都会被打包进一个结构体，这个结构体并不保存应用层消息的边界，这就意味着多条相同类型的消息可能会被合并到一个结构体中。</p>
<p>下面的图描述了建立一个SSL Record的过程</p>
<p><img src="/img/ssl_record.png" alt="ssl record"></p>
<p>上面的子层在SSL记录协议(SSL Record Protocol)之上，它由四个子协议组成。每个子协议都有非常明确的目的，并在通信的不同阶段被应用：</p>
<ol>
<li><p>握手协议（HandShake Protocol）：它使双方可以相互认证，以及为本次连接协商出一个加密套件（cipher suite）和其他参数。SSL握手协议涉及到客户端和服务端之间4组消息交换。每一组都是在独立的TCP段（segment）中传输。下面的图为这个过程做了总结，它包含好几个步骤，一些步骤是可选的。注意，<em>ChangeCipherSpec</em>不属于这个协议，他们是独立的协议，下面会讲到。<br><img src="/img/handshake.png" alt="handshake"></p>
</li>
<li><p>ChangeCipherSpec协议：它使之前双方协商得到的参数起作用，通信变成加密的。</p>
</li>
<li>Alert协议：用于通信异常，并预警可能降低通信安全性的问题</li>
<li>应用数据协议（Application Data Protocol）：它接受任意大小的数据（通常是应用层数据），将数据喂给安全通道（feeds it through the secure channel）。</li>
</ol>
<p>多条消息可以被串联成一条记录层（Record Layer）消息，但是这些消息必须归属于相同的子协议。结果是，这4个协议的每个都必须是自定界的（比如，都需要包含自己的长度字段）。</p>
<h2 id="记录协议格式（Record-Protocol-format）"><a href="#记录协议格式（Record-Protocol-format）" class="headerlink" title="记录协议格式（Record Protocol format）"></a>记录协议格式（Record Protocol format）</h2><p>TLS 记录头（Record header）包含3个字段，高层协议建立在它之上：</p>
<ol>
<li>Byte 0：TLS记录类型（TLS recode type）</li>
<li>Bytes 1-2: TLS version (major/minor)</li>
<li>Bytes 3-4: Length of data in the record (excluding the header itself). The maximum supported is 16384 (16K)</li>
</ol>
<p><img src="/img/record_protocol_format.png" alt="record protocol format"></p>
<h2 id="握手协议格式（Handshake-Protocol-format）"><a href="#握手协议格式（Handshake-Protocol-format）" class="headerlink" title="握手协议格式（Handshake Protocol format）"></a>握手协议格式（Handshake Protocol format）</h2><p>这是TLS种最复杂的子协议。TLS标准主要也在这一部分，因为它为建立一个安全的连接处理了所有细节。下面的图展示了握手协议消息的主体结构。TLS标准存在10种（不包括扩展）握手消息类型，下面一一做了展示。</p>
<p><img src="/img/handshake_message_structure.png" alt="handshake message general structure"></p>
<ul>
<li>HelloRequest：允许服务器重启握手协商。不常用。如果一个连接被挂起了足够长时间只是安全性下降，服务器可以使用此消息迫使客户端重新协商新的会话秘钥（keys）。</li>
</ul>
<p><img src="/img/hello_request.png" alt="hello request"></p>
<ul>
<li>ClientHello：这条消息代表了一个TLS握手协商的开始。发送它的同时会带上客户端支持的加密套件列表，服务端会挑选最合适的那个（安全性最强的那个），此外还有一个压缩方法列表，一个扩展列表。通过包含<code>SessionId</code>字段，它也赋予了客户端重新开始之前的会话的能力。</li>
</ul>
<p><img src="/img/client_hello.png" alt="client hello"></p>
<ul>
<li>ServerHello：ServerHello消息和ClientHello消息很类似，除了它只包含一个密码套件和一个加密方法。如果他包含了一个SessionId（例如：SessionId长度大于0），就是通知客户端在以后重用这个会话。</li>
</ul>
<p><img src="/img/server_hello.png" alt="server hello"></p>
<ul>
<li>Certificate：这个消息的消息体包含了一个公钥证书链。证书链使TLS支持证书分层和公钥基础设施（PKI：Public Key Infrastructures）</li>
</ul>
<p><img src="/img/certificate.png" alt="certificate"></p>
<ul>
<li>ServerKeyExchange：该消息携带客户端需要从服务器获得的密钥交换算法参数，以便之后能使用对称加密。这是可选的，因为并非所有密钥交换都要求服务器明确地发送此消息。实际上，在大多数情况下，Certificate消息足以使客户端与服务器安全地通信一个预先密钥。这些参数的格式完全取决于所选择的密钥套件（CipherSuite），它先前由服务器通过ServerHello消息设置。</li>
</ul>
<p><img src="/img/server_key_exchange.png" alt="server key exchange"></p>
<ul>
<li>CertificateRequest：当服务器需要客户端身份验证时使用它。在Web服务器中不常用，但在某些情况下非常重要。该消息不仅向客户端询问证书，还会告知哪些证书类型是可接受的。此外，它还指出那些证书机构是可信赖的。</li>
</ul>
<p><img src="/img/certificate_request.png" alt="certificate request"></p>
<ul>
<li>ServerHelloDone：该消息完成了握手协商的服务器部分。它没有附加信息。</li>
</ul>
<p><img src="/img/server_hello_done.png" alt="server hello done"></p>
<ul>
<li>ClientKeyExchange：它为服务器提供必要的数据，以生成对称加密的密钥。消息格式与ServerKeyExchange非常相似，因为它主要取决于服务器选择的密钥交换算法。</li>
</ul>
<p><img src="/img/client_key_exchange.png" alt="client key exchange"></p>
<ul>
<li>CertificateVerify：客户端使用该消息来证明服务器拥有与其公钥证书相对应的私钥。该消息保存有客户端数字签名的散​​列信息。如果服务器向客户端发出CertificateRequest，则需要发送需要验证的证书。同样的，信息的确切尺寸和结构取决于商定的算法。在所有情况下，输入到哈希函数的信息是相同的。</li>
</ul>
<p><img src="/img/certificate_verify.png" alt="certificate verify"></p>
<ul>
<li>Finished：此消息表示TLS协商已完成，密码套件（CipherSuite）已激活。应该发送已经加密，因为协商成功完成，所以必须在此之前发送一个<code>ChangeCipherSpec</code>协议消息来激活加密。Finish消息包含一个用所有先前的握手消息组合的哈希，其后是识别服务器/客户端角色的特殊号码，主密钥和填充。所产生的哈希与<code>CertificateVerify</code>哈希不同，因为存在更多的握手消息。</li>
</ul>
<p><img src="/img/finish.png" alt="finish"></p>
<h2 id="ChangeCipherSpec协议格式"><a href="#ChangeCipherSpec协议格式" class="headerlink" title="ChangeCipherSpec协议格式"></a>ChangeCipherSpec协议格式</h2><p>这是最简单的协议：它只有一条消息。该消息必须是单独的协议而不是握手协议的一部分的原因是由于记录层封装（Record Layer encapsulation）。 TLS协议同时对整个记录层消息进行加密。 ChangeCipherSpec消息表示加密的激活，并且由于加密不能应用于消息的一部分，因此任何其他消息都不可能遵循ChangeCipherSpec。避免这些组合的最佳方法是将此消息升级为协议状态。</p>
<p>下面展示ChangeCipherSpec消息是如何构造的：</p>
<p><img src="/img/change_cipher_spec.png" alt="change cipher spec"></p>
<h2 id="Alert协议格式"><a href="#Alert协议格式" class="headerlink" title="Alert协议格式"></a>Alert协议格式</h2><p>警报协议也很简单。它定义了两个字段：严重性级别和警报描述。第一个字段表示警报的严重性（警告为1，致命的2），而第二个字段则表示准确的条件。支持的警报描述取决于SSL/TLS版本。</p>
<p><img src="/img/alert_protocol_format.png" alt="alert protocol format"></p>
<h2 id="ApplicationData协议格式"><a href="#ApplicationData协议格式" class="headerlink" title="ApplicationData协议格式"></a>ApplicationData协议格式</h2><p>该协议的任务是正确地封装来自网络堆栈的应用层的数据，从而可以通过底层协议（TCP）无缝地处理数据，而不会强制更改任何这些层。此协议中消息的格式遵循与以前协议相同的结构。</p>
<p><img src="/img/application_protocol_format.png" alt="applicationdata protocol format"></p>
<h2 id="分析SSL-TLS流量"><a href="#分析SSL-TLS流量" class="headerlink" title="分析SSL/TLS流量"></a>分析SSL/TLS流量</h2><p>我将使用Wireshark进行抓包。客户端基于Scheme的方式支持SSL/TLS，服务端是OpenSSL分发的一部分（具有证书）。服务器监听在443端口，所有通信将通过环回设备进行。在Wireshark中将视图限制为TLS数据包的最简单方法是使用协议过滤器“ssl”。</p>
<h3 id="第一个包（客户端-gt-服务端）"><a href="#第一个包（客户端-gt-服务端）" class="headerlink" title="第一个包（客户端-&gt;服务端）"></a>第一个包（客户端-&gt;服务端）</h3><p>一旦服务器运行并等待连接，客户端就可以启动它。这是客户端发送的第一个数据包</p>
<p><img src="/img/first_flight.png" alt="first flight"></p>
<h3 id="第二个包（服务端-gt-客户端）"><a href="#第二个包（服务端-gt-客户端）" class="headerlink" title="第二个包（服务端-&gt;客户端）"></a>第二个包（服务端-&gt;客户端）</h3><p>第一个包只包含一个从客户端发送到服务器的TLS握手消息（ClientHello）。然而，服务器发送给客户端的作为ClientHello响应的下一个TCP数据包携带3个握手消息。这些消息是ServerHello，Certificate和ServerHelloDone（没有发送ServerKeyExchange或CertificateRequest）。在下一个数据包之后，我将省略较低的堆栈协议（TCP/IP）。</p>
<p><img src="/img/second_flight.png" alt="second flight"></p>
<h3 id="第三个包（客户端-gt-服务端）"><a href="#第三个包（客户端-gt-服务端）" class="headerlink" title="第三个包（客户端-&gt;服务端）"></a>第三个包（客户端-&gt;服务端）</h3><p>目前看上去都是正确的，与上述的协议一致。客户端和服务器现在已经同意使用的算法（密钥交换的RSA，对称加密的AES-256-CBC和消息散列的SHA），压缩（无压缩）和使用的TLS扩展（SessionTicket TLS，重新谈判信息）。此外，客户端现在拥有服务器的证书，因此可以决定是否信任服务器。下一个数据包由客户端发送，并携带以下消息：ClientKeyExchange，ChangeCipherSpec，Finished（已经加密）。</p>
<p><img src="/img/third_flight.png" alt="third flight"></p>
<h3 id="第四个包（服务端-gt-客户端）"><a href="#第四个包（服务端-gt-客户端）" class="headerlink" title="第四个包（服务端-&gt;客户端）"></a>第四个包（服务端-&gt;客户端）</h3><p>在客户端发送ChangeCipherSpec和Finished之后，服务器预期执行相同的操作，以便双向启动采用对称密钥和所有协商的密码套件参数的加密通信。服务器必须发送自己的ChangeCipherSpec和Finished的消息，以使握手过程可以被认为是成功的。在这个消息中发生的一件非常有趣的事情是，我们看到其中一个扩展，扩展名称为Transport Layer Security（传输层安全TLS）会话恢复，而无需服务器端状态，它明确说明了它的作用。你应该记得，它被要求作为我们的ClientHello的一部分，并由服务器在其ServerHello中实现。有关与此扩展相关的消息的信息，我们需要查找<a href="http://www.ietf.org/rfc/rfc5077.txt" target="_blank" rel="external">RFC5077</a>规范。如文档中所述，此扩展握手消息已被分配号码4。</p>
<p><img src="/img/fourth_flight.png" alt="fourth flight"></p>
<h3 id="应用层数据（客户端-lt-gt-服务端）"><a href="#应用层数据（客户端-lt-gt-服务端）" class="headerlink" title="应用层数据（客户端&lt;-&gt;服务端）"></a>应用层数据（客户端&lt;-&gt;服务端）</h3><p>此时，客户端和服务器完成握手。加密通信就位，应用数据可以安全传输。这是一个示例记录，单个TCP数据包可以携带几个消息：</p>
<p><img src="/img/application_data.png" alt="application data"></p>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>由于我们的连接是加密的，所以想知道在数据包中发送什么的唯一方法是使Wireshark或类似的工具知道传输中使用的密钥。尽管这是可能的，我认为为了分析的目的，当客户端或服务器主动关闭连接时，知道客户端会发出一个警告消息就足够了。此警报消息的类型应为CloseNotify（类型0），但是我们将无法从原始数据中看到它。在这种情况下，客户端是以下警报消息的发件人：</p>
<p><img src="/img/closing_connection.png" alt="closing message"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从流量分析可以看出，标准库和客户端的实现遵循了TLS 1.0规范。希望这对您了解SSL/TLS协议的内部机制是有用的。我发现检查十六进制原始数据（特别是像Wireshark这样强大的工具）是一种非常有意义和有趣的工作方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/19/Django外键赋值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/19/Django外键赋值/" itemprop="url">Django外键赋值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-19T10:46:48+08:00">
                2016-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>class Article(models.Model):
    title = models.CharField(max_length=1024, default=&apos;&apos;)
    ...
    def __str__(self):
        return &apos;Article pk:%d %s&apos; % (self.pk, self.title[:30])

class ArticleContent(models.Model):
    article = cached_fields.OneToOneField(Article)
    ...
</code></pre><p>写代码的的时候，发现了一个很奇怪的现象，当我给一个instance的外键（以_id结尾）赋值（数字）的时候    ，这个外键对应的instance的值并不会改变。</p>
<pre><code>In [44]: ac = ArticleContent.objects.get(article_id=14269)
In [45]: ac.article_id
Out[45]: 14269
In [46]: ac.article_id = 14266
In [47]: ac.save()
In [48]: ac.article
Out[48]: &lt;Article: Article pk:14266 EC: Russia, Ukraine to Meet in&gt;
In [49]: ac.article.pk
Out[49]: 14266
</code></pre><p>如上面的代码所示，为了找到答案，我翻了一下Django的源码：</p>
<pre><code>django/db/models/fields/related_descriptors.py 
145     def __get__(self, instance, cls=None):
146         &quot;&quot;&quot;
147         Get the related instance through the forward relation.
148
149         With the example above, when getting ``child.parent``:
150
151         - ``self`` is the descriptor managing the ``parent`` attribute
152         - ``instance`` is the ``child`` instance
153         - ``cls`` is the ``Child`` class (we don&apos;t need it)
154         &quot;&quot;&quot;
155         if instance is None:
156             return self
157
158         # The related instance is loaded from the database and then cached in
159         # the attribute defined in self.cache_name. It can also be pre-cached
160         # by the reverse accessor (ReverseOneToOneDescriptor).
161         try:
162             rel_obj = getattr(instance, self.cache_name)
163         except AttributeError:
164             val = self.field.get_local_related_value(instance)
165             if None in val:
166                 rel_obj = None
167             else:
168                 qs = self.get_queryset(instance=instance)
169                 qs = qs.filter(self.field.get_reverse_related_filter(instance))
170                 # Assuming the database enforces foreign keys, this won&apos;t fail.
171                 rel_obj = qs.get()
172                 # If this is a one-to-one relation, set the reverse accessor
173                 # cache on the related object to the current instance to avoid
174                 # an extra SQL query if it&apos;s accessed later on.
175                 if not self.field.remote_field.multiple:
176                     setattr(rel_obj, self.field.remote_field.get_cache_name(), instance)
177             setattr(instance, self.cache_name, rel_obj)
178
179         if rel_obj is None and not self.field.null:
180             raise self.RelatedObjectDoesNotExist(
181                 &quot;%s has no %s.&quot; % (self.field.model.__name__, self.field.name)
182             )
183         else:
184             return rel_obj
</code></pre><p>注释得非常到位，当我们请求<code>ac.article</code>的时候，会先去检查对应的cache（在这里是<code>_article_cache</code>，感兴趣可以去看<code>cache_name</code>的生成规则，就是外键名前面加下划线，后面加cache）存不存在，如果不存在那么就进行数据库请求，请求完之后会保存到cache中。</p>
<p>我们再看看<code>__set__</code>，代码太长就不贴了（就在<code>__get__</code>方法下面）。除了给外键字段（<code>article</code>）赋值外，还会将pk字段（<code>article_id</code>，是<code>lh_field.attname</code>的值）设置为None，这样下次请求的时候就能拿到正确的值。</p>
<p>以上都是ForeignKey的Magic，而当我们给<code>article_id</code>赋值的时候，只是在给一个普通的attribute赋值而已，没有任何magic，不会清理对应外键的cache，这时候拿到的instance仍然是cache中原来的那个instance。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/03/Django-redis如何支持存取整型和布尔值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/03/Django-redis如何支持存取整型和布尔值/" itemprop="url">Django-redis如何支持存取整型和布尔值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-03T05:16:48+08:00">
                2016-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>redis支持5种数据类型，分别是string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。整型值和布尔值并不在其中。存储整型和布尔值时，redis会将其转换为字符串</p>
<pre><code>127.0.0.1:6379&gt; SET test_key 1
OK
127.0.0.1:6379&gt; GET test_key
&quot;1&quot;
127.0.0.1:6379&gt; SET test_key True
OK
127.0.0.1:6379&gt; GET test_key
&quot;True&quot;
127.0.0.1:6379&gt; SET test_key TRUE
OK
127.0.0.1:6379&gt; GET test_key
&quot;TRUE&quot;
127.0.0.1:6379&gt; SET test_key true
OK
127.0.0.1:6379&gt; GET test_key
&quot;true&quot;
</code></pre><p>但是当我们使用了<code>django-redis</code>之后发现，我们可以正常存取整型和布尔值，这是怎么做的呢？答案自然是在源码中，直觉告诉我们，<code>set函数</code>里一定做了什么事情。</p>
<pre><code># django_redis.client.default.py
def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None, client=None, nx=False, xx=False):
    &quot;&quot;&quot;
    Persist a value to the cache, and set an optional expiration time.
    Also supports optional nx parameter. If set to True - will use redis setnx instead of set.
    &quot;&quot;&quot;

    if not client:
        client = self.get_client(write=True)

    nkey = self.make_key(key, version=version)
    nvalue = self.encode(value)

    ......
</code></pre><p><code>set</code>方法中调用了类的<code>encode</code>的方法对<code>value</code>进行了处理，我们再看<code>encode</code>：</p>
<pre><code>django_redis.client.default.py
def encode(self, value): &quot;&quot;&quot; Encode the given value. &quot;&quot;&quot;

if isinstance(value, bool) or not isinstance(value, integer_types):
    value = self._serializer.dumps(value)
    value = self._compressor.compress(value)
    return value

return value
</code></pre><p>看到了吧，如果是<code>布尔值</code>，那么要调用一个<code>dumps</code>方法，我们找到这个<code>dumps</code>方法：</p>
<pre><code>django_redis.serializers.pickle.py
class PickleSerializer(BaseSerializer): ......

def dumps(self, value):
    return pickle.dumps(value, self._pickle_version)

def loads(self, value):
    return pickle.loads(force_bytes(value))
</code></pre><p>原来是用了<a href="https://docs.python.org/3/library/pickle.html" target="_blank" rel="external">pickle</a>来做了序列化，这样拿出来的时候调用<code>pickle.loads</code>方法，就可以还原为原来的对象了。这也是<code>django-redis</code>支持存储任意<code>python</code>对象的原因，<a href="https://docs.python.org/3/library/pickle.html" target="_blank" rel="external">pickle</a>帮了大忙。</p>
<p>至于<code>int</code>的存取就简单了，我们从<code>get</code>方法看过去：</p>
<pre><code>django_redis.client.default.py
def get(self, key, default=None, version=None, client=None): &quot;&quot;&quot; Retrieve a value from the cache. Returns decoded value if key is found, the default if not. &quot;&quot;&quot; if client is None: client = self.get_client(write=False)

key = self.make_key(key, version=version)

try:
    value = client.get(key)
except _main_exceptions as e:
    raise ConnectionInterrupted(connection=client, parent=e)

if value is None:
    return default

return self.decode(value)
</code></pre><p>可以看到对从<code>redis</code>中取出来的值调用了<code>decode</code>方法：</p>
<pre><code>django_redis.client.default.py
def decode(self, value): 
&quot;&quot;&quot; 
Decode the given value. 
&quot;&quot;&quot; 
try: 
    value = int(value)
except (ValueError, TypeError):
    try:
        value = self._compressor.decompress(value)
    except CompressorError:
        # Handle little values, chosen to be not compressed pass
        value = self._serializer.loads(value) return value
</code></pre><p>一目了然了吧，总结的话就是：<code>redis</code>存的时候还是存的字符串，但是取出来的时候会尝试去<code>int</code>一下。</p>
<p>大家可能会有这样的疑问，如果值是<code>&#39;123&#39;</code>这样的字符串怎么办呢？这样并不会有问题啦，因为字符串存到数据库之前会先做<code>pickle.dumps</code>，这样就可以区分开<strong>数字转换成的字符串</strong>和<strong>真实的字符串</strong>了。</p>
<p>另外，将<code>整型</code>进行<code>pickle</code>也是可以的，但是我觉得因为数字的存储是很平常的需求，而<code>pickle</code>之后会带上对象的各种附加信息，会增加空间消耗，所以作者才有了这样的设计。</p>
<p>如果大家需要写自己的<code>redis client</code>的话，可以参考一下这些设计，会给使用带来很大的方便。</p>
<p><strong>Note</strong>: <code>Python3</code> 中<code>pickle</code>和<code>cPickle</code>已经合并为<code>pickle</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/17/Django-model去掉unique_together报错/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/17/Django-model去掉unique_together报错/" itemprop="url">Django model去掉unique_together报错</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-17T08:46:48+08:00">
                2016-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>事情是这样的，我有一个存储考试的表</p>
<pre><code>class Exam(models.Model):
    category = models.ForiegnKey(Category)
    name = models.CharField(max_length=128)
    date = models.DateField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = (&apos;category&apos;, &apos;date&apos;)
</code></pre><p>category表示考试的类型，date表示考试的日期。建表的时候考虑到一个类型的考试在同一个应该只有一个考试，所以就加了一个<code>unique_together</code>。但是由于业务需要，这个unique_together不需要了。</p>
<p>用过django的人都知道，这不是个大问题，删掉<code>unique_together</code>的代码，然后makemigrations呗，确实，我就这么做了。但是当我migrate的时候却报错了，错误如下：</p>
<pre><code>django.db.utils.OperationalError: (1553, &quot;Cannot drop index &apos;insurance_exam_category_id_a430e581_uniq&apos;: needed in a foreign key constraint&quot;)
</code></pre><p>数据库不让我删除这个index，并且告诉我有一个外键约束用到了这个它。我就奇怪了，category是外键没错，但是我这个是<code>unique_together</code>啊，怎么可能有哪个外键用到了它呢？</p>
<p>没办法，我只能到数据库里寻找答案，<code>show create table exam</code>，输出如下：</p>
<pre><code>| insurance_exam | CREATE TABLE `insurance_exam` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) NOT NULL,
  `date` date NOT NULL,
  `created_at` datetime(6) NOT NULL,
  `updated_at` datetime(6) NOT NULL,
  `category_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `insurance_exam_category_id_a430e581_uniq` (`category_id`,`date`),
  CONSTRAINT `insurance_exam_category_id_a2238260_fk_insurance_category_id` FOREIGN KEY (`category_id`) REFERENCES `insurance_category` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1062 DEFAULT CHARSET=utf8mb4 |
</code></pre><p>可以看到UNIQUE KEY那一行就是<code>unique_together</code>，下面一行是category外键。没有其他东西了啊，到底哪个外键用到了我们的<code>unique_together</code>？</p>
<p>外键只能是category了，也没有别的外键啊。到底是怎么回事呢？</p>
<p>原因是这样的：在Mysql中外键会自动在表上添加一个index，也就说如果没有unique_together，我们的表应该是这样的：</p>
<pre><code>| insurance_exam | CREATE TABLE `insurance_exam` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) NOT NULL,
  `date` date NOT NULL,
  `created_at` datetime(6) NOT NULL,
  `updated_at` datetime(6) NOT NULL,
  `category_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `category_id` (`category_id`),
  CONSTRAINT `insurance_exam_category_id_a2238260_fk_insurance_category_id` FOREIGN KEY (`category_id`) REFERENCES `insurance_category` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1062 DEFAULT CHARSET=utf8mb4 |
</code></pre><p>但是因为有了<code>unique_together</code>的<code>unique_key</code>，并且category在联合索引的左边，根据最左前缀原则，category的索引就有了，所以就不会另外建索引，这个时候category的外键约束就依赖了这个<code>unique_key</code>，所以删除的时候会出现那样的报错。</p>
<p>机智的小伙伴应该想到了，如果我们要去掉<code>unique_together</code>，我们可以将category的KEY加回去，这样就可以将<code>unique_together</code>删掉了。sql如下：</p>
<pre><code>alter table exam add index(category_id);
</code></pre><p>这样，migrate就能成功了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/10/python-string-intern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/10/python-string-intern/" itemprop="url">python_string_intern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-10T10:12:09+08:00">
                2016-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章会介绍<code>CPython 2.7.12</code>中字符串<code>intern</code>的知识。</p>
<p>首先举一个例子说明内置的<code>intern</code>函数的用法：</p>
<pre><code>&gt;&gt;&gt; s1 = &apos;foo!&apos;
&gt;&gt;&gt; s2 = &apos;foo!&apos;
&gt;&gt;&gt; s1 is s2
False
&gt;&gt;&gt; s1 = intern(&apos;foo!&apos;)
&gt;&gt;&gt; s1
&apos;foo!&apos;
&gt;&gt;&gt; s2 = intern(&apos;foo!&apos;)
&gt;&gt;&gt; s1 is s2
True
</code></pre><p>你应该已经体会到了用法，但是，在<code>python</code>内部它是怎么工作的呢？</p>
<h2 id="String-Intern（字符串驻留）"><a href="#String-Intern（字符串驻留）" class="headerlink" title="String Intern（字符串驻留）"></a>String Intern（字符串驻留）</h2><p>###<code>PyStringObject</code>结构体</p>
<p>我们需要深入<code>CPython</code>的源码，表示<code>Python</code>字符串的<code>C</code>结构体<code>PyStringObject</code>在<code>stringobject.h</code>文件中：</p>
<pre><code>typedef struct {
    PyObject_VAR_HEAD
    long ob_shash;
    int ob_sstate;
    char ob_sval[1];

    /* Invariants:
     *     ob_sval contains space for &apos;ob_size+1&apos; elements.
     *     ob_sval[ob_size] == 0.
     *     ob_shash is the hash of the string or -1 if not computed yet.
     *     ob_sstate != 0 iff the string object is in stringobject.c&apos;s
     *       &apos;interned&apos; dictionary; in this case the two references
     *       from &apos;interned&apos; to this object are *not counted* in ob_refcnt.
     */
} PyStringObject;
</code></pre><p>根据注释，如果字符串被<code>interned</code>，变量<code>ob_sstate</code>的值将不再等于<code>0</code>。一般来说，我们不会直接接触这个变量，而是通过下面定义的宏<code>PyString_CHECK_INTERNED</code>来读取它：</p>
<pre><code>#define PyString_CHECK_INTERNED(op) (((PyStringObject *)(op))-&gt;ob_sstate)
</code></pre><p>###interned字典</p>
<p>然后，让我们来看<code>stringobject.c</code>。<code>24行</code>定义了一个对象的引用，<code>interned</code>字符串将会存放在这个对象里。</p>
<pre><code>static PyObject *interned;
</code></pre><p>实际上，这个对象就是一个正常的<code>Python</code>字典，在第<code>4744行</code>被初始化</p>
<pre><code>interned = PyDict_New();
</code></pre><p>最终，所有的魔法都在第<code>4731行``PyString_InternInPlace</code>函数中发生。下面是函数实现：</p>
<pre><code>PyString_InternInPlace(PyObject **p)
{
    register PyStringObject *s = (PyStringObject *)(*p);
    PyObject *t;
    if (s == NULL || !PyString_Check(s))
        Py_FatalError(&quot;PyString_InternInPlace: strings only please!&quot;);
    /* If it&apos;s a string subclass, we don&apos;t really know what putting
       it in the interned dict might do. */
    if (!PyString_CheckExact(s))
        return;
    if (PyString_CHECK_INTERNED(s))
        return;
    if (interned == NULL) {
        interned = PyDict_New();
        if (interned == NULL) {
            PyErr_Clear(); /* Don&apos;t leave an exception */
            return;
        }
    }
    t = PyDict_GetItem(interned, (PyObject *)s);
    if (t) {
        Py_INCREF(t);
        Py_DECREF(*p);
        *p = t;
        return;
    }

    if (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) &lt; 0) {
        PyErr_Clear();
        return;
    }
    /* The two references in interned are not counted by refcnt.
       The string deallocator will take care of this */
    Py_REFCNT(s) -= 2;
    PyString_CHECK_INTERNED(s) = SSTATE_INTERNED_MORTAL;
}
</code></pre><p>可以看到，<code>interned</code>字典中的<code>keys</code>都是指向字符串对象的指针，<code>values</code>也是同样的指针。另外，字符串的派生类不能被<code>intern</code>。不考虑<code>错误检查</code>和<code>引用计数</code>，我们可以用如下伪代码重写这个函数：</p>
<pre><code>interned = None

def intern(string):
    if string is None or not type(string) is str:
        raise TypeError

    if string.is_interned:
        return string

    if interned is None:
        global interned
        interned = {}

    t = interned.get(string)
    if t is not None:
        return t

    interned[string] = string
    string.is_interned = True
    return string
</code></pre><p>简单吧！</p>
<p>###字符串intern的好处</p>
<p>####共享对象</p>
<p>为什么你要使用字符串<code>intern</code>？首先，共享字符串对象可以减少内存占用。让我们回到第一个例子，一开始，变量<code>s1</code>和<code>s2</code>指向两个不同的对象。</p>
<p><img src="http://guilload.com/assets/media/python-string-interning/foo.png" alt="The two variables reference two different objects"></p>
<p>在<code>intern</code>之后，他们都指向了同一个对象。第二个对象占用的内存被节省下来了。</p>
<p><img src="http://guilload.com/assets/media/python-string-interning/bar.png" alt="Now, the two variables reference the same object"></p>
<p>在处理一些低信息熵的大列表的时候，<code>intern</code>非常有用。例如，当我们解析一个语料库，we could benefit from the very heavy-tailed distribution of word frequencies in human languages to intern strings to our advantage。下面的例子中，我们会使用<code>NLTK</code>来导入<code>Hamlet by Shakespeare</code>，使用<code>Heapy</code>来观察<code>intern</code>前后对象的堆栈使用：</p>
<pre><code>import guppy
import nltk

hp = guppy.hpy()
hp.setrelheap()

hamlet = nltk.corpus.shakespeare.words(&apos;hamlet.xml&apos;)
print hp.heap()

hamlet = [intern(wrd) for wrd in nltk.corpus.shakespeare.words(&apos;hamlet.xml&apos;)]
print hp.heap()



$ python intern.py

Partition of a set of 31187 objects. Total size = 1725752 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0  31166 100  1394864  81   1394864  81 str
...

Partition of a set of 4555 objects. Total size = 547840 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0      4   0   328224  60    328224  60 list
     1   4529  99   215776  39    544000  99 str
...
</code></pre><p>如你所见，我们极大地减少了字符串对象的数量（从<code>31187</code>减少到<code>4555</code>），并且内存占用减少了<code>6.5</code>倍</p>
<p>####指针比较</p>
<p>第二，我们可以用<code>O(1)</code>的指针比较来代替<code>O(n)</code>的字节比较</p>
<p>为了验证这个，我测量了在比较两个字符串是否相等的时，<code>intern</code>与否分别的时间。下面的图应该能说服你：</p>
<p><img src="http://guilload.com/assets/media/python-string-interning/qux.png" alt="Pointer comparison vs. byte-per-byte comparison"></p>
<p>###Native interning</p>
<p>在一些条件下，字符串会被原生<code>interning</code>。还是第一个例子，如果我用<code>foo</code>而不是<code>foo！</code>，字符串<code>s1</code>和<code>s2</code>就会被自动地<code>intern</code>。</p>
<pre><code>&gt;&gt;&gt; s1 = &apos;foo&apos;
&gt;&gt;&gt; s2 = &apos;foo&apos;
&gt;&gt;&gt; s1 is s2
True
</code></pre><p>###Interned or not interned?</p>
<p>写这篇文章之前，我一直在想，在后台，字符串会根据一个参考字符串长度和构成它们的字符的规则来执行<code>intern</code>。我的想法离正确答案很近，但是，当我操作几组创建方法不同的字符串时，我无法推测出这条规则到底是什么！</p>
<pre><code>&gt;&gt;&gt; &apos;foo&apos; is &apos;foo&apos;
True
&gt;&gt;&gt; &apos;foo!&apos; is &apos;foo!&apos;
False
&gt;&gt;&gt; &apos;foo&apos; + &apos;bar&apos; is &apos;foobar&apos;
True
&gt;&gt;&gt; &apos;&apos;.join([&apos;f&apos;]) is &apos;&apos;.join([&apos;f&apos;])
True
&gt;&gt;&gt; &apos;&apos;.join([&apos;f&apos;, &apos;o&apos;, &apos;o&apos;]) is &apos;&apos;.join([&apos;f&apos;, &apos;o&apos;, &apos;o&apos;])
False
&gt;&gt;&gt; &apos;a&apos; * 20 is &apos;aaaaaaaaaaaaaaaaaaaa&apos;
True
&gt;&gt;&gt; &apos;a&apos; * 21 is &apos;aaaaaaaaaaaaaaaaaaaaa&apos;
False
&gt;&gt;&gt; &apos;foooooooooooooooooooooooooooooo&apos; is &apos;foooooooooooooooooooooooooooooo&apos;
True
</code></pre><p>在看完这些例子后，你要承认，确实非常难以确定系统是根据什么来执行原生的<code>intern</code>。我们还需要阅读更多的<code>CPython</code>代码来找出答案。</p>
<p>####Fact 1: all length 0 and length 1 strings are interned</p>
<p>还是在<code>stringobject.c</code>，我们这些要看<code>PyString_FromStringAndSize</code>和 <code>PyString_FromString</code>函数中都有的一些代码：</p>
<pre><code>/* share short strings */
if (size == 0) {
    PyObject *t = (PyObject *)op;
    PyString_InternInPlace(&amp;t);
    op = (PyStringObject *)t;
    nullstring = op;
    Py_INCREF(op);
} else if (size == 1 &amp;&amp; str != NULL) {
    PyObject *t = (PyObject *)op;
    PyString_InternInPlace(&amp;t);
</code></pre><p>非常清晰：所有长度为<code>0</code>和<code>1</code>的字符串都会被<code>intern</code>。</p>
<p>####Fact 2: 在编译期间字符串会被<code>interned</code></p>
<p>你写的<code>Python</code>代码并不是直接被解释器执行，代码会通过一个经典的编译链来生成一种中间语言：<code>bytecode</code>（字节码）。<code>python</code>字节码是被<code>Python</code>解释器这个虚拟机执行的一系类指令。你可以在<a href="https://docs.python.org/2/library/dis.html#bytecodes" target="_blank" rel="external">这里</a>看到所有的指令。通过使用<code>dis</code>模块，你可以看到一个函数或模块执行了哪些指令：</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def foo():
...     print &apos;foo!&apos;
...
&gt;&gt;&gt; dis.dis(foo)
  2           0 LOAD_CONST               1 (&apos;foo!&apos;)
              3 PRINT_ITEM
              4 PRINT_NEWLINE       
              5 LOAD_CONST               0 (None)
              8 RETURN_VALUE
</code></pre><p>正如你知道的，在<code>Python</code>中，一切皆对象。代码也是<code>Python</code>对象，它表示了一块字节码。一个代码对象带有执行时所需要的所有信息：常量，变量名等。我们发现，当在<code>Python</code>中创建代码对象的时候，有一些字符串被<code>intern</code>了：</p>
<pre><code>PyCodeObject *
PyCode_New(int argcount, int nlocals, int stacksize, int flags,
           PyObject *code, PyObject *consts, PyObject *names,
           PyObject *varnames, PyObject *freevars, PyObject *cellvars,
           PyObject *filename, PyObject *name, int firstlineno,
           PyObject *lnotab)

           ...
           /* Intern selected string constants */
           for (i = PyTuple_Size(consts); --i &gt;= 0; ) {
               PyObject *v = PyTuple_GetItem(consts, i);
               if (!PyString_Check(v))
                   continue;
               if (!all_name_chars((unsigned char *)PyString_AS_STRING(v)))
                   continue;
               PyString_InternInPlace(&amp;PyTuple_GET_ITEM(consts, i));
           }
</code></pre><p>在<code>codeobject.c</code>中，<code>consts元组</code>包含了在编译期间定义的字面量：<code>布尔值</code>，<code>浮点数</code>，<code>整数</code>和在你的程序中声明的字符串。在这个元祖中存储的字符串，如果没有被<code>all_name_chars</code>函数过滤掉的话，将会被全部<code>intern</code>。</p>
<p>下面的例子中，<code>s1</code>是在编译期间被声明的。相反的是，<code>s2</code>是在运行时产生的：</p>
<pre><code>s1 = &apos;foo&apos;
s2 = &apos;&apos;.join([&apos;f&apos;, &apos;o&apos;, &apos;o&apos;])
</code></pre><p>结果是，<code>s1</code>将会被<code>intern</code>，<code>s2</code>不会。</p>
<p><code>all_name_chars</code>方法将会过滤掉不是由<code>ascii字符</code>，<code>数字</code>和<code>下划线</code>构成的字符串（Python中变量名的命令规范）：</p>
<pre><code>#define NAME_CHARS \
    &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&quot;

/* all_name_chars(s): true if all chars in s are valid NAME_CHARS */

static int
all_name_chars(unsigned char *s)
{
    static char ok_name_char[256];
    static unsigned char *name_chars = (unsigned char *)NAME_CHARS;

    if (ok_name_char[*name_chars] == 0) {
        unsigned char *p;
        for (p = name_chars; *p; p++)
            ok_name_char[*p] = 1;
    }
    while (*s) {
        if (ok_name_char[*s++] == 0)
            return 0;
    }
    return 1;
}
</code></pre><p>理解了这些，我们就知道了为什么<code>&#39;foo!&#39; is &#39;foo!&#39;</code>等于<code>False</code>，而<code>&#39;foo&#39; is &#39;foo&#39;</code>等于<code>True</code>，胜利了吗？还没有！</p>
<p>####字节码优化产生了更多字符串常量</p>
<p>这听起来和直觉不符，但是在下面的例子中，字符串连接的输出不是在运行时，而是在编译时：</p>
<pre><code>&gt;&gt;&gt; &apos;foo&apos; + &apos;bar&apos; is &apos;foobar&apos;
True
</code></pre><p>这就是为什么<code>&#39;foo&#39; + &#39;bar&#39;</code>也被<code>intern</code>了，表达式等于<code>True</code>。</p>
<p>怎么做到的？倒数第二的源码编译器生成了第一个版本的字节码。这个原始的字节码最终会进入最后一个编译器，被称作<code>“窥孔优化”</code>(<code>peephole optimization</code>)</p>
<p><img src="http://guilload.com/assets/media/python-string-interning/baz.png" alt="Compilation chain"></p>
<p>这一步的目标是通过替换更快的指令来产生更加高效的字节码。</p>
<p>##常量合并<code>Constant folding</code></p>
<p>在<code>窥孔优化</code>期间，应用到的一项技术就是常量合并，使用更加简单的常量。想象你是一个编译器，你看到了下面这行：</p>
<pre><code>SECONDS = 24 * 60 * 60
</code></pre><p>你能做什么来简化这个表达式以在运行时节约几个时钟周期。你可以用计算好的值<code>86400</code>来替换这个表达式。这就是<code>foo&#39; + &#39;bar&#39;</code>发生的事。让我们定义一个<code>foobar</code>函数，分解相关的字节码：</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def foobar():
...         return &apos;foo&apos; + &apos;bar&apos;
&gt;&gt;&gt; dis.dis(foobar)
  2           0 LOAD_CONST               3 (&apos;foobar&apos;)
              3 RETURN_VALUE
</code></pre><p>看到了吧！根本没有看到加法和初始的两个常量<code>&#39;foo&#39;</code>和<code>&#39;bar&#39;</code>。如果<code>CPython</code>字节码没有被优化，那么输出应该是这样的：</p>
<pre><code>&gt;&gt;&gt; dis.dis(foobar)
  2           0 LOAD_CONST               1 (&apos;foo&apos;)
              3 LOAD_CONST               2 (&apos;bar&apos;)
              6 BINARY_ADD    
              7 RETURN_VALUE
</code></pre><p>我们解决为什么下面的表达式正确的问题：</p>
<pre><code>&gt;&gt;&gt; &apos;a&apos; * 20 is &apos;aaaaaaaaaaaaaaaaaaaa&apos;
</code></pre><p>####避免大的 .pyc 文件</p>
<p>那么为什么<code>&#39;a&#39; * 21 is &#39;aaaaaaaaaaaaaaaaaaaaa&#39;</code>不等于<code>True</code>呢？你还记得在你的包里面会看到的<code>.pyc</code>文件吗。如果一个人写了诸如<code>[&#39;foo!&#39;] * 10**9</code>的代码会怎么样呢？这样会导致<code>.pyc</code>文件非常巨大！为了避免这个现象，<code>窥孔优化</code>中产生的序列长度如果大于<code>20</code>，将会被丢弃。</p>
<p>##补充</p>
<p>###窥孔优化<br>顾名思义，是一种很局部的优化方式，编译器仅仅在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则，或者通过整体的分析，通过指令转换，提升代码性能。别看这些代码转换很局部，很小，但可能会带来很大的性能提升。</p>
<p>这个窥孔，你可以认为是一个滑动窗口，编译器在实施窥孔优化时，就仅仅分析这个窗口内的指令。每次转换之后，可能还会暴露相邻窗口之间的某些优化机会，所以可以多次调用窥孔优化，尽可能提升性能。</p>
<p>窥孔优化可以在四个方面寻找优化机会：冗余指令删除，包括冗余的load和store指令以及死代码(不会执行的代码);控制流优化；强度削弱；利用特有指令。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">212</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
