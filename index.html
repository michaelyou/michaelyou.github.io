<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/img/lufei.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/翻译-Illustrated-guide-to-SQLX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/翻译-Illustrated-guide-to-SQLX/" itemprop="url">[翻译] Illustrated guide to SQLX</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T21:56:18+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这篇文章虽说标题是SQLX指南，但也可以看做是标准库database/sql<a href="https://golang.org/pkg/database/sql/" target="_blank" rel="external">文档</a>的补充</p>
</blockquote>
<p><strong>sqlx</strong>包对Go内置的<strong>database/sql</strong>包提供了一系列扩展</p>
<p>本文的重点在于检测Go对于数据库的一些习惯用法，所以不要认为这里展示的SQL是使用数据的推荐方法。本文不涉及设置Go开发环境，基本的Go语法，以及SQL本身。</p>
<p>另外，err变量被用来接受返回的错误，但是为了简洁本文一般会忽略它。在实际的开发中，你需要检查所有返回的错误。</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>这里是一些学习在Go中使用SQL的非常好的资源：</p>
<ul>
<li><a href="http://golang.org/pkg/database/sql/" target="_blank" rel="external">database/sql documentation</a></li>
<li><a href="http://go-database-sql.org/" target="_blank" rel="external">go-database-sql tutorial</a></li>
</ul>
<p>如果你需要开始学习Go本身，下面的资源应该用得上：</p>
<ul>
<li><a href="http://tour.golang.org/" target="_blank" rel="external">The Go tour</a></li>
<li><a href="http://golang.org/doc/code.html" target="_blank" rel="external">How to write Go code</a></li>
<li><a href="http://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a></li>
</ul>
<p>因为<code>database/sql</code>的接口是sqlx的一个子集，所以本文中关于<code>database/sql</code>用法的建议同样适用于<code>sqlx</code></p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>你需要安装<strong>sqlx</strong>和数据库驱动。因为package不依赖具体数据库，推荐使用sqlite3进行学习：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> get github.com/jmoiron/sqlx</div><div class="line">$ <span class="keyword">go</span> get github.com/mattn/<span class="keyword">go</span>-sqlite3</div></pre></td></tr></table></figure>
<h3 id="Handle-Types"><a href="#Handle-Types" class="headerlink" title="Handle Types"></a>Handle Types</h3><p><code>sqlx</code>被设计成和<code>database/sql</code>用法相同。主要有4个<strong>handle types</strong>：</p>
<ul>
<li>sqlx.DB - 类似于sql.DB, 表示一个database</li>
<li>sqlx.Tx - 类似于sql.Tx, 表示一个transaction</li>
<li>sqlx.Stmt - 类似于sql.Stmt, 表示一个prepared statement</li>
<li>sqlx.NamedStmt - 表示一个支持<a href="#s-1">命名参数</a>的prepared statement</li>
</ul>
<p>Handle types均<a href="https://golang.org/doc/effective_go.html#embedding" target="_blank" rel="external">嵌入（embed）</a>了在<code>database/sql</code>中的对应类型，这意味着当你调用<code>sqlx.DB.Query</code>时，你是在调用和<code>sql.DB.Query</code>相同的代码。这使得它可以很容易被加入到现有的数据库项目中</p>
<p>另外，还有两个<strong>cursor types</strong>：</p>
<ul>
<li>sqlx.Rows - 类似于sql.Rows, Queryx返回的一个cursor</li>
<li>sqlx.Row - 类似于sql.Row, QueryRowx返回的结果</li>
</ul>
<p>sqlx.Rows包含了sql.Rows。但是因为底层实现无法调用，sqlx.Row重新部分实现了sql.Row的标准接口。</p>
<h3 id="连接到数据库"><a href="#连接到数据库" class="headerlink" title="连接到数据库"></a>连接到数据库</h3><p>一个<code>DB</code>实例并不是一个连接，而是数据库的一种抽象表示。这就是为什么创建一个DB实例不会返回error，也不会panic。它内部维护了一个<a href="#s-2">连接池</a>，当需要连接的时候才会第一次去尝试连接数据库。可以通过open方法来创建一个<code>sqlx.DB</code>，或者通过<code>NewDb</code>从已存在的<code>sql.DB</code>上创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> db *sqlx.DB</div><div class="line"> </div><div class="line"><span class="comment">// exactly the same as the built-in</span></div><div class="line">db = sqlx.Open(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// from a pre-existing sql.DB; note the required driverName</span></div><div class="line">db = sqlx.NewDb(sql.Open(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>), <span class="string">"sqlite3"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// force a connection and test that it worked</span></div><div class="line">err = db.Ping()</div></pre></td></tr></table></figure>
<p>在某些情况下，你可能会想同时打开和连接一个DB；比如说需要在初始化阶段捕捉配置问题。这个问题可以通过<code>Connect</code>来解决，它打开了一个DB并尝试调用<code>Ping</code>方法。<code>MustConnect</code>方法在遇到错误时会<code>panic</code>，适合用于正式项目。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> err error</div><div class="line"><span class="comment">// open and connect at the same time:</span></div><div class="line">db, err = sqlx.Connect(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// open and connect at the same time, panicing on error</span></div><div class="line">db = sqlx.MustConnect(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>)</div></pre></td></tr></table></figure>
<h3 id="Querying-101"><a href="#Querying-101" class="headerlink" title="Querying 101"></a>Querying 101</h3><p>sqlx中的handle types实现了与database/sql相同的基本数据库查询操作：</p>
<ul>
<li>Exec(…) (sql.Result, error) - unchanged from database/sql</li>
<li>Query(…) (*sql.Rows, error) - unchanged from database/sql</li>
<li>QueryRow(…) *sql.Row - unchanged from database/sql</li>
</ul>
<p>下面是对内置操作的扩展：</p>
<ul>
<li>MustExec() sql.Result – Exec, but panic on error</li>
<li>Queryx(…) (*sqlx.Rows, error) - Query, but return an sqlx.Rows</li>
<li>QueryRowx(…) *sqlx.Row – QueryRow, but return an sqlx.Row</li>
</ul>
<p>还有的是新的接口：</p>
<ul>
<li>Get(dest interface{}, …) error</li>
<li>Select(dest interface{}, …) error</li>
</ul>
<p>我们从未改变的接口开始，一一解释一下它们的用法</p>
<h4 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h4><p>Exec和MustExec从连接池中获取一个连接，然后在server上执行相应的查询。对于不支持ad-hoc 查询的驱动，一个prepared statement会在背后被创建来执行。在结果返回之前连接就会被归还给连接池。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">schema := <span class="string">`CREATE TABLE place (</span></div><div class="line"><span class="string">    country text,</span></div><div class="line"><span class="string">    city text NULL,</span></div><div class="line"><span class="string">    telcode integer);`</span></div><div class="line"> </div><div class="line"><span class="comment">// execute a query on the server</span></div><div class="line">result, err := db.Exec(schema)</div><div class="line"> </div><div class="line"><span class="comment">// or, you can use MustExec, which panics on error</span></div><div class="line">cityState := <span class="string">`INSERT INTO place (country, telcode) VALUES (?, ?)`</span></div><div class="line">countryCity := <span class="string">`INSERT INTO place (country, city, telcode) VALUES (?, ?, ?)`</span></div><div class="line">db.MustExec(cityState, <span class="string">"Hong Kong"</span>, <span class="number">852</span>)</div><div class="line">db.MustExec(cityState, <span class="string">"Singapore"</span>, <span class="number">65</span>)</div><div class="line">db.MustExec(countryCity, <span class="string">"South Africa"</span>, <span class="string">"Johannesburg"</span>, <span class="number">27</span>)</div></pre></td></tr></table></figure>
<p><a href="http://golang.org/pkg/database/sql/#Result" target="_blank" rel="external">结果</a>可能有两种：<br><code>LastInsertId()</code> 或者 <code>RowsAffected()</code>, 具体的返回有驱动决定。举个例子，在Mysql中，对有自增key的表进行插入操作会返回<code>LastInsertId()</code>。但是在PostgreSQL中，<code>LastInsertId()</code>只有在使用RETURNING语句的row cursor中才会返回。</p>
<h4 id="bindvars"><a href="#bindvars" class="headerlink" title="bindvars"></a>bindvars</h4><p>查询占位符<code>?</code>，内部称为绑定变量，非常重要！你应该使用这种方式来向数据库发送数据，因为它们可以防止<a href="https://en.wikipedia.org/wiki/SQL_injection" target="_blank" rel="external">SQL注入</a>攻击。<code>database/sql</code>不对查询文本做任何验证，查询语句会原封不动地和编码过的参数一起发送给server。查询语句将会首先在server上准备（被解析），除非驱动实现了一个特殊的接口。因此Bindvars是数据库各异的：</p>
<ul>
<li>MySQL uses the <strong>?</strong> variant shown above</li>
<li>PostgreSQL uses an enumerated <strong>$1</strong>, <strong>$2</strong>, etc bindvar syntax</li>
<li>SQLite accepts both <strong>?</strong> and <strong>$1</strong> syntax</li>
<li>Oracle uses a <strong>:name</strong> syntax</li>
</ul>
<p>其他数据库可能不同。你可以使用<strong>sqlx.DB.Rebind(string) string</strong>方法来获取适用于你的数据库的查询语句，入参为使用<code>?</code>作为变量绑定的查询语句。</p>
<p>一个常见的对变量绑定的误解是它是用来做插值的。其实他们只是用来做参数化，并不能用来<a href="http://use-the-index-luke.com/sql/where-clause/bind-parameters" target="_blank" rel="external">改变SQL语句的结构</a>。比如，用bindvars来参数化 字段名 或者 表名 是行不通的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// doesn't work</span></div><div class="line">db.Query(<span class="string">"SELECT * FROM ?"</span>, <span class="string">"mytable"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// also doesn't work</span></div><div class="line">db.Query(<span class="string">"SELECT ?, ? FROM people"</span>, <span class="string">"name"</span>, <span class="string">"location"</span>)</div></pre></td></tr></table></figure>
<p>###Query<br>Query是<code>database/sql</code>中执行查询主要使用的方法。该方法返回一个<code>sql.Rows</code>对象和一个<code>error</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// fetch all places from the db</span></div><div class="line">rows, err := db.Query(<span class="string">"SELECT country, city, telcode FROM place"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// iterate over each row</span></div><div class="line"><span class="keyword">for</span> rows.Next() &#123;</div><div class="line">    <span class="keyword">var</span> country <span class="keyword">string</span></div><div class="line">    <span class="comment">// note that city can be NULL, so we use the NullString type</span></div><div class="line">    <span class="keyword">var</span> city    sql.NullString</div><div class="line">    <span class="keyword">var</span> telcode <span class="keyword">int</span></div><div class="line">    err = rows.Scan(&amp;country, &amp;city, &amp;telcode)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你应该将<code>Rows</code>对象看做一个数据库cursor而不是一个结果列表。尽管数据库驱动缓存的方法不一样，通过<code>Next()</code>迭代每次获取一列结果，对于查询结果非常巨大的情况下，可以有效的限制内存的使用，因为你一次只处理一行数据。<code>Scan()</code>利用<a href="http://golang.org/pkg/reflect" target="_blank" rel="external">reflect</a>把sql每一列结果映射到go语言的数据类型如<code>string</code>，<code>[]byte</code>上。如果你没有遍历完全部的rows结果，一定要记得在把connection返回到连接池之前调用<code>rows.Close()</code>。</p>
<p>Query返回的error有可能是在server准备查询的时候发生的，也有可能是在执行查询语句的时候发生的。例如可能从连接池中获取一个坏的连接（尽管数据库会<a href="http://golang.org/src/pkg/database/sql/sql.go?s=23888:23957#L885" target="_blank" rel="external">尝试10次</a>去发现或创建一个工作连接）。一般来说，错误主要是错误的sql语句，错误的类似匹配，错误的字段名或表名。</p>
<p>在大部分情况下，<code>Rows.Scan()</code>会把从驱动获取的数据进行拷贝，无论驱动如何使用缓存。特殊类型<code>sql.RawBytes</code>可以用来从驱动返回的数据中获取一个<em>zero-copy</em>的byte slice。当下一次调用Next的时候，这个值就不再有效了，因为它指向的内存已经被驱动重写了别的数据。</p>
<p>Query使用的connection在所有的rows通过<code>Next()</code>遍历完后或者调用<code>rows.Close()</code>后释放。更多细节可以参考<a href="#s-2">连接池</a> </p>
<p>sqlx扩展的<code>Queryx</code>和<code>Query</code>行为很相似，不过返回一个<code>sqlx.Rows</code>对象，支持扩展了的scan行为。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Place <span class="keyword">struct</span> &#123;</div><div class="line">    Country       <span class="keyword">string</span></div><div class="line">    City          sql.NullString</div><div class="line">    TelephoneCode <span class="keyword">int</span> <span class="string">`db:"telcode"`</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">rows, err := db.Queryx(<span class="string">"SELECT * FROM place"</span>)</div><div class="line"><span class="keyword">for</span> rows.Next() &#123;</div><div class="line">    <span class="keyword">var</span> p Place</div><div class="line">    err = rows.StructScan(&amp;p)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sqlx.Rowx的主要扩展就是<code>StructScan</code>，可以自动把查询结果scan到对应结构体的字段上。注意结构体中的字段必须是<a href="http://golang.org/doc/effective_go.html#names" target="_blank" rel="external">可导出的</a>（首字母大写），这样sqlx才能够写入值。正如在上面代码中所示，可以利用db结构体标签来指定结构体字段对应的数据库字段名，或者用<a href="http://jmoiron.github.io/sqlx/#mapping" target="_blank" rel="external">db.MapperFunc()</a>来指定默认的映射。默认是对结构体的字段名执行<code>strings.Lower</code>后，和数据库的列名进行匹配。关于<code>StructScan</code>,<code>SliceScan</code>,<code>MapScan</code>更详细的内容请参见后面章节<a href="#s-3">advanced scanning</a>。</p>
<h3 id="QueryRow"><a href="#QueryRow" class="headerlink" title="QueryRow"></a>QueryRow</h3><p>QueryRow从数据库中获取一列数据。它从连接池中获取一个连接，然后执行Query，返回一个<code>Row</code>对象，这个对象有一个自己的内部的Rows对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">row := db.QueryRow(<span class="string">"SELECT * FROM place WHERE telcode=?"</span>, <span class="number">852</span>)</div><div class="line"><span class="keyword">var</span> telcode <span class="keyword">int</span></div><div class="line">err = row.Scan(&amp;telcode)</div></pre></td></tr></table></figure>
<p>不像Query，QueryRow只返回一个Row类型，并不返回error，如果在执行查询过程中出错，则错误通过Scan返回，如果查询结果为空，则返回<code>sql.ErrNoRows</code>。如果Scan本身出错（比如类型不匹配），error同样由scan返回。</p>
<p>结果Row中关联的Rows对象在Scan时被关闭，这意味着QueryRow使用的连接会一直保持到结果被scan。也就意味着使用QueryRow的时候不能够使用sql.RawByes，因为引用的内存属于驱动，而当控制权交给调用者（应用程序）的时候这块内存可能已经无效了。</p>
<p>QueryRowx返回一个sqlx.Row而不是sql.Row，它实现了跟Rows相同的scan方法如上，同时还有高级的scan方法如下：（更高级的scan方法<a href="#s-3">advanced scanning</a>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p Place</div><div class="line">err := db.QueryRowx(<span class="string">"SELECT city, telcode FROM place LIMIT 1"</span>).StructScan(&amp;p)</div></pre></td></tr></table></figure>
<h3 id="Get-and-Select"><a href="#Get-and-Select" class="headerlink" title="Get and Select"></a>Get and Select</h3><p><code>Get</code>和<code>Select</code>是一个非常省时的扩展。它们把query和非常灵活的scan语法结合起来。为了更加清晰的介绍它们，我们先讨论下什么是scannalbe：</p>
<ul>
<li>a value is scannable if it is not a struct, eg <strong>string</strong>, <strong>int</strong></li>
<li>a value is scannable if it implements <strong>sql.Scanner</strong></li>
<li>a value is scannable if it is a struct with no exported fields (eg. <strong>time.Time</strong>)</li>
</ul>
<p><code>Get</code>和<code>Select</code>对scannable的类型使用<code>rows.scan</code>，对non-scannable的类型使用<code>rows.StructScan</code>。他们大体上与<code>QueryRow</code>和<code>Query</code>相同，Get用来获取单个结果然后Scan，Select用来获取一系列结果（a slice of results）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">p := Place&#123;&#125;</div><div class="line">pp := []Place&#123;&#125;</div><div class="line"> </div><div class="line"><span class="comment">// this will pull the first place directly into p</span></div><div class="line">err = db.Get(&amp;p, <span class="string">"SELECT * FROM place LIMIT 1"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// this will pull places with telcode &gt; 50 into the slice pp</span></div><div class="line">err = db.Select(&amp;pp, <span class="string">"SELECT * FROM place WHERE telcode &gt; ?"</span>, <span class="number">50</span>)</div><div class="line"> </div><div class="line"><span class="comment">// they work with regular types as well</span></div><div class="line"><span class="keyword">var</span> id <span class="keyword">int</span></div><div class="line">err = db.Get(&amp;id, <span class="string">"SELECT count(*) FROM place"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// fetch at most 10 place names</span></div><div class="line"><span class="keyword">var</span> names []<span class="keyword">string</span></div><div class="line">err = db.Select(&amp;names, <span class="string">"SELECT name FROM place LIMIT 10"</span>)</div></pre></td></tr></table></figure>
<p>Get和Select在执行完查询后就会关闭Rows，并且在执行阶段遇到任何问题都会返回错误。由于它们内部使用的StructScan，所以 下文中<a href="#5">advanced scanning section</a>讲的特征也适用与Get和Select。</p>
<p>Select可以提高编码效率，但是要注意<code>Select</code>和<code>Queryx</code>是有很大不同的，因为Select会把整个结果一次放入内存。如果查询时没有控制结果的大小，那么最好使用<code>Query/StructScan</code>迭代方法。</p>
<h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h3><p>为了使用transactions，必须使用<code>DB.Begin()</code>来创建，下面的代码是错误的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// this will not work if connection pool &gt; 1</span></div><div class="line">db.MustExec(<span class="string">"BEGIN;"</span>)</div><div class="line">db.MustExec(...)</div><div class="line">db.MustExec(<span class="string">"COMMIT;"</span>)</div></pre></td></tr></table></figure>
<p>Exec和其他查询语句会向DB请求一个connection，执行完后就返回到连接池中，并不能保证每次获取的connection就是BEGIN执行时使用的那个，所以正确的做法是使用<code>DB.Begin</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tx, err := db.Begin()</div><div class="line">err = tx.Exec(...)</div><div class="line">err = tx.Commit()</div></pre></td></tr></table></figure>
<p>DB还可以使用扩展<code>Beginx()</code>和<code>MustBegin()</code>，返回<code>sqlx.Tx</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tx := db.MustBegin()</div><div class="line">tx.MustExec(...)</div><div class="line">err = tx.Commit()</div></pre></td></tr></table></figure>
<p>sqlx.Tx拥有sqlx.DB拥有的所有的handle extensions。</p>
<p>由于transaction是一个connection状态，Tx对象必须绑定和控制单个connection。一个Tx会在整个生命周期中保存一个connection，然后在调用<code>Commit()</code>或<code>Rollback()</code>的时候释放掉。你至少要调用其中一个方法，否则connection会一直被占用直到被垃圾回收。 </p>
<p>由于在一个transaction中只能有一个connection，所以每次只能执行一条语句。在执行另外的query操作之前，cursor类型对象<code>Row</code>和<code>Rows</code>必须被Scanned或Closed。如果在数据库给你返回数据的时候你尝试向数据库发送数据，这个操作可能会中断connection。</p>
<p>最后，Tx对象仅仅执行了一个BEGIN语句和绑定了一个connection，它其实并没有在server上执行任何操作。而transaction真实的行为，比如locking和<a href="http://en.wikipedia.org/wiki/Isolation_(database_systems" target="_blank" rel="external">isolation</a>)，在不同数据库上的实现是不同的。</p>
<h3 id="Prepared-Statements"><a href="#Prepared-Statements" class="headerlink" title="Prepared Statements"></a>Prepared Statements</h3><p>对于大部分的数据库来说，当一个query执行的时候，在数据库内部statements其实已经准备好了。然而你还是可以通过<code>sqlx.DB.Prepare()</code>准备statements，便于后面在别的地方重用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stmt, err := db.Prepare(<span class="string">`SELECT * FROM place WHERE telcode=?`</span>)</div><div class="line">row = stmt.QueryRow(<span class="number">65</span>)</div><div class="line"> </div><div class="line">tx, err := db.Begin()</div><div class="line">txStmt, err := tx.Prepare(<span class="string">`SELECT * FROM place WHERE telcode=?`</span>)</div><div class="line">row = txStmt.QueryRow(<span class="number">852</span>)</div></pre></td></tr></table></figure>
<p>Prepare会在数据库上执行preparation操作，所以它需要一个connection和它的connection state。 database/sql把这部分进行了抽象，自动在新的connection上创建statement，这样开发者就能通过<strong>stmt对象</strong>在多个connection上并发执行操作。<br><code>Preparex()</code>返回一个<code>sqlx.Stmt</code>对象，包含sqlx.DB和sqlx.Tx所有的handle 扩展（方法）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stmt, err := db.Preparex(<span class="string">`SELECT * FROM place WHERE telcode=?`</span>)</div><div class="line"><span class="keyword">var</span> p Place</div><div class="line">err = stmt.Get(&amp;p, <span class="number">852</span>)</div></pre></td></tr></table></figure>
<p>sql.Tx对象有一个Stmt()方法，从已存在的transaction中返回一个特定于该transaction的statement。 sqlx.Tx同样含有一个<code>Stmtx()</code>方法，从已有的<code>sql.Stmt</code>或<code>sqlx.Stmt</code>中创建一个特定于transaction的<code>sqlx.Stmt</code>。</p>
<h3 id="Query-Helpers"><a href="#Query-Helpers" class="headerlink" title="Query Helpers"></a>Query Helpers</h3><p>The database/sql package does not do anything with your actual query text. This makes it trivial to use backend-specific features in your code; you can write queries just as you would write them in your database prompt. While this is very flexible, it makes writing certain kinds of queries difficult.</p>
<h4 id="“In”-Queries"><a href="#“In”-Queries" class="headerlink" title="“In” Queries"></a>“In” Queries</h4><p>由于database/sql并不会分析你的查询语句并且会直接把参数传递给driver，这样对于<code>IN</code>的查询操作就非常麻烦了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">level</span> <span class="keyword">IN</span> (?);</div></pre></td></tr></table></figure>
<p>当这条语句在后台prepare为一个statement时，bindvar<code>?</code>对应一个参数，但是这样的查询语句往往对应的是多个参数，eg:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> levels = []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</div><div class="line">rows, err := db.Query(<span class="string">"SELECT * FROM users WHERE level IN (?);"</span>, levels)</div></pre></td></tr></table></figure>
<p>这样的情况在sqlx下可以这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> levels = []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</div><div class="line">query, args, err := sqlx.In(<span class="string">"SELECT * FROM users WHERE level IN (?);"</span>, levels)</div><div class="line"> </div><div class="line"><span class="comment">// sqlx.In returns queries with the `?` bindvar, we can rebind it for our backend</span></div><div class="line">query = db.Rebind(query)</div><div class="line">rows, err := db.Query(query, args...)</div></pre></td></tr></table></figure>
<p><code>sqlx.In</code>根据传入的参数个数扩充对应的bindvars，然后把参数放到一个新的参数列表中,然后用返回的query语句和args执行query操作。<br>这个函数只针对<code>?</code>bindvar，可以使用<code>db.Rebind</code>来获取一个适合当前数据库的query. </p>
<h3 id="s-1">Named Queries</h3>

<p>Named query对于许多数据库包是非常常见的做法。允许开发者通过引用结构体字段名或map key的bindvar语法，绑定查询语句中的值。结构体域名的名字转换规则遵循StructScan，使用<code>NameMapper</code>和<code>db</code>结构体标签。除此之外还有两个相关的Named查询：</p>
<ul>
<li>NamedQuery(…) (*sqlx.Rows, error) - like Queryx, but with named bindvars</li>
<li>NamedExec(…) (sql.Result, error) - like Exec, but with named bindvars</li>
</ul>
<p>还有一个额外的类型 :</p>
<ul>
<li>NamedStmt - an sqlx.Stmt which can be prepared with named bindvars</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// named query with a struct</span></div><div class="line">p := Place&#123;Country: <span class="string">"South Africa"</span>&#125;</div><div class="line">rows, err := db.NamedQuery(<span class="string">`SELECT * FROM place WHERE country=:country`</span>, p)</div><div class="line"> </div><div class="line"><span class="comment">// named query with a map</span></div><div class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"city"</span>: <span class="string">"Johannesburg"</span>&#125;</div><div class="line">result, err := db.NamedExec(<span class="string">`SELECT * FROM place WHERE city=:city`</span>, m)</div></pre></td></tr></table></figure>
<p>Named query execution and preparation works off both structs and maps. If you desire the full set of query verbs, prepare a named statement and use that instead:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">p := Place&#123;TelephoneCode: <span class="number">50</span>&#125;</div><div class="line">pp := []Place&#123;&#125;</div><div class="line"> </div><div class="line"><span class="comment">// select all telcodes &gt; 50</span></div><div class="line">nstmt, err := db.PrepareNamed(<span class="string">`SELECT * FROM place WHERE telcode &gt; :telcode`</span>)</div><div class="line">err = nstmt.Select(&amp;pp, p)</div></pre></td></tr></table></figure>
<p>Names query通过解析查询中的<code>:param</code>语法然后用当前数据库支持的bindvar替换，然后在执行数据库操作时按照结构体或map进行映射，所以适应于任何sqlx支持的数据库。<br>你还可以使用<code>sqlx.Names</code>（使用？bindvar）结合<code>sqlx.IN</code>执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">arg := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</div><div class="line">    <span class="string">"published"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">"authors"</span>: []&#123;<span class="number">8</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">44</span>&#125;,</div><div class="line">&#125;</div><div class="line">query, args, err := sqlx.Named(<span class="string">"SELECT * FROM articles WHERE published=:published AND author_id IN (:authors)"</span>, arg)</div><div class="line">query, args, err := sqlx.In(query, args...)</div><div class="line">query = db.Rebind(query)</div><div class="line">db.Query(query, args...)</div></pre></td></tr></table></figure>
<p></p><h3 id="s-3">Advanced Scanning</h3><br>structScan很复杂，支持embedded struct，赋值时和Go语言为嵌入属性或方法使用的优先规则一样。常用在具有相同部分的多个表模型。<p></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> AutoIncr <span class="keyword">struct</span> &#123;</div><div class="line">    ID       <span class="keyword">uint64</span></div><div class="line">    Created  time.Time</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">type</span> Place <span class="keyword">struct</span> &#123;</div><div class="line">    Address <span class="keyword">string</span></div><div class="line">    AutoIncr</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</div><div class="line">    Name <span class="keyword">string</span></div><div class="line">    AutoIncr</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上三个结构体中，Person和Place都能够通过StructScan获取<code>id</code>和<code>created</code>列，因为它们都内嵌了一个结构体<code>AutoIncr</code>，<code>AutoIncr</code>中定义了ID和Created对应列id和creatd。这种方法还支持递归，下面代码中Person的Name，以及AutoIncr的ID和Created都是可访问的，无论是Go的点操作符还是通过StructScan。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</div><div class="line">    BossID <span class="keyword">uint64</span></div><div class="line">    EmployeeID <span class="keyword">uint64</span></div><div class="line">    Person</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sqlx历史上曾经为non-embedded结构体支持过这个feature，但是发现用户使用它来定义外键（relationship）以及重复embed，这会引起困惑而不得不终止这个feature：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</div><div class="line">    Father Person</div><div class="line">    Mother Person</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Go语言中，屏蔽子域是合法的，如果结构体Employee定义一个Name，那么就会屏蔽Person的Name，但是不确定的selectors是非法的，会引起一个runtime error。如果我们想创建一个Person和Place的组合结构体，因为它们内部都有AutoIncr，我们该将<code>id</code>字段的值放在哪里？会不会有错误？</p>
<p>基于sqlx构建结构体域名到域地址映射的方法，当把列Scan到结构体时，它并不知道一个name在遍历结构体树的时候是否遇到了两次。所以不像Go语言，StructScan会选择第一个遇到的匹配name的结构体字段。由于Go结构体是从上往下排序，sqlx执行的是breadth-first traversal搜索算法，所以在下面的代码中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> PersonPlace <span class="keyword">struct</span> &#123;</div><div class="line">    Person</div><div class="line">    Place</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StrucScan会把id赋值给Person.AUtoIncr.ID。为了避免混淆，建议在SQL语句中使用AS来增加列别名。</p>
<h3 id="Scan-Destination-Safety"><a href="#Scan-Destination-Safety" class="headerlink" title="Scan Destination Safety"></a>Scan Destination Safety</h3><p>By default, StructScan will return an error if a column does not map to a field in the destination. This mimics the treatment for things like unused variables in Go, but does not match the way that standard library marshallers like encoding/json behave. Because SQL is generally executed in a more controlled fashion than parsing JSON, and these errors are generally coding errors, a decision was made to return errors by default.</p>
<p>Like unused variables, columns which you ignore are a waste of network and database resources, and detecting things like an incompatible mapping or a typo in a struct tag early can be difficult without the mapper letting you know something wasn’t found.</p>
<p>Despite this, there are some cases where ignoring columns with no destination might be desired. For this, there is the Unsafe method on each Handle type which returns a new copy of that handle whith this safety turned off:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p Person</div><div class="line"><span class="comment">// err here is not nil because there are no field destinations for columns in `place`</span></div><div class="line">err = db.Get(&amp;p, <span class="string">"SELECT * FROM person, place LIMIT 1;"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// this will NOT return an error, even though place columns have no destination</span></div><div class="line">udb := db.Unsafe()</div><div class="line">err = udb.Get(&amp;p, <span class="string">"SELECT * FROM person, place LIMIT 1;"</span>)</div></pre></td></tr></table></figure>
<h3 id="Controlling-Name-Mapping"><a href="#Controlling-Name-Mapping" class="headerlink" title="Controlling Name Mapping"></a>Controlling Name Mapping</h3><p>Struct fields used as targets for StructScans must be capitalized in order to be accessible by sqlx. Because of this, sqlx uses a NameMapper which applies strings.ToLower to field names to map them to columns in your rows result. This isn’t always desirable, depending on your schema, so sqlx allows the mapping to be customized a number of ways.</p>
<p>The simplest of these ways is to set it for a db handle by using sqlx.DB.MapperFunc, which receives an argument of type func(string) string. If your library requires a particular mapper, and you don’t want to poison the sqlx.DB you receive, you can create a copy for use in the library to ensure a particular default mapping:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if our db schema uses ALLCAPS columns, we can use normal fields</span></div><div class="line">db.MapperFunc(strings.ToUpper)</div><div class="line"> </div><div class="line"><span class="comment">// suppose a library uses lowercase columns, we can create a copy</span></div><div class="line"><span class="built_in">copy</span> := sqlx.NewDb(db.DB, db.DriverName())</div><div class="line"><span class="built_in">copy</span>.MapperFunc(strings.ToLower)</div></pre></td></tr></table></figure>
<p>Each sqlx.DB uses the sqlx/reflectx package’s Mapper to achieve this mapping underneath, and exposes the active mapper as sqlx.DB.Mapper. You can further customize the mapping on a DB by setting it directly:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/jmoiron/sqlx/reflectx"</span></div><div class="line"> </div><div class="line"><span class="comment">// Create a new mapper which will use the struct field tag "json" instead of "db"</span></div><div class="line">db.Mapper = reflectx.NewMapperFunc(<span class="string">"json"</span>, strings.ToLower)</div></pre></td></tr></table></figure>
<h3 id="Alternate-Scan-Types"><a href="#Alternate-Scan-Types" class="headerlink" title="Alternate Scan Types"></a>Alternate Scan Types</h3><p>In addition to using Scan and StructScan, an sqlx Row or Rows can be used to automatically return a slice or a map of results:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rows, err := db.Queryx(<span class="string">"SELECT * FROM place"</span>)</div><div class="line"><span class="keyword">for</span> rows.Next() &#123;</div><div class="line">    <span class="comment">// cols is an []interface&#123;&#125; of all of the column results</span></div><div class="line">    cols, err := rows.SliceScan()</div><div class="line">&#125;</div><div class="line"> </div><div class="line">rows, err := db.Queryx(<span class="string">"SELECT * FROM place"</span>)</div><div class="line"><span class="keyword">for</span> rows.Next() &#123;</div><div class="line">    results := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</div><div class="line">    err = rows.MapScan(results)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SliceScan returns an []interface{} of all columns, which can be useful in situations where you are executing queries on behalf of a third party and have no way of knowing what columns may be returned. MapScan behaves the same way, but maps the column names to interface{} values. An important caveat here is that the results returned by rows.Columns() does not include fully qualified names, such that SELECT a.id, b.id FROM a NATURAL JOIN b will result in a Columns result of []string{“id”, “id”}, clobbering one of the results in your map.</p>
<h3 id="Custom-Types"><a href="#Custom-Types" class="headerlink" title="Custom Types"></a>Custom Types</h3><p>The examples above all used the built-in types to both scan and query with, but database/sql provides interfaces to allow you to use any custom types:</p>
<ul>
<li>sql.Scanner allows you to use custom types in a Scan()</li>
<li>driver.Valuer allows you to use custom types in a Query/QueryRow/Exec</li>
</ul>
<p>These are the standard interfaces, and using them will ensure portability to any library that might be providing services on top of database/sql. For a detailed look at how to use them, read this blog post or check out the sqlx/types package, which implements a few standard useful types.</p>
<p></p><h3 id="s-2">连接池</h3><br>Statement preparation 和执行查询需要连接，DB对象管理了一个连接池让我们可以安全地执行并行查询。在Go 1.2版本中有两个方法来控制连接池的大小： <p></p>
<ul>
<li>DB.SetMaxIdleConns(n int)</li>
<li>DB.SetMaxOpenConns(n int)</li>
</ul>
<p>默认情况下，连接池可以无限增长，当连接池中没有空闲连接时新的连接就会被创建。你可以用DB.SetMaxOpenConns来设置连接池的最大值。不在使用的连接会被标记为空闲，如果不再需要连接将会被关闭。为了防止创建和关闭大量连接，你可以通过DB.SetMaxIdleConns来设置连接的最大空闲数量（要考虑到数据库的负载情况）。</p>
<blockquote>
<p>注：MaxOpenConns设置的是能创建的连接数的最大值，MaxIdleConns则是可以被复用的连接的最大值。MaxOpenConns多余MaxIdleConns的连接在使用完之后就会被close掉。上面一段原文就写得比较绕，这里补充一下辅助理解。</p>
</blockquote>
<p>很容易碰到因为不释放连接而出现的麻烦。为了防止这种情况，我们需要：</p>
<ul>
<li>Ensure you Scan() every Row object</li>
<li>Ensure you either Close() or fully-iterate via Next() every Rows object</li>
<li>Ensure every transaction returns its connection via Commit() or Rollback()</li>
</ul>
<p>如果你没做到上面说的任一点，连接会被持有直到发生gc。db会立即创建大量连接来补偿刚刚丢掉的这一个。需要注意的是Rows.Close()可以被重复调用，所以即使在可能不需要的情况下调用也是可以的，不要害怕。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/10/路由查找之Radix-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/10/路由查找之Radix-Tree/" itemprop="url">路由查找之Radix Tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-10T18:50:34+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是Radix-Tree"><a href="#什么是Radix-Tree" class="headerlink" title="什么是Radix Tree"></a>什么是Radix Tree</h2><blockquote>
<p>在计算机科学中，基数树，或称Patricia trie/tree，或crit bit tree，压缩前缀树，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。</p>
</blockquote>
<p><img src="/img/radix_tree.png" alt=""></p>
<p>golang的web框架<a href="https://github.com/labstack/echo" target="_blank" rel="external">echo</a>和<a href="https://github.com/gin-gonic/gin" target="_blank" rel="external">gin</a>都使用了<code>radix tree</code>作为路由查找的算法，我们以gin的实现来分析一下。</p>
<p>在gin的路由中，每一个<code>Http Method</code>(GET, PUT, POST…)都对应了一棵 <code>radix tree</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (engine *Engine) addRoute(method, path string, handlers HandlersChain) &#123;</div><div class="line">    // ...</div><div class="line">    </div><div class="line">    // 获取method对应的树，如果没有就创建</div><div class="line">    root := engine.trees.get(method)</div><div class="line">    if root == nil &#123;</div><div class="line">        // 创建radix tree，只有根节点</div><div class="line">        root = new(node)</div><div class="line">        engine.trees = append(engine.trees, methodTree&#123;method: method, root: root&#125;)</div><div class="line">    &#125;</div><div class="line">    root.addRoute(path, handlers)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>radix tree</code>可以被认为是一棵简洁版的前缀树。拥有共同前缀的节点也共享同一个父节点。下面是一个<code>GET</code>方法对应的路由树的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Priority   Path             Handle</div><div class="line">9          \                *&lt;1&gt;</div><div class="line">3          ├s               nil</div><div class="line">2          |├earch\         *&lt;2&gt;</div><div class="line">1          |└upport\        *&lt;3&gt;</div><div class="line">2          ├blog\           *&lt;4&gt;</div><div class="line">1          |    └:post      nil</div><div class="line">1          |         └\     *&lt;5&gt;</div><div class="line">2          ├about-us\       *&lt;6&gt;</div><div class="line">1          |        └team\  *&lt;7&gt;</div><div class="line">1          └contact\        *&lt;8&gt;</div></pre></td></tr></table></figure>
<p><code>*&lt;num&gt;</code>是方法（handler）对应的指针，从根节点遍历到叶子节点我们就能得到完整的路由表，图中的示例实现了以下路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET(&quot;/&quot;, func1)</div><div class="line">GET(&quot;/search/&quot;, func2)</div><div class="line">GET(&quot;/support/&quot;, func3)</div><div class="line">GET(&quot;/blog/&quot;, func4)</div><div class="line">GET(&quot;/blog/:post/&quot;, func5)</div><div class="line">GET(&quot;/about-us/&quot;, func6)</div><div class="line">GET(&quot;/about-us/team/&quot;, func7)</div><div class="line">GET(&quot;/contact/&quot;, func8)</div></pre></td></tr></table></figure>
<p><code>:post</code>是真实的<code>post name</code>的一个占位符（就是一个参数）。这里体现了radix tree相较于hash-map的一个优点，树结构允许我们的路径中存在动态的部分（参数）,因为我们匹配的是路由的模式而不是hash值</p>
<p>为了更具扩展性，每一层的节点按照priority排序，priority是节点的子节点（儿子节点，孙子节点等）注册的handler的数量，这样做有两个好处：</p>
<ol>
<li>被最多路径包含的节点会被最先评估。这样可以让尽量多的路由快速被定位。</li>
<li>有点像成本补偿。最长的路径可以被最先评估，补偿体现在最长的路径需要花费更长的时间来定位，如果最长路径的节点能被优先评估（即每次拿子节点都命中），那么所花时间不一定比短路径的路由长。下面展示了节点（每个<code>-</code>可以看做一个节点）评估的路径：从左到右，从上到下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">├------------</div><div class="line">├---------</div><div class="line">├-----</div><div class="line">├----</div><div class="line">├--</div><div class="line">├--</div><div class="line">└-</div></pre></td></tr></table></figure>
<h2 id="节点数据结构"><a href="#节点数据结构" class="headerlink" title="节点数据结构"></a>节点数据结构</h2><p>节点的数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">type node struct &#123;</div><div class="line">    // 节点路径，比如上面的s，earch，和upport</div><div class="line">    path      string</div><div class="line">    // 节点是否是参数节点，比如上面的:post</div><div class="line">    wildChild bool</div><div class="line">    // 节点类型，包括static, root, param, catchAll</div><div class="line">    // static: 静态节点，比如上面的s，earch等节点</div><div class="line">    // root: 树的根节点</div><div class="line">    // catchAll: 有*匹配的节点</div><div class="line">    // param: 参数节点</div><div class="line">    nType     nodeType</div><div class="line">    // 路径上最大参数个数</div><div class="line">    maxParams uint8</div><div class="line">    // 和children字段对应, 保存的是分裂的分支的第一个字符</div><div class="line">    // 例如search和support, 那么s节点的indices对应的&quot;eu&quot;</div><div class="line">    // 代表有两个分支, 分支的首字母分别是e和u</div><div class="line">    indices   string</div><div class="line">    // 儿子节点</div><div class="line">    children  []*node</div><div class="line">    // 处理函数</div><div class="line">    handlers  HandlersChain</div><div class="line">    // 优先级，子节点注册的handler数量</div><div class="line">    priority  uint32</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line">func (n *node) addRoute(path string, handlers HandlersChain) &#123;</div><div class="line">    fullPath := path</div><div class="line">    n.priority++</div><div class="line">    numParams := countParams(path)</div><div class="line"></div><div class="line">    // non-empty tree</div><div class="line">    if len(n.path) &gt; 0 || len(n.children) &gt; 0 &#123;</div><div class="line">    walk:</div><div class="line">        for &#123;</div><div class="line">            // Update maxParams of the current node</div><div class="line">            if numParams &gt; n.maxParams &#123;</div><div class="line">                n.maxParams = numParams</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Find the longest common prefix.</div><div class="line">            // This also implies that the common prefix contains no &apos;:&apos; or &apos;*&apos;</div><div class="line">            // since the existing key can&apos;t contain those chars.</div><div class="line">            i := 0</div><div class="line">            max := min(len(path), len(n.path))</div><div class="line">            for i &lt; max &amp;&amp; path[i] == n.path[i] &#123;</div><div class="line">                i++</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Split edge</div><div class="line">            // 开始分裂，比如一开始path是search，新来了support，s是他们匹配的部分，</div><div class="line">            // 那么会将s拿出来作为parent节点，增加earch和upport作为child节点</div><div class="line">            if i &lt; len(n.path) &#123;</div><div class="line">                child := node&#123;</div><div class="line">                    path:      n.path[i:],  // 不匹配的部分作为child节点</div><div class="line">                    wildChild: n.wildChild,</div><div class="line">                    indices:   n.indices,</div><div class="line">                    children:  n.children,</div><div class="line">                    handlers:  n.handlers,</div><div class="line">                    priority:  n.priority - 1,  // 降级成子节点，priority减1</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Update maxParams (max of all children)</div><div class="line">                for i := range child.children &#123;</div><div class="line">                    if child.children[i].maxParams &gt; child.maxParams &#123;</div><div class="line">                        child.maxParams = child.children[i].maxParams</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                // 当前节点的子节点变成刚刚分裂的出来的节点</div><div class="line">                n.children = []*node&#123;&amp;child&#125;</div><div class="line">                // []byte for proper unicode char conversion, see #65</div><div class="line">                n.indices = string([]byte&#123;n.path[i]&#125;)</div><div class="line">                n.path = path[:i]</div><div class="line">                n.handlers = nil</div><div class="line">                n.wildChild = false</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Make new node a child of this node</div><div class="line">            // 将新来的节点插入新的parent节点作为子节点</div><div class="line">            if i &lt; len(path) &#123;</div><div class="line">                path = path[i:]</div><div class="line"></div><div class="line">					// 如果是参数节点（包含:或*）</div><div class="line">                if n.wildChild &#123;</div><div class="line">                    n = n.children[0]</div><div class="line">                    n.priority++</div><div class="line"></div><div class="line">                    // Update maxParams of the child node</div><div class="line">                    if numParams &gt; n.maxParams &#123;</div><div class="line">                        n.maxParams = numParams</div><div class="line">                    &#125;</div><div class="line">                    numParams--</div><div class="line"></div><div class="line">                    // Check if the wildcard matches</div><div class="line">                    // 例如：/blog/:pp 和 /blog/:ppp，需要检查更长的通配符</div><div class="line">                    if len(path) &gt;= len(n.path) &amp;&amp; n.path == path[:len(n.path)] &#123;</div><div class="line">                        // check for longer wildcard, e.g. :name and :names</div><div class="line">                        if len(n.path) &gt;= len(path) || path[len(n.path)] == &apos;/&apos; &#123;</div><div class="line">                            continue walk</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    panic(&quot;path segment &apos;&quot; + path +</div><div class="line">                        &quot;&apos; conflicts with existing wildcard &apos;&quot; + n.path +</div><div class="line">                        &quot;&apos; in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">					// 首字母，用来与indices做比较</div><div class="line">                c := path[0]</div><div class="line"></div><div class="line">                // slash after param</div><div class="line">                if n.nType == param &amp;&amp; c == &apos;/&apos; &amp;&amp; len(n.children) == 1 &#123;</div><div class="line">                    n = n.children[0]</div><div class="line">                    n.priority++</div><div class="line">                    continue walk</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Check if a child with the next path byte exists</div><div class="line">                // 判断子节点中是否有和当前path有匹配的，只需要查看子节点path的第一个字母即可，即indices</div><div class="line">                // 比如s的子节点现在是earch和upport，indices为eu</div><div class="line">                // 如果新来的路由为super，那么就是和upport有匹配的部分u，将继续分类现在的upport节点</div><div class="line">                for i := 0; i &lt; len(n.indices); i++ &#123;</div><div class="line">                    if c == n.indices[i] &#123;</div><div class="line">                        i = n.incrementChildPrio(i)</div><div class="line">                        n = n.children[i]</div><div class="line">                        continue walk</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Otherwise insert it</div><div class="line">                if c != &apos;:&apos; &amp;&amp; c != &apos;*&apos; &#123;</div><div class="line">                    // []byte for proper unicode char conversion, see #65</div><div class="line">                    // 记录第一个字符，放在indices中</div><div class="line">                    n.indices += string([]byte&#123;c&#125;)</div><div class="line">                    child := &amp;node&#123;</div><div class="line">                        maxParams: numParams,</div><div class="line">                    &#125;</div><div class="line">                    // 增加子节点</div><div class="line">                    n.children = append(n.children, child)</div><div class="line">                    n.incrementChildPrio(len(n.indices) - 1)</div><div class="line">                    n = child</div><div class="line">                &#125;</div><div class="line">                n.insertChild(numParams, path, fullPath, handlers)</div><div class="line">                return</div><div class="line"></div><div class="line">            &#125; else if i == len(path) &#123; // Make node a (in-path) leaf</div><div class="line">                // 路径相同，如果已有handler就报错，没有就赋值</div><div class="line">                if n.handlers != nil &#123;</div><div class="line">                    panic(&quot;handlers are already registered for path &apos;&apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">                &#125;</div><div class="line">                n.handlers = handlers</div><div class="line">            &#125;</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123; // Empty tree，空树，插入节点，节点种类是root</div><div class="line">        n.insertChild(numParams, path, fullPath, handlers)</div><div class="line">        n.nType = root</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此函数的主要目的是找到插入节点的位置，如果和现有节点存在相同的前缀，那么要将现有节点进行分裂，然后再插入，下面是<code>insertChild</code>函数</p>
<h2 id="插入子节点"><a href="#插入子节点" class="headerlink" title="插入子节点"></a>插入子节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line">// @1: 参数个数</div><div class="line">// @2: 路径</div><div class="line">// @3: 完整路径</div><div class="line">// @4: 处理函数</div><div class="line">func (n *node) insertChild(numParams uint8, path string, fullPath string, handlers HandlersChain) &#123;</div><div class="line">    var offset int // already handled bytes of the path</div><div class="line"></div><div class="line">    // find prefix until first wildcard (beginning with &apos;:&apos;&apos; or &apos;*&apos;&apos;)</div><div class="line">    // 找到前缀，只要匹配到wildcard</div><div class="line">    for i, max := 0, len(path); numParams &gt; 0; i++ &#123;</div><div class="line">        c := path[i]</div><div class="line">        if c != &apos;:&apos; &amp;&amp; c != &apos;*&apos; &#123;</div><div class="line">            continue</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // find wildcard end (either &apos;/&apos; or path end)</div><div class="line">        end := i + 1</div><div class="line">        for end &lt; max &amp;&amp; path[end] != &apos;/&apos; &#123;</div><div class="line">            switch path[end] &#123;</div><div class="line">            // the wildcard name must not contain &apos;:&apos; and &apos;*&apos;</div><div class="line">            case &apos;:&apos;, &apos;*&apos;:</div><div class="line">                panic(&quot;only one wildcard per path segment is allowed, has: &apos;&quot; +</div><div class="line">                    path[i:] + &quot;&apos; in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">            default:</div><div class="line">                end++</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // check if this Node existing children which would be</div><div class="line">        // unreachable if we insert the wildcard here</div><div class="line">        if len(n.children) &gt; 0 &#123;</div><div class="line">            panic(&quot;wildcard route &apos;&quot; + path[i:end] +</div><div class="line">                &quot;&apos; conflicts with existing children in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // check if the wildcard has a name</div><div class="line">        if end-i &lt; 2 &#123;</div><div class="line">            panic(&quot;wildcards must be named with a non-empty name in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if c == &apos;:&apos; &#123; // param</div><div class="line">            // split path at the beginning of the wildcard</div><div class="line">            if i &gt; 0 &#123;</div><div class="line">                n.path = path[offset:i]</div><div class="line">                offset = i</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            child := &amp;node&#123;</div><div class="line">                nType:     param,</div><div class="line">                maxParams: numParams,</div><div class="line">            &#125;</div><div class="line">            n.children = []*node&#123;child&#125;</div><div class="line">            n.wildChild = true</div><div class="line">            n = child</div><div class="line">            n.priority++</div><div class="line">            numParams--</div><div class="line"></div><div class="line">            // if the path doesn&apos;t end with the wildcard, then there</div><div class="line">            // will be another non-wildcard subpath starting with &apos;/&apos;</div><div class="line">            if end &lt; max &#123;</div><div class="line">                n.path = path[offset:end]</div><div class="line">                offset = end</div><div class="line">                </div><div class="line">                child := &amp;node&#123;</div><div class="line">                    maxParams: numParams,</div><div class="line">                    priority:  1,</div><div class="line">                &#125;</div><div class="line">                n.children = []*node&#123;child&#125;</div><div class="line">                // 下次循环这个新的child节点</div><div class="line">                n = child</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; else &#123; // catchAll</div><div class="line">            if end != max || numParams &gt; 1 &#123;</div><div class="line">                panic(&quot;catch-all routes are only allowed at the end of the path in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if len(n.path) &gt; 0 &amp;&amp; n.path[len(n.path)-1] == &apos;/&apos; &#123;</div><div class="line">                panic(&quot;catch-all conflicts with existing handle for the path segment root in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // currently fixed width 1 for &apos;/&apos;</div><div class="line">            i--</div><div class="line">            if path[i] != &apos;/&apos; &#123;</div><div class="line">                panic(&quot;no / before catch-all in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            n.path = path[offset:i]</div><div class="line"></div><div class="line">            // first node: catchAll node with empty path</div><div class="line">            child := &amp;node&#123;</div><div class="line">                wildChild: true,</div><div class="line">                nType:     catchAll,</div><div class="line">                maxParams: 1,</div><div class="line">            &#125;</div><div class="line">            n.children = []*node&#123;child&#125;</div><div class="line">            n.indices = string(path[i])</div><div class="line">            n = child</div><div class="line">            n.priority++</div><div class="line"></div><div class="line">            // second node: node holding the variable</div><div class="line">            child = &amp;node&#123;</div><div class="line">                path:      path[i:],</div><div class="line">                nType:     catchAll,</div><div class="line">                maxParams: 1,</div><div class="line">                handlers:  handlers,</div><div class="line">                priority:  1,</div><div class="line">            &#125;</div><div class="line">            n.children = []*node&#123;child&#125;</div><div class="line"></div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // insert remaining path part and handle to the leaf</div><div class="line">    n.path = path[offset:]</div><div class="line">    n.handlers = handlers</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>insertChild</code>函数是根据<code>path</code>本身进行分割, 将<code>/</code>分开的部分分别作为节点保存, 形成一棵树结构. 注意参数匹配中的<code>:</code>和<code>*</code>的区别, 前者是匹配一个字段, 后者是匹配后面所有的路径</p>
<h2 id="路径查找"><a href="#路径查找" class="headerlink" title="路径查找"></a>路径查找</h2><p>匹配每个children的path，最长匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line">// Returns the handle registered with the given path (key). The values of</div><div class="line">// wildcards are saved to a map.</div><div class="line">// If no handle can be found, a TSR (trailing slash redirect) recommendation is</div><div class="line">// made if a handle exists with an extra (without the) trailing slash for the</div><div class="line">// given path.</div><div class="line">func (n *node) getValue(path string, po Params, unescape bool) (handlers HandlersChain, p Params, tsr bool) &#123;</div><div class="line">    p = po</div><div class="line">walk: // Outer loop for walking the tree</div><div class="line">    for &#123;</div><div class="line">        // 尚未到达path的终点</div><div class="line">        if len(path) &gt; len(n.path) &#123;</div><div class="line">            // 前面一段需要一致</div><div class="line">            if path[:len(n.path)] == n.path &#123;</div><div class="line">                path = path[len(n.path):]</div><div class="line">                // If this node does not have a wildcard (param or catchAll)</div><div class="line">                // child,  we can just look up the next child node and continue</div><div class="line">                // to walk down the tree</div><div class="line">                if !n.wildChild &#123;</div><div class="line">                    c := path[0]</div><div class="line">                    for i := 0; i &lt; len(n.indices); i++ &#123;</div><div class="line">                        if c == n.indices[i] &#123;</div><div class="line">                            n = n.children[i]</div><div class="line">                            continue walk</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // Nothing found.</div><div class="line">                    // We can recommend to redirect to the same URL without a</div><div class="line">                    // trailing slash if a leaf exists for that path.</div><div class="line">                    tsr = (path == &quot;/&quot; &amp;&amp; n.handlers != nil)</div><div class="line">                    return</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // handle wildcard child</div><div class="line">                n = n.children[0]</div><div class="line">                switch n.nType &#123;</div><div class="line">                case param:</div><div class="line">                    // find param end (either &apos;/&apos; or path end)</div><div class="line">                    end := 0</div><div class="line">                    for end &lt; len(path) &amp;&amp; path[end] != &apos;/&apos; &#123;</div><div class="line">                        end++</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // save param value</div><div class="line">                    if cap(p) &lt; int(n.maxParams) &#123;</div><div class="line">                        p = make(Params, 0, n.maxParams)</div><div class="line">                    &#125;</div><div class="line">                    i := len(p)</div><div class="line">                    p = p[:i+1] // expand slice within preallocated capacity</div><div class="line">                    p[i].Key = n.path[1:]</div><div class="line">                    val := path[:end]</div><div class="line">                    if unescape &#123;</div><div class="line">                        var err error</div><div class="line">                        if p[i].Value, err = url.QueryUnescape(val); err != nil &#123;</div><div class="line">                            p[i].Value = val // fallback, in case of error</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        p[i].Value = val</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // we need to go deeper!</div><div class="line">                                        if end &lt; len(path) &#123;</div><div class="line">                        if len(n.children) &gt; 0 &#123;</div><div class="line">                            path = path[end:]</div><div class="line">                            n = n.children[0]</div><div class="line">                            continue walk</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        // ... but we can&apos;t</div><div class="line">                        tsr = (len(path) == end+1)</div><div class="line">                        return</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if handlers = n.handlers; handlers != nil &#123;</div><div class="line">                        return</div><div class="line">                    &#125;</div><div class="line">                    if len(n.children) == 1 &#123;</div><div class="line">                        // No handle found. Check if a handle for this path + a</div><div class="line">                        // trailing slash exists for TSR recommendation</div><div class="line">                        n = n.children[0]</div><div class="line">                        tsr = (n.path == &quot;/&quot; &amp;&amp; n.handlers != nil)</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    return</div><div class="line"></div><div class="line">                case catchAll:</div><div class="line">                    // save param value</div><div class="line">                    if cap(p) &lt; int(n.maxParams) &#123;</div><div class="line">                        p = make(Params, 0, n.maxParams)</div><div class="line">                    &#125;</div><div class="line">                    i := len(p)</div><div class="line">                    p = p[:i+1] // expand slice within preallocated capacity</div><div class="line">                    p[i].Key = n.path[2:]</div><div class="line">                    if unescape &#123;</div><div class="line">                        var err error</div><div class="line">                        if p[i].Value, err = url.QueryUnescape(path); err != nil &#123;</div><div class="line">                            p[i].Value = path // fallback, in case of error</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        p[i].Value = path</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    handlers = n.handlers</div><div class="line">                    return</div><div class="line"></div><div class="line">                default:</div><div class="line">                    panic(&quot;invalid node type&quot;)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else if path == n.path &#123;</div><div class="line">            // We should have reached the node containing the handle.</div><div class="line">            // Check if this node has a handle registered.</div><div class="line">            if handlers = n.handlers; handlers != nil &#123;</div><div class="line">                return</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if path == &quot;/&quot; &amp;&amp; n.wildChild &amp;&amp; n.nType != root &#123;</div><div class="line">                tsr = true</div><div class="line">                return</div><div class="line">            &#125;</div><div class="line">            // No handle found. Check if a handle for this path + a</div><div class="line">            // trailing slash exists for trailing slash recommendation</div><div class="line">            for i := 0; i &lt; len(n.indices); i++ &#123;</div><div class="line">                if n.indices[i] == &apos;/&apos; &#123;</div><div class="line">                    n = n.children[i]</div><div class="line">                    tsr = (len(n.path) == 1 &amp;&amp; n.handlers != nil) ||</div><div class="line">                        (n.nType == catchAll &amp;&amp; n.children[0].handlers != nil)</div><div class="line">                    return</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Nothing found. We can recommend to redirect to the same URL with an</div><div class="line">        // extra trailing slash if a leaf exists for that path</div><div class="line">        tsr = (path == &quot;/&quot;) ||</div><div class="line">            (len(n.path) == len(path)+1 &amp;&amp; n.path[len(path)] == &apos;/&apos; &amp;&amp;</div><div class="line">                path == n.path[:len(n.path)-1] &amp;&amp; n.handlers != nil)</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前总听大家说数据结构与算法有什么用，工作中又用不到，上面就是一个很好的示例。我们平时还是要多关注底层原理，做后端的同学多看看框架的代码，一定受益匪浅~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/go-pprof-采样何时进行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/go-pprof-采样何时进行/" itemprop="url">go pprof 采样何时进行</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T15:20:36+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	_ <span class="string">"net/http/pprof"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		log.Println(http.ListenAndServe(<span class="string">"localhost:6060"</span>, <span class="literal">nil</span>))</div><div class="line">	&#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码大家应该都很熟悉，<code>go tool pprof</code>工具的通用代码，用来做性能等分析。我这两天尝试用了一下，不免有了一个疑问：<code>pprof</code>是要采样的，这个采样是何时进行的？是程序启动就开始采样还是当我<code>curl localhost:$PORT/debug/pprof/$PROFILE_TYPE</code>开始？</p>
<p>为什么会考虑这个呢，主要是在看的框架里集成了<code>pprof</code>，默认打开，如果是程序一开始就采样，那对于性能是有损耗的。这种问题别人回答你，你也不一定相信，我们还是来看看<code>pprof</code>的代码吧。</p>
<p>标准库的代码是在<code>$GOROOT/src</code>下面，我们找一下<code>pprof</code>，在我的mac上路径是<code>/usr/local/Cellar/go/1.9.2/libexec/src/net/http/pprof/pprof.go</code></p>
<p>首先是<code>init</code>函数，注册了我们用到的分析urls：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">    http.Handle(<span class="string">"/debug/pprof/"</span>, http.HandlerFunc(Index))</div><div class="line">    http.Handle(<span class="string">"/debug/pprof/cmdline"</span>, http.HandlerFunc(Cmdline))</div><div class="line">    http.Handle(<span class="string">"/debug/pprof/profile"</span>, http.HandlerFunc(Profile))</div><div class="line">    http.Handle(<span class="string">"/debug/pprof/symbol"</span>, http.HandlerFunc(Symbol))</div><div class="line">    http.Handle(<span class="string">"/debug/pprof/trace"</span>, http.HandlerFunc(Trace))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是在程序启动就执行的，这也是我们感觉只要import就万事大吉的原因。其实看到这里应该就明白了，profile只是普通的函数调用而已，程序启动只是注册了handler，真正的采样应该是在请求之后执行的。</p>
<p>但是来都来了，我们不妨往下看看，毕竟需要看标准库的机会不多。我们来看一下<code>cpu profile</code>，也就是<code>Profile</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Profile responds with the pprof-formatted cpu profile.</span></div><div class="line"><span class="comment">// The package initialization registers it as /debug/pprof/profile.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Profile</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">    sec, _ := strconv.ParseInt(r.FormValue(<span class="string">"seconds"</span>), <span class="number">10</span>, <span class="number">64</span>)</div><div class="line">    <span class="keyword">if</span> sec == <span class="number">0</span> &#123;</div><div class="line">        sec = <span class="number">30</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> durationExceedsWriteTimeout(r, <span class="keyword">float64</span>(sec)) &#123;</div><div class="line">        w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/plain; charset=utf-8"</span>)</div><div class="line">        w.Header().Set(<span class="string">"X-Go-Pprof"</span>, <span class="string">"1"</span>)</div><div class="line">        w.WriteHeader(http.StatusBadRequest)</div><div class="line">        fmt.Fprintln(w, <span class="string">"profile duration exceeds server's WriteTimeout"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Set Content Type assuming StartCPUProfile will work,</span></div><div class="line">    <span class="comment">// because if it does it starts writing.</span></div><div class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>)</div><div class="line">    <span class="keyword">if</span> err := pprof.StartCPUProfile(w); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="comment">// StartCPUProfile failed, so no writes yet.</span></div><div class="line">        <span class="comment">// Can change header back to text content</span></div><div class="line">        <span class="comment">// and send error code.</span></div><div class="line">        w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/plain; charset=utf-8"</span>)</div><div class="line">        w.Header().Set(<span class="string">"X-Go-Pprof"</span>, <span class="string">"1"</span>)</div><div class="line">        w.WriteHeader(http.StatusInternalServerError)</div><div class="line">        fmt.Fprintf(w, <span class="string">"Could not enable CPU profiling: %s\n"</span>, err)</div><div class="line">                <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    sleep(w, time.Duration(sec)*time.Second)</div><div class="line">    pprof.StopCPUProfile()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取了一个默认30秒的时间，执行<code>StartCPUProfile</code>，里面应该是个<code>goroutine</code>，调用返回后sleep了一下，结束<code>cpu profile</code>。采样应该是在<code>StartCPUProfile</code>，执行seconds时间。</p>
<p>再来看看<code>StartCPUProfile</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartCPUProfile</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="comment">// The runtime routines allow a variable profiling rate,</span></div><div class="line">    <span class="comment">// but in practice operating systems cannot trigger signals</span></div><div class="line">    <span class="comment">// at more than about 500 Hz, and our processing of the</span></div><div class="line">    <span class="comment">// signal is not cheap (mostly getting the stack trace).</span></div><div class="line">    <span class="comment">// 100 Hz is a reasonable choice: it is frequent enough to</span></div><div class="line">    <span class="comment">// produce useful data, rare enough not to bog down the</span></div><div class="line">    <span class="comment">// system, and a nice round number to make it easy to</span></div><div class="line">    <span class="comment">// convert sample counts to seconds. Instead of requiring</span></div><div class="line">    <span class="comment">// each client to specify the frequency, we hard code it.</span></div><div class="line">    <span class="keyword">const</span> hz = <span class="number">100</span></div><div class="line"></div><div class="line">    cpu.Lock()</div><div class="line">    <span class="keyword">defer</span> cpu.Unlock()</div><div class="line">    <span class="keyword">if</span> cpu.done == <span class="literal">nil</span> &#123;</div><div class="line">        cpu.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Double-check.</span></div><div class="line">    <span class="keyword">if</span> cpu.profiling &#123;</div><div class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cpu profiling already in use"</span>)</div><div class="line">    &#125;</div><div class="line">    cpu.profiling = <span class="literal">true</span></div><div class="line">    runtime.SetCPUProfileRate(hz)</div><div class="line">    <span class="keyword">go</span> profileWriter(w)</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注释解释了取样频率的由来，我们先看一下CPU主频的概念：</p>
<blockquote>
<p>CPU的主频，即CPU内核工作的时钟频率（CPU Clock Speed）。CPU的主频的基本单位是赫兹（Hz），但更多的是以兆赫兹（MHz）或吉赫兹（GHz）为单位。时钟频率的倒数即为时钟周期。时钟周期的基本单位为秒（s），但更多的是以毫秒（ms）、微妙（us）或纳秒（ns）为单位。在一个时钟周期内，CPU执行一条运算指令。也就是说，在1000 Hz的CPU主频下，每1毫秒可以执行一条CPU运算指令。在1 MHz的CPU主频下，每1微妙可以执行一条CPU运算指令。而在1 GHz的CPU主频下，每1纳秒可以执行一条CPU运算指令。</p>
</blockquote>
<p>在默认情况下，Go语言的运行时系统会以100 Hz的的频率对CPU使用情况进行取样。也就是说每秒取样100次，即每10毫秒会取样一次。为什么使用这个频率呢？因为100 Hz既足够产生有用的数据，又不至于让系统产生停顿。并且100这个数上也很容易做换算，比如把总取样计数换算为每秒的取样数。实际上，这里所说的对CPU使用情况的取样就是对当前的Goroutine的堆栈上的程序计数器的取样。由此，我们就可以从样本记录中分析出哪些代码是计算时间最长或者说最耗CPU资源的部分了。</p>
<p>代码很容易理解，锁住cpu，设置runtime的采样频率，<code>profileWriter</code>就是实际采样了。</p>
<p>所以结论是，采样在请求之后才会进行，线上打开采样的接口没有问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="external">Profiling Go Programs</a></li>
<li><a href="https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/" target="_blank" rel="external">Profiling Go programs with pprof</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/go-command-tutorial/0.12.html" target="_blank" rel="external">go tool pprof</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/05/go语言死循环分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/05/go语言死循环分析/" itemprop="url">go语言死循环分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-05T12:18:55+08:00">
                2017-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近看了一篇文章，<a href="https://gocn.io/article/441" target="_blank" rel="external">如何定位 golang 进程 hang 死的 bug</a>，里面有这样一段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"io"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    <span class="string">"runtime"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    runtime.GOMAXPROCS(runtime.NumCPU())</div><div class="line">    <span class="keyword">go</span> server()</div><div class="line">    <span class="keyword">go</span> printNum()</div><div class="line">    <span class="keyword">var</span> i = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        <span class="comment">// will block here, and never go out</span></div><div class="line">        i++</div><div class="line">    &#125;</div><div class="line">    fmt.Println(<span class="string">"for loop end"</span>)</div><div class="line">    time.Sleep(time.Second * <span class="number">3600</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNum</span><span class="params">()</span></span> &#123;</div><div class="line">    i := <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        fmt.Println(i)</div><div class="line">        i++</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class="line">    fmt.Println(<span class="string">"hello world"</span>)</div><div class="line">    io.WriteString(w, <span class="string">"hello, world!\n"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</div><div class="line">    http.HandleFunc(<span class="string">"/"</span>, HelloServer)</div><div class="line">    err := http.ListenAndServe(<span class="string">":12345"</span>, <span class="literal">nil</span>)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行，会发现打印一会儿数字后停了，我们执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl localhost:12345</div></pre></td></tr></table></figure>
<p>程序卡死。关于程序挂在哪里借助<code>dlv</code>是很好定位的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dlv debug hang.go</div></pre></td></tr></table></figure>
<p>进去之后运行程序，打印停止进入卡死状态，我们执行<code>ctrl C</code>，<code>dlv</code>会显示断开的地方：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">received SIGINT, stopping process (will not forward signal)&gt; main.main() ./hang.<span class="keyword">go</span>:<span class="number">17</span> (PC: <span class="number">0x12dd</span>7c8)</div><div class="line">    <span class="number">12</span>: <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="number">13</span>:         runtime.GOMAXPROCS(runtime.NumCPU())</div><div class="line">    <span class="number">14</span>:         <span class="keyword">go</span> server()</div><div class="line">    <span class="number">15</span>:         <span class="keyword">go</span> printNum()</div><div class="line">    <span class="number">16</span>:         <span class="keyword">var</span> i = <span class="number">1</span></div><div class="line">=&gt;  <span class="number">17</span>:         <span class="keyword">for</span> &#123;</div><div class="line">    <span class="number">18</span>:                 <span class="comment">// will block here, and never go out</span></div><div class="line">    <span class="number">19</span>:                 i++</div><div class="line">    <span class="number">20</span>:         &#125;</div><div class="line">    <span class="number">21</span>:         fmt.Println(<span class="string">"for loop end"</span>)</div><div class="line">    <span class="number">22</span>:         time.Sleep(time.Second * <span class="number">3600</span>)</div><div class="line">(dlv)</div></pre></td></tr></table></figure>
<p>但是我还是不明白，不明白的地方主要是因为：</p>
<ul>
<li>我又看了两篇文章<a href="http://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/" target="_blank" rel="external">Goroutine调度实例简要分析</a>和<a href="http://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="external">也谈goroutine调度器</a>，是同一位作者Tony Bai写的，写得非常好。第二篇文章解释了goroutine的调度和cpu数量的关系（不多加解释，建议大家看看），我的mac是双核四线程（这里不明白的同学自行google cpu 超线程），go版本是1.9，理论上讲可以跑4个goroutine而不用考虑死循环，一个死循环最多把一个cpu打死，上面的代码中只有3个goroutine，而且他们看上去都挂住了。</li>
<li>上面说的理论上讲，不是我主观臆测的，我跑了<code>1</code>中<a href="http://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/" target="_blank" rel="external">第一篇文章</a>中的一个例子:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadloop</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">go</span> deadloop()</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        time.Sleep(time.Second * <span class="number">1</span>)</div><div class="line">        fmt.Println(<span class="string">"I got scheduled!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码有两个goroutine，一个是<code>main goroutine</code>，一个是<code>deadloop goroutine</code>，跑得时候<code>deadloop gouroutine</code>不会对<code>main goroutine</code>造成影响，打印一直在持续，作者的文章解释了原因。</p>
<ul>
<li><a href="https://gocn.io/article/441" target="_blank" rel="external">如何定位 golang 进程 hang 死的 bug</a>这篇文章提到了<code>gcwaiting</code>，然而没有解释。</li>
</ul>
<p>在<a href="https://gocn.io/article/441" target="_blank" rel="external">如何定位 golang 进程 hang 死的 bug</a>有这样一段话：</p>
<blockquote>
<p>因为在 for 循环中没有函数调用的话，编译器不会插入调度代码，所以这个执行 for 循环的 goroutine 没有办法被调出，而在循环期间碰到 gc，那么就会卡在 gcwaiting 阶段，并且整个进程永远 hang 死在这个循环上。并不再对外响应。</p>
</blockquote>
<p>这个其实就是我们的第一段代码卡死的原因，也是我们第二段代码没有卡死的原因，就是在<code>gc</code>上！</p>
<p>我们再看一篇文章，<a href="https://studygolang.com/articles/9004" target="_blank" rel="external">golang的垃圾回收（GC）机制</a>，这篇文章很短，但每句话都很重要：</p>
<blockquote>
<ol>
<li>设置gcwaiting=1，这个在每一个G任务之前会检查一次这个状态，如是，则会将当前M 休眠；</li>
<li>如果这个M里面正在运行一个长时间的G任务，咋办呢，难道会等待这个G任务自己切换吗？这样的话可要等10ms啊，不能等！坚决不能等！<br>所以会主动发出抢占标记（类似于上一篇），让当前G任务中断，再运行下一个G任务的时候，就会走到第1步</li>
</ol>
</blockquote>
<p>那么如果这时候运行的是没有函数调用的死循环呢，gc也发出了抢占标记，但是如果死循环没有函数调用，就没有地方被标记，无法被抢占，那就只能设置<code>gcwaiting=1</code>，而<strong>M没有休眠</strong>，<code>stop the world</code>卡住了（死锁），<code>gcwaiting</code>一直是1，整个程序都卡住了！</p>
<p>这里其实已经解释了第一份代码的现象，第二份代码为什么没有hang住相信大家也能猜到了：代码里没有触发gc！我们来手动触发一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    _ <span class="string">"net/http/pprof"</span></div><div class="line">    <span class="comment">// "runtime"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadloop</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">        log.Println(http.ListenAndServe(<span class="string">"localhost:6060"</span>, <span class="literal">nil</span>))</div><div class="line">    &#125;()</div><div class="line">    <span class="keyword">go</span> deadloop()</div><div class="line">    i := <span class="number">3</span></div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        time.Sleep(time.Second * <span class="number">1</span>)</div><div class="line">        i--</div><div class="line">        fmt.Println(<span class="string">"I got scheduled!"</span>)</div><div class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</div><div class="line">            runtime.GC()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会发现打印了3行之后，程序也卡死了，bingo🎉</p>
<p>我们来看看<code>gcwaiting</code>是不是等于1:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> go build hang2.go</div><div class="line"></div><div class="line"><span class="meta">$</span> GODEBUG="schedtrace=300,scheddetail=1" ./hang2</div><div class="line"></div><div class="line">SCHED 2443ms: gomaxprocs=4 idleprocs=3 threads=7 spinningthreads=0 idlethreads=2 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0</div><div class="line">  P0: status=1 schedtick=4 syscalltick=5 m=5 runqsize=0 gfreecnt=1</div><div class="line">  P1: status=0 schedtick=14 syscalltick=0 m=-1 runqsize=0 gfreecnt=0</div><div class="line">  P2: status=0 schedtick=3 syscalltick=4 m=-1 runqsize=0 gfreecnt=0</div><div class="line">......  </div><div class="line">SCHED 2751ms: gomaxprocs=4 idleprocs=0 threads=7 spinningthreads=0 idlethreads=2 runqueue=0 gcwaiting=1 nmidlelocked=0 stopwait=1 sysmonwait=0</div><div class="line">  P0: status=1 schedtick=4 syscalltick=5 m=5 runqsize=0 gfreecnt=1</div><div class="line">  P1: status=3 schedtick=14 syscalltick=0 m=-1 runqsize=0 gfreecnt=0</div><div class="line">  P2: status=3 schedtick=3 syscalltick=10 m=-1 runqsize=0 gfreecnt=0</div><div class="line">  P3: status=3 schedtick=1 syscalltick=26 m=0 runqsize=0 gfreecnt=0</div><div class="line">  M6: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 helpgc=0 spinning=false blocked=false lockedg=-1</div><div class="line">  M5: p=0 curg=19 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 helpg</div></pre></td></tr></table></figure>
<p>代码诚不欺我也！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://gocn.io/article/441" target="_blank" rel="external">如何定位 golang 进程 hang 死的 bug</a></li>
<li><a href="http://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/" target="_blank" rel="external">Goroutine调度实例简要分析</a></li>
<li><a href="http://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="external">也谈goroutine调度器</a></li>
<li><a href="https://studygolang.com/articles/9004" target="_blank" rel="external">golang的垃圾回收（GC）机制</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/27/hystrix-go简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/27/hystrix-go简介/" itemprop="url">hystrix-go简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T17:45:44+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/afex/hystrix-go" target="_blank" rel="external">hystrix</a>是一个容错库，旨在隔离指向远程系统，服务和第三方库的请求，杜绝级联故障，并在复杂的分布式系统中实现弹性，毕竟在分布式系统中，故障是不可避免的。</p>
<p>此项目脱胎于由Netflix开源的同名java项目。<a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">https://github.com/Netflix/Hystrix</a></p>
<h3 id="像Hystrix命令一样执行代码"><a href="#像Hystrix命令一样执行代码" class="headerlink" title="像Hystrix命令一样执行代码"></a>像Hystrix命令一样执行代码</h3><p>定义依赖于外部系统的应用逻辑，将函数传给<code>Go</code>。当外部系统处于健康状态，这个函数将是唯一被执行的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hystrix.Go(<span class="string">"my_command"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// talk to other services</span></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;, <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<h3 id="定义fallback行为"><a href="#定义fallback行为" class="headerlink" title="定义fallback行为"></a>定义fallback行为</h3><p>如果希望外部系统挂了的时候执行一些动作，可以给<code>Go</code>传递第二个函数。理想情况下，这里的逻辑可以让你的应用优雅地处理外部系统不可用的情况。</p>
<p>当第一个函数返回error，或者在一系列健康检查的情况下函数无法运行结束，都会触发fallback。更详细的<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works" target="_blank" rel="external">参考在这里</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">hystrix.Go(<span class="string">"my_command"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// talk to other services</span></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// do this when services are down</span></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="等待输出"><a href="#等待输出" class="headerlink" title="等待输出"></a>等待输出</h3><p>调用<code>Go</code>就像执行了一个goroutine，除了你能获取到一个error的channel并且监控它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">output := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</div><div class="line">errors := hystrix.Go(<span class="string">"my_command"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// talk to other services</span></div><div class="line">	output &lt;- <span class="literal">true</span></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;, <span class="literal">nil</span>)</div><div class="line"></div><div class="line"><span class="keyword">select</span> &#123;</div><div class="line"><span class="keyword">case</span> out := &lt;-output:</div><div class="line">	<span class="comment">// success</span></div><div class="line"><span class="keyword">case</span> err := &lt;-errors:</div><div class="line">	<span class="comment">// failure</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="同步API"><a href="#同步API" class="headerlink" title="同步API"></a>同步API</h3><p>调用一个借口并且等待返回是一个常见的场景（对应于goroutine），Hystrix提供了一个<code>Do</code>函数，返回一个error</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">err := hystrix.Do(&quot;my_command&quot;, func() error &#123;</div><div class="line">	// talk to other services</div><div class="line">	return nil</div><div class="line">&#125;, nil)</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在应用启动期间，你可以调用<code>ConfigureCommand</code>来为每个command添加配置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hystrix.ConfigureCommand(<span class="string">"my_command"</span>, hystrix.CommandConfig&#123;</div><div class="line">	Timeout:               <span class="number">1000</span>,</div><div class="line">	MaxConcurrentRequests: <span class="number">100</span>,</div><div class="line">	ErrorPercentThreshold: <span class="number">25</span>,</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>也有别的配置方法，更详细的介绍请参考官方文档。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>最后给大家举个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"github.com/afex/hystrix-go/hystrix"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	hystrix.Go(<span class="string">"get_baidu"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">		<span class="comment">// talk to other services</span></div><div class="line">		_, err := http.Get(<span class="string">"https://www.baidu.com/"</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			fmt.Println(<span class="string">"get error"</span>)</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</div><div class="line">		fmt.Println(<span class="string">"get an error, handle it"</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;)</div><div class="line"> </div><div class="line">	time.Sleep(<span class="number">2</span> * time.Second)  <span class="comment">// 调用Go方法就是起了一个goroutine，这里要sleep一下，不然看不到效果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>网络请求，大家把网络断开后就能够模拟外部服务挂掉的情况。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>熔断机制在分布式系统中几乎是必备的组件，下面总结一下：</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>hystrix作用在客户端，客户端程序依赖hystrix相关的第三方包，使得客户端与所依赖的服务，形成隔离(goroutine的隔离)。依赖服务的延迟与失败变的可控。保护调用者goroutine的执行。</p>
</li>
<li><p>避免了分布式系统中，单个组件的失败导致的级联影响。</p>
</li>
<li><p>快速失败，迅速恢复。  hystrix有快速失败机制，单个组件服务失败率到一定程度后，再请求，会直接响应失败。再这之后，会有重试机制。减少系统在错误服务调用上的开销。</p>
</li>
<li><p>降级应用</p>
</li>
</ol>
<h4 id="hystrix的设计原则"><a href="#hystrix的设计原则" class="headerlink" title="hystrix的设计原则"></a>hystrix的设计原则</h4><ol>
<li><p>防止任何单个依赖服务耗尽所有用户线程</p>
</li>
<li><p>直接响应失败，而不是一直等待</p>
</li>
<li><p>提供错误返回接口，而不是让用户线程直接处理依赖服务抛出的异常</p>
</li>
<li><p>使用隔离或熔断技术来降低并限制单个依赖对整个系统造成的影响</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/15/golang数据库相关的几个package的关系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/15/golang数据库相关的几个package的关系/" itemprop="url">golang数据库相关的几个package的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T19:45:04+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>挑orm的过程中不知不觉被搞晕了，怎么那么多相关的package，下面我们来理一理这些package的关系</p>
<ul>
<li>database/sql</li>
<li><a href="https://github.com/go-sql-driver/mysql/" target="_blank" rel="external">https://github.com/go-sql-driver/mysql/</a></li>
<li><a href="https://github.com/jmoiron/sqlx" target="_blank" rel="external">https://github.com/jmoiron/sqlx</a></li>
</ul>
<h3 id="database-sql"><a href="#database-sql" class="headerlink" title="database/sql"></a>database/sql</h3><p><code>database/sql</code>是go的一个标准库，提供了一些sql数据库的通用接口。它需要和数据库驱动一起使用，<a href="https://github.com/golang/go/wiki/SQLDrivers" target="_blank" rel="external">这里</a>是一个数据库驱动的列表。</p>
<p>对于mysql而言，我们最常用的是<a href="https://github.com/go-sql-driver/mysql/" target="_blank" rel="external">https://github.com/go-sql-driver/mysql/</a></p>
<h3 id="driver数据库驱动"><a href="#driver数据库驱动" class="headerlink" title="driver数据库驱动"></a>driver数据库驱动</h3><p>数据库驱动具体是什么呢？</p>
<p>每一个数据库都有一套客户端-服务端的通信协议。作为客户端，如果要从数据库中查询/插入数据，就要遵循这套协议，按照协议格式发送请求。显然，让每个用户实现协议非常浪费而不切实际。所以数据库作者提供了一个软件（或者说package），这个软件实现了协议，并且暴露出了一些API接口供客户端与数据库交互，这个软件就是数据库驱动。</p>
<p>驱动有标准，比如ODBC和JDBC，符合标准的驱动会实现一套相同的API接口，这样即使更换了数据库，客户端也不需要变更。</p>
<p>另外显而易见的是，驱动是语言相关的，不同的编程语言操作数据库需要对应语言实现的数据库驱动。所以驱动主要就是实现了与数据库交互的协议，当我们使用时，一般会这么写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">        <span class="string">"database/sql"</span></div><div class="line"></div><div class="line">        _ <span class="string">"github.com/go-sql-driver/mysql"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// mysql是驱动的名字</span></div><div class="line">        db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"username:passwd@/test?charset=utf8"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">		  _ <span class="string">"github.com/go-sql-driver/mysql"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>会执行init函数，将mysql驱动注册到<code>database/sql</code>中的<code>drivers</code>中去，drivers是一个map：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drivers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]driver.Driver)</div></pre></td></tr></table></figure>
<p>显然，我们可以注册多个驱动，如果我们后端使用了不同的数据库的话，比如同时使用了<code>mysql</code>和<code>postgresql</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">        <span class="string">"database/sql"</span></div><div class="line"></div><div class="line">        _ <span class="string">"github.com/go-sql-driver/mysql"</span></div><div class="line">        _ <span class="string">"github.com/lib/pq"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// mysql和postgres是驱动的名字</span></div><div class="line">        my_db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"username:passwd@/test?charset=utf8"</span>)</div><div class="line">        postgre_db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"username:passwd@/test?charset=utf8"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sqlx"><a href="#sqlx" class="headerlink" title="sqlx"></a>sqlx</h3><p>sql是标准库<code>database/sql</code>的一个扩展，提供了一些更友好的接口，但是并没有过度封装，很多人放弃使用各种orm转而使用了<code>sqlx</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/03/go-scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/03/go-scope/" itemprop="url">go语言作用域踩坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-03T20:15:38+08:00">
                2017-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天饭饭给我出了个题目，下面这段代码为什么报错，怎么改？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</div><div class="line">    s <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> a *A</div><div class="line"></div><div class="line">    <span class="keyword">if</span> check(a) &#123;</div><div class="line">        a, err := generate()</div><div class="line">        fmt.Println(a.s, err)</div><div class="line">    &#125;</div><div class="line">    fmt.Println(a.s)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span> <span class="params">(*A, error)</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;A&#123;s: <span class="string">"b"</span>&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(a *A)</span> <span class="title">bool</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行一下，发现报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">panic: runtime error: invalid memory address or nil pointer dereference</div><div class="line">[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x1095520]</div><div class="line"></div><div class="line">goroutine 1 [running]:</div><div class="line">main.main()</div><div class="line">        /go_code/src/go_examples/go_scope.go:18 +0x280</div><div class="line">exit status 2</div></pre></td></tr></table></figure>
<p>18行，也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Println(a.s)</div></pre></td></tr></table></figure>
<p>报错了，报错没法提供更多信息（go新手，老鸟可能能看出端倪），我们加一些打印</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> a *A</div><div class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;a)      <span class="comment">// 1</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> check(a) &#123;</div><div class="line">        a, err := generate()</div><div class="line">        fmt.Printf(<span class="string">"%p\n"</span>, &amp;a)  <span class="comment">// 2</span></div><div class="line">        fmt.Println(a.s, err)   <span class="comment">// 3</span></div><div class="line">    &#125;</div><div class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;a)      <span class="comment">// 4</span></div><div class="line">    fmt.Println(a.s)            </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0xc42000c028   // 1</div><div class="line">0xc42000c038   // 2</div><div class="line">b &lt;nil&gt;        // 3</div><div class="line">0xc42000c028   // 4</div></pre></td></tr></table></figure>
<p>我们发现，2处的<code>a</code>竟然不是我们定义的（1处）<code>a</code>，发生了什么！</p>
<p>其实看到这里很多人可能都明白了，其实是<code>a, err := generate()</code>里面<code>:=</code>的问题，我们最初的设想是golang会定义新变量<code>err</code>，而<code>a</code>为初始定义的那个变量（1处）。但实际情况是，对于使用<code>:=</code>定义的变量，如果新变量与那个同名已定义变量 (这里就是1处的变量<code>a</code>)不在一个作用域中时，那么golang会重新定义这个变量，这就是导致这个问题的真凶。</p>
<p>怎么改呢，我们重写一下<code>main</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> a *A</div><div class="line">    <span class="keyword">var</span> err error</div><div class="line"></div><div class="line">    <span class="keyword">if</span> check(a) &#123;</div><div class="line">        a, err = generate()</div><div class="line">        fmt.Println(a.s, err)</div><div class="line">    &#125;</div><div class="line">    fmt.Println(a.s)            </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此即可~</p>
<p>这个坑真的非常容易踩，而且不太好发现，感谢饭饭🙏</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/17/Docker数据管理-Volume，-bind-mount和tmpfs-mount/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/17/Docker数据管理-Volume，-bind-mount和tmpfs-mount/" itemprop="url">Docker数据管理-Volume， bind mount和tmpfs mount</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-17T20:52:02+08:00">
                2017-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们可以将数据写到容器的可写入层，但是这种写入是有缺点的：</p>
<ul>
<li>当容器停止运行时，写入的数据会丢失。你也很难将这些数据从容器中取出来给另外的应用程序使用。</li>
<li>容器的可写入层与宿主机是紧密耦合的。这些写入的数据在可以轻易地被删掉。</li>
<li>写入容器的可写入层需要一个<a href="https://docs.docker.com/engine/userguide/storagedriver/" target="_blank" rel="external">存储驱动</a>（<code>storage driver</code>）来管理文件系统。这个存储驱动通过linux内核提供了一个<code>union filesystem</code>。相比于数据卷（<code>data volume</code>），这种额外的抽象会降低性能。</li>
</ul>
<p>Docker提供了3种方法将数据从Docker宿主机挂载（mount）到容器：<code>volumes</code>，<code>bind mounts</code>和<code>tmpfs mounts</code>。一般来说，<code>volumes</code>总是最好的选择。</p>
<p>##选择合适的挂载方式</p>
<p>不管你选择哪种挂载方式，从容器中看都是一样的。数据在容器的文件系统中被展示为一个目录或者一个单独的文件。</p>
<p>一个简单区分<code>volumes</code>，<code>bind mounts</code>和<code>tmpfs mounts</code>不同点的方法是：思考数据在宿主机上是如何存在的。</p>
<p><img src="/img/types-of-mounts.png" alt="different mount"></p>
<ul>
<li><strong>Volumes</strong>由Docker管理，存储在宿主机的某个地方（在linux上是<code>/var/lib/docker/volumes/</code>）。非Docker应用程序不能改动这一位置的数据。Volumes是Docker最好的数据持久化方法。</li>
<li><strong>Bind mounts</strong>的数据可以存放在宿主机的任何地方。数据甚至可以是重要的系统文件或目录。非Docker应用程序可以改变这些数据。</li>
<li><strong>tmpfs mounts</strong>的数据只存储在宿主机的内存中，不会写入到宿主机的文件系统。</li>
</ul>
<h2 id="更详细的Diff"><a href="#更详细的Diff" class="headerlink" title="更详细的Diff"></a>更详细的Diff</h2><ul>
<li><p><strong>Volumes</strong>：由Docker创建和管理。你可以通过<code>docker volume create</code>命令显式地创建<code>volume</code>，Docker也可以在创建容器或服务是自己创建volume。</p>
<p>当你创建了一个volume，它会被存放在宿主机的一个目录下。当你将这个volume挂载到某个容器时，这个目录就是挂载到容器的东西。这一点和<code>bind mounts</code>类似，除了volumes是由Docker创建的，和宿主机的核心（<code>core functionality</code>）隔离。</p>
<p>一个volume可以同时被挂载到几个容器中。即使没有正在运行的容器使用这个volume，volume依然存在，不会被自动清除。可以通过<code>docker volume prune</code>清除不再使用的volumes。</p>
<p>volumes也支持<code>volume driver</code>，可以将数据存放在另外的机器或者云上。</p>
</li>
<li><p><strong>Bind mounts</strong>：Docker早期就支持这个特性。与volumes相比，<code>Bind mounts</code>支持的功能有限。使用<code>bind mounts</code>时，宿主机上的一个文件或目录被挂载到容器上。</p>
<blockquote>
<p>警告：使用<code>Bind mounts</code>的一个副作用是，容器中运行的程序可以修改宿主机的文件系统，包括创建，修改，删除重要的系统文件或目录。这个功能可能会有安全问题。</p>
</blockquote>
</li>
<li><p><strong>tmpfs mounts</strong>：<code>tmpfs mounts</code>的数据不会落盘。在容器的生命周期内，它可以被用来存储一些不需要持久化的状态或敏感数据。例如，<code>swarm</code>服务通过<code>tmpfs mounts</code>来将<a href="https://docs.docker.com/engine/swarm/secrets/" target="_blank" rel="external">secrets</a>挂载到一个服务的容器中去。</p>
</li>
</ul>
<h2 id="适合Volumes的场景"><a href="#适合Volumes的场景" class="headerlink" title="适合Volumes的场景"></a>适合Volumes的场景</h2><ul>
<li>在不同的容器中共享数据。If you don’t explicitly create it, a volume is created the first time it is mounted into a container. When that container stops or is removed, the volume still exists. Multiple containers can mount the same volume simultaneously, either read-write or read-only. <strong>Volumes are only removed when you explicitly remove them</strong>.</li>
<li>When the Docker host is not guaranteed to have a given directory or file structure. Volumes help you decouple the configuration of the Docker host from the container runtime.</li>
<li>When you want to store your container’s data on a remote host or a cloud provider, rather than locally.</li>
<li>当你需要备份或迁移数据的时候，When you need to be able to back up, restore, or migrate data from one Docker host to another, volumes are a better choice. You can stop containers using the volume, then back up the volume’s directory (such as /var/lib/docker/volumes/<volume-name>).</volume-name></li>
</ul>
<h2 id="适合bind-mounts的场景"><a href="#适合bind-mounts的场景" class="headerlink" title="适合bind mounts的场景"></a>适合bind mounts的场景</h2><ul>
<li>宿主机和容器共享配置文件。Docker提供的DNS解决方案就是如此，将宿主机的<code>/etc/resolv.conf</code>挂载到每个容器中。</li>
<li>开发环境需要在宿主机和容器中共享代码。docker的开发就是如此，毕竟容器中一般是没有编辑器的</li>
<li>When the file or directory structure of the Docker host is guaranteed to be consistent with the bind mounts the containers require.</li>
</ul>
<h2 id="适合tmpfs-mounts的场景"><a href="#适合tmpfs-mounts的场景" class="headerlink" title="适合tmpfs mounts的场景"></a>适合tmpfs mounts的场景</h2><p><code>tmpfs mounts</code>主要用在你既不想在容器内，又不想在宿主机文件系统保存数据的时候。这可能是出于安全原因，也可能是你的应用需要写非常多的非持久化数据，<code>tmpfs mounts</code>这时候可以保证容器性能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/16/docker-swarm部署应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/16/docker-swarm部署应用/" itemprop="url">docker swarm部署应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-16T21:42:58+08:00">
                2017-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="什么是swarm"><a href="#什么是swarm" class="headerlink" title="什么是swarm"></a>什么是swarm</h3><p>一个<code>swarm</code>就是一组运行<code>Docker</code>并组成集群的机器。之后，你继续运行以前使用的<code>Docker命令</code>，但现在它们是由<code>swarm manager</code>(也是一台机器，执行<code>docker swarm init</code>的就是<code>manager</code>)在集群上执行。集群中的机器可以是物理机或虚拟机。加入集群后，它们被称为<code>节点</code>（node）。</p>
<p><code>swarm manager</code>可以使用几种策略来运行容器，例如“最空的节点”（<code>empties node</code>） - 将容器放到利用率最低的机器上。或者“全局”（<code>global</code>）模式，它确保每台机器只能获得指定容器的一个实例。你通过在<code>compose文件</code>来指示<code>swarm manager</code>使用这些策略。</p>
<p><code>swarm manager</code>是集群中唯一可以执行命令的机器，也是唯一可以授权其他机器作为<code>worker</code>加入集群的机器。<code>worker</code>只提供<code>capacity</code>，它无法告诉任何其他机器它可以做什么和不能做什么。</p>
<h3 id="什么是slack"><a href="#什么是slack" class="headerlink" title="什么是slack"></a>什么是slack</h3><p><code>stack</code>是一组相互关联的服务，可以被一起编排。<code>单个stack</code>能够定义整个应用程序的功能（尽管非常复杂的应用程序可能希望使用多个stack）。</p>
<h2 id="Set-up-your-swarm"><a href="#Set-up-your-swarm" class="headerlink" title="Set up your swarm"></a>Set up your swarm</h2><p>一个<code>swarm</code>由很多<code>node</code>组成，<code>node</code>可以是物理机或虚拟机。基本概念很简单：运行<code>docker swarm init</code>启用集群模式，使当前的机器成为<code>manager</code>，然后在其他机器上运行<code>docker swarm join</code>，使他们以<code>worker</code>身份加入集群。</p>
<h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>我们可以在本机创建几台虚拟机来创建我们的集群（需要安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">VirtualBox</a>）</p>
<p>首先，使用<code>docker-machine</code>命令，通过<code>VirtualBox</code>驱动创建两台虚拟机，<code>myvm1</code>和<code>myvm2</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> docker-machine create --driver virtualbox myvm1</div><div class="line"><span class="meta">$</span> docker-machine create --driver virtualbox myvm2</div></pre></td></tr></table></figure>
<p>我们将<code>myvm1</code>用作manager，它可以执行docker命令和授权别的worker加入swarm，<code>myvm2</code>将作为worker。</p>
<p>登录<code>docker-machine</code>创建的虚拟机可以使用<code>docker-machine ssh命令</code>,下面我们设置<code>myvm1</code>为manager：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜  docker-machine ls</div><div class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</div><div class="line">myvm1   -        virtualbox   Running   tcp://192.168.99.101:2376           v17.06.2-ce</div><div class="line">myvm2   -        virtualbox   Running   tcp://192.168.99.102:2376           v17.06.2-ce</div><div class="line">➜  docker-machine ssh myvm1 "docker swarm init --advertise-addr 192.168.99.101:2377"</div><div class="line"></div><div class="line">Swarm initialized: current node (u5e02o4thu4uurxm9w71kxtu5) is now a manager.</div><div class="line"></div><div class="line">To add a worker to this swarm, run the following command:</div><div class="line"></div><div class="line">    docker swarm join --token SWMTKN-1-02sp63h6alkj7sd57dkv6omkyvkb60y05delt5zvkspe0293ao-dtmm6kqjzbbe33jmo03yrml8t 192.168.99.101:2377</div><div class="line"></div><div class="line">To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</div></pre></td></tr></table></figure>
<p>可以看到，返回值中已经有了一个配置好的<code>docker swarm join</code>命令，复制这个命令，在myvm2上执行，使myvm2加入你的swarm作为worker：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  docker-machine ssh myvm2 "docker swarm join --token SWMTKN-1-02sp63h6alkj7sd57dkv6omkyvkb60y05delt5zvkspe0293ao-dtmm6kqjzbbe33jmo03yrml8t 192.168.99.101:2377"</div><div class="line">This node joined a swarm as a worker.</div></pre></td></tr></table></figure>
<p>🎉，我们的第一个<code>swarm</code>创建成功了。</p>
<p>我们可以登上<code>myvm1</code>去看看现在的节点情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜  docker-machine ssh myvm1</div><div class="line">                        ##         .</div><div class="line">                  ## ## ##        ==</div><div class="line">               ## ## ## ## ##    ===</div><div class="line">           /"""""""""""""""""\___/ ===</div><div class="line">      ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~</div><div class="line">           \______ o           __/</div><div class="line">             \    \         __/</div><div class="line">              \____\_______/</div><div class="line"> _                 _   ____     _            _</div><div class="line">| |__   ___   ___ | |_|___ \ __| | ___   ___| | _____ _ __</div><div class="line">| '_ \ / _ \ / _ \| __| __) / _` |/ _ \ / __| |/ / _ \ '__|</div><div class="line">| |_) | (_) | (_) | |_ / __/ (_| | (_) | (__|   &lt;  __/ |</div><div class="line">|_.__/ \___/ \___/ \__|_____\__,_|\___/ \___|_|\_\___|_|</div><div class="line">Boot2Docker version 17.06.2-ce, build HEAD : ff16afa - Wed Sep  6 00:17:25 UTC 2017</div><div class="line">Docker version 17.06.2-ce, build cec0b72</div><div class="line"></div><div class="line">docker@myvm1:~$ docker node ls</div><div class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS</div><div class="line">ggr9eji9z868qrorwerufrr45     myvm2               Ready               Active</div><div class="line">u5e02o4thu4uurxm9w71kxtu5 *   myvm1               Ready               Active              Leader</div></pre></td></tr></table></figure>
<p>一目了然，现在有两个node，myvm1是作为leader存在</p>
<h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>我们使用<a href="https://github.com/michaelyou/docker_swarm_deploy" target="_blank" rel="external">这个</a>简单的python应用来作为部署对象，你完全可以使用自己的应用程序(但还是建议用我使用的这个程序，这个应用打印了container的hostname，这是下面负载均衡的一个测试)。</p>
<p>首先将<code>docker-compose.yml</code>拷贝到<code>myvm1</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine scp docker-compose.yml myvm1:~</div></pre></td></tr></table></figure>
<p>然后就是部署了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker-machine ssh myvm1 "docker stack deploy -c docker-compose.yml firstswarmapp"</div><div class="line"></div><div class="line">Creating service firstswarmapp_visualizer</div><div class="line">Creating service firstswarmapp_redis</div><div class="line">Creating service firstswarmapp_web</div></pre></td></tr></table></figure>
<p>这时候部署已经完成了，我们来看看成果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜  docker-machine ssh myvm1 "docker stack ls"</div><div class="line">NAME                SERVICES</div><div class="line">firstswarmapp       1</div><div class="line">➜  docker-machine ssh myvm1 "docker stack ps firstswarmapp"</div><div class="line">ID                  NAME                  IMAGE                         NODE                DESIRED STATE       CURRENT STATE                  ERROR               PORTS</div><div class="line">ID                  NAME                         IMAGE                             NODE                DESIRED STATE       CURRENT STATE                 ERROR                              PORTS</div><div class="line">6lfkdnzq27yf        firstswarmapp_redis.1        redis:latest                      myvm1               Running             Running 43 seconds ago</div><div class="line">ui2tdail0fxv        firstswarmapp_visualizer.1   dockersamples/visualizer:stable   myvm1               Running             Running 2 minutes ago</div><div class="line">901cprboy06k        firstswarmapp_web.1          michaelyou/friendlyhello:v1       myvm2               Running             Running 33 minutes ago</div><div class="line">uvju8t48sc2s        firstswarmapp_web.2          michaelyou/friendlyhello:v1       myvm2               Running             Running 33 minutes ago</div><div class="line">sk2z91e4yn9x        firstswarmapp_web.3          michaelyou/friendlyhello:v1       myvm1               Running             Running 34 minutes ago</div><div class="line">tuzdxnfyofyc        firstswarmapp_web.4          michaelyou/friendlyhello:v1       myvm2               Running             Running 33 minutes ago</div><div class="line">715at7211p8k        firstswarmapp_web.5          michaelyou/friendlyhello:v1       myvm1               Running             Running 34 minutes ago</div></pre></td></tr></table></figure>
<p>可以看到，我们一共有7个<code>container</code>。<code>web</code>5个，分布在两台机器上，<code>redis</code>和<code>visualizer</code>各一个，在<code>manager节点</code>上。这和我们在<code>docker-compose.yml</code>中定义的一样。</p>
<p><code>myvm1</code>和<code>myvm2</code>的地址都可以访问我们的应用。你创建的网络在它们之间是共享，并且负载平衡的。运行<code>docker-machine ls</code>来获取你的虚拟机的IP地址，并在浏览器上访问它们，并刷新。你会看到五个可能的容器ID，它们随机循环，显示了负载平衡的存在。</p>
<p>两个IP地址都能工作的原因是群集中的节点加入了一个入口路由网格（routing mesh）。这样可以确保在集群中某个端口部署的服务始终将该端口保留给其自己，无论实际运行容器的是哪个节点。以下是在一个三节点集群的8080端口上部署的名为my-web的服务的路由网格示意图：</p>
<p><img src="/img/ingress-routing-mesh.png" alt="ingress-routing-mesh"></p>
<p>如果想要增加容器个数，只要修改<code>docker-compose.yml</code>文件中的replicas的数量，然后重新执行deploy就可以了。</p>
<p>如果要加入新的node，只要在新的机器上执行我们在<code>myvm2</code>上执行的<code>docker swarm join</code>命令就可以了，加入新的节点后，重新执行deploy，我们就能用上新的机器了（注意要重新执行deploy，不会自动deploy，这一点和elasticsearch等软件不一样）。</p>
<p>因为我们部署了visualizer，可以通过网页来看看我们集群现在的情况：</p>
<p><img src="/img/my_swarm.png" alt="my swarm"></p>
<p>跟<code>docker stack ps</code>输出是一致的。</p>
<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>清理stack</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine ssh myvm1 "docker stack rm firstswarmapp"</div></pre></td></tr></table></figure>
<p>这时候swarm还是在的，清理swarm：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine ssh myvm1 "docker swarm leave --force"</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/12/docker源码分析1-cli/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/12/docker源码分析1-cli/" itemprop="url">docker源码分析（一）-cli</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-12T20:41:10+08:00">
                2017-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Docker代码更新很快，网上各位大神的源码解析很多已经是几年前的版本了。实现上有了很大改变，加之Docker项目更名为<a href="https://github.com/moby/moby" target="_blank" rel="external">moby</a>，其中很多组件又从moby中拆分了出来，一开始看简直是一脸懵逼啊。在这里跟大家分享了一下最近看的<a href="https://github.com/docker/cli" target="_blank" rel="external">docker/cli</a>的源码，抛砖引玉，欢迎大家批评指正。</p>
<p>分析的<code>docker client</code>版本是<code>17.06.2-ce</code>。</p>
<p><code>docker client</code>是Docker的客户端程序，也就是我们敲的<code>docker * *</code> 命令，我们通过他与<code>docker deamon</code>程序进行交互。可以将他看成一个普通的客户端程序，docker的核心<code>namespace</code>和<code>cgroup</code>等技术都不在这里。</p>
<h2 id="搭建docker-client开发环境"><a href="#搭建docker-client开发环境" class="headerlink" title="搭建docker-client开发环境"></a>搭建docker-client开发环境</h2><p><code>docker_client</code>的开发环境也是在容器中，项目已经给我们做好了封装，具体可以参考项目Readme的<a href="https://github.com/docker/cli#development" target="_blank" rel="external">Development</a>章节。</p>
<p>问几个问题，大家可以思考一下：</p>
<h4 id="1-开发是在容器中，可是容器里面连编辑器都没有，怎么开发？"><a href="#1-开发是在容器中，可是容器里面连编辑器都没有，怎么开发？" class="headerlink" title="1. 开发是在容器中，可是容器里面连编辑器都没有，怎么开发？"></a>1. 开发是在容器中，可是容器里面连编辑器都没有，怎么开发？</h4><p>答： 准确来说应该是在容器中调试，开发还是在本地开发，容器中看到的目录是我们本地目录mount进去的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> docker.Makefile文件</div><div class="line"></div><div class="line">......</div><div class="line">MOUNTS = -v "$(CURDIR)":/go/src/github.com/docker/cli</div><div class="line">......</div><div class="line"><span class="meta">#</span> start container in interactive mode for in-container development</div><div class="line">.PHONY: dev</div><div class="line">dev: build_docker_image</div><div class="line">    docker run -ti --security-opt=seccomp:unconfined $(ENVVARS) $(MOUNTS) \</div><div class="line">        -v /var/run/docker.sock:/var/run/docker.sock \</div><div class="line">        $(DEV_DOCKER_IMAGE_NAME) ash</div><div class="line"></div><div class="line">shell: dev</div><div class="line">......</div></pre></td></tr></table></figure>
<p>从shell里面还是很容器看出来的，run的时候mount了<code>$(CURDIR)</code></p>
<h4 id="2-容器里面是不是还装了一个docker啊，为什么我在里面敲命令有响应？"><a href="#2-容器里面是不是还装了一个docker啊，为什么我在里面敲命令有响应？" class="headerlink" title="2. 容器里面是不是还装了一个docker啊，为什么我在里面敲命令有响应？"></a>2. 容器里面是不是还装了一个docker啊，为什么我在里面敲命令有响应？</h4><p>答：不是的，里面只有你编译生成的docker client程序，是没有docker deamon程序，至于为什么能响应，还是看上面的shell脚本，<code>-v /var/run/docker.sock:/var/run/docker.sock</code>这一行将<code>docker.sock</code>文件也mount了进去，<code>docker.sock</code>是<code>docker deamon</code>默认监听的Unix套接字（Unix domain socket），容器中的进程可以通过他与docker deamon进行通信。所以这里docker client通信的是你本机的docker daemon。</p>
<p><img src="/img/docker_deamon_socket.png" alt="docker_deamon_socket"></p>
<blockquote>
<p>Note: 关于<code>/var/run/docker.sock</code>更多内容可以看<a href="https://medium.com/lucjuggery/about-var-run-docker-sock-3bfd276e12fd" target="_blank" rel="external">这里</a></p>
</blockquote>
<p>所以我们的开发流程是：本地改代码–&gt;到container中编译–&gt;运行docker client看效果</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>是时候表演真正的技术了！</p>
<p>😆，开个玩笑，下面的分析如果有问题，还请大家不吝赐教！</p>
<p>我尽量把文件路径列出来，会贴一些代码，但主要还是路径，建议大家把代码clone下来照着看。</p>
<p>docker—client是基于<a href="https://github.com/spf13/cobra" target="_blank" rel="external">cobra</a>写的，建议大家先看一下cobra，至少写个<code>hello world</code>熟悉一下基本用法。</p>
<p>我们开始了！</p>
<p>入口文件在<code>cmd/docker/docker.go</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 日志输出采用了第三方库logrus</span></div><div class="line">    <span class="comment">// Set terminal emulation based on platform as required.</span></div><div class="line">    stdin, stdout, stderr := term.StdStreams()</div><div class="line">    logrus.SetOutput(stderr)</div><div class="line"></div><div class="line">    dockerCli := command.NewDockerCli(stdin, stdout, stderr)</div><div class="line">    </div><div class="line">    <span class="comment">// root命令，子命令都在这里面，重点看</span></div><div class="line">    cmd := newDockerCommand(dockerCli)</div><div class="line"></div><div class="line">    <span class="comment">// 命令执行	</span></div><div class="line">    <span class="keyword">if</span> err := cmd.Execute(); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">if</span> sterr, ok := err.(cli.StatusError); ok &#123;</div><div class="line">            <span class="keyword">if</span> sterr.Status != <span class="string">""</span> &#123;</div><div class="line">                fmt.Fprintln(stderr, sterr.Status)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// StatusError should only be used for errors, and all errors should</span></div><div class="line">            <span class="comment">// have a non-zero exit status, so never exit with 0</span></div><div class="line">            <span class="keyword">if</span> sterr.StatusCode == <span class="number">0</span> &#123;</div><div class="line">                os.Exit(<span class="number">1</span>)</div><div class="line">            &#125;</div><div class="line">            os.Exit(sterr.StatusCode)</div><div class="line">        &#125;</div><div class="line">        fmt.Fprintln(stderr, err)</div><div class="line">        os.Exit(<span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是这个文件，<code>newDockerCommand</code>函数调用了<code>commands.AddCommands(cmd, dockerCli)</code>来添加命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDockerCommand</span><span class="params">(dockerCli *command.DockerCli)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</div><div class="line">        opts := cliflags.NewClientOptions()</div><div class="line">        <span class="keyword">var</span> flags *pflag.FlagSet</div><div class="line"></div><div class="line">        cmd := &amp;cobra.Command&#123;</div><div class="line">                Use:              <span class="string">"docker [OPTIONS] COMMAND [ARG...]"</span>,</div><div class="line">                Short:            <span class="string">"A self-sufficient runtime for containers"</span>,</div><div class="line">                SilenceUsage:     <span class="literal">true</span>,</div><div class="line">                SilenceErrors:    <span class="literal">true</span>,</div><div class="line">                TraverseChildren: <span class="literal">true</span>,</div><div class="line">                Args:             noArgs,</div><div class="line">                RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">                        <span class="keyword">if</span> opts.Version &#123;</div><div class="line">                                showVersion()</div><div class="line">                                <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">return</span> command.ShowHelp(dockerCli.Err())(cmd, args)</div><div class="line">                &#125;,</div><div class="line">                PersistentPreRunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">                        <span class="comment">// daemon command is special, we redirect directly to another binary</span></div><div class="line">                        <span class="keyword">if</span> cmd.Name() == <span class="string">"daemon"</span> &#123;</div><div class="line">                                <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// flags must be the top-level command flags, not cmd.Flags()</span></div><div class="line">                        opts.Common.SetDefaultOptions(flags)</div><div class="line">                        dockerPreRun(opts)</div><div class="line">                        <span class="keyword">if</span> err := dockerCli.Initialize(opts); err != <span class="literal">nil</span> &#123;</div><div class="line">                                <span class="keyword">return</span> err</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">return</span> isSupported(cmd, dockerCli)</div><div class="line">                &#125;,</div><div class="line">        &#125;</div><div class="line">        cli.SetupRootCommand(cmd)</div><div class="line"></div><div class="line">        flags = cmd.Flags()</div><div class="line">        flags.BoolVarP(&amp;opts.Version, <span class="string">"version"</span>, <span class="string">"v"</span>, <span class="literal">false</span>, <span class="string">"Print version information and quit"</span>)</div><div class="line">        flags.StringVar(&amp;opts.ConfigDir, <span class="string">"config"</span>, cliconfig.Dir(), <span class="string">"Location of client config files"</span>)</div><div class="line">        opts.Common.InstallFlags(flags)</div><div class="line"></div><div class="line">        setFlagErrorFunc(dockerCli, cmd, flags, opts)</div><div class="line"></div><div class="line">        setHelpFunc(dockerCli, cmd, flags, opts)</div><div class="line"></div><div class="line">        cmd.SetOutput(dockerCli.Out())</div><div class="line">        cmd.AddCommand(newDaemonCommand())</div><div class="line">        # 添加子命令，cmd里现在是root命令</div><div class="line">        commands.AddCommands(cmd, dockerCli)</div><div class="line"></div><div class="line">        setValidateArgs(dockerCli, cmd, flags, opts)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cmd</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这行上面的<code>cmd.AddCommand(newDaemonCommand())</code>是为<code>docker daemon</code>命令进行的输出，<code>newDaemonCommand</code>定义在<code>cmd/docker/daemon_none.go</code>中，从他的<code>RunE</code>方法可以看出来，是输出了不能运行的提示，<code>runtime.GOOS</code>是输出当前系统的名称，比如mac是<code>Darwin</code>， ubuntu是<code>linux</code>，完整看来就是:</p>
<pre><code>`docker daemon` is not supported on Darwin. Please run `dockerd` directly
</code></pre><p>让我们来到<code>commands.AddCommands</code>定义的地方，<code>cli/command/commands/commands.go</code>文件，可以看到<code>cmd.AddCommand</code>的调用，这里就是在添加我们看到的二级命令，也就是紧跟着<code>docker</code>后面的命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddCommands</span><span class="params">(cmd *cobra.Command, dockerCli *command.DockerCli)</span></span> &#123;</div><div class="line">        cmd.AddCommand(</div><div class="line">                ......</div><div class="line"></div><div class="line">                <span class="comment">// container</span></div><div class="line">                container.NewContainerCommand(dockerCli),</div><div class="line">                container.NewRunCommand(dockerCli),</div><div class="line">                </div><div class="line">                ......</div><div class="line">                hide(container.NewPsCommand(dockerCli)),</div><div class="line">                hide(container.NewRenameCommand(dockerCli)),</div><div class="line">                ......</div></pre></td></tr></table></figure>
<p>我们从上看到下，整齐划一中发现最后好多命令被用hide包裹了。这些命令是一些旧命令，在新的版本中可以使用新的命令来代替，如果设置了环境变量<code>DOCKER_HIDE_LEGACY_COMMANDS</code>不为空，那么docker的提示将不会输出这些。</p>
<p>这里的命令太多了，我们通过<code>docker ps</code>命令来了解一下大致的执行流程。</p>
<p><code>docker ps</code>命令也是旧版的命令，<code>hide(container.NewPsCommand(dockerCli))</code>就是在处理他。在新版本中对应的是<code>docker container ls</code>命令。实现代码在<code>cli/command/container/list.go</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewPsCommand creates a new cobra.Command for `docker ps`</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPsCommand</span><span class="params">(dockerCli *command.DockerCli)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</div><div class="line">        options := psOptions&#123;filter: opts.NewFilterOpt()&#125;</div><div class="line"></div><div class="line">        cmd := &amp;cobra.Command&#123;</div><div class="line">                Use:   <span class="string">"ps [OPTIONS]"</span>,</div><div class="line">                Short: <span class="string">"List containers"</span>,</div><div class="line">                Args:  cli.NoArgs,</div><div class="line">                RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">                        <span class="keyword">return</span> runPs(dockerCli, &amp;options)</div><div class="line">                &#125;,</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        flags := cmd.Flags()</div><div class="line"></div><div class="line">        flags.BoolVarP(&amp;options.quiet, <span class="string">"quiet"</span>, <span class="string">"q"</span>, <span class="literal">false</span>, <span class="string">"Only display numeric IDs"</span>)</div><div class="line">        flags.BoolVarP(&amp;options.size, <span class="string">"size"</span>, <span class="string">"s"</span>, <span class="literal">false</span>, <span class="string">"Display total file sizes"</span>)</div><div class="line">        flags.BoolVarP(&amp;options.all, <span class="string">"all"</span>, <span class="string">"a"</span>, <span class="literal">false</span>, <span class="string">"Show all containers (default shows just running)"</span>)</div><div class="line">        flags.BoolVar(&amp;options.noTrunc, <span class="string">"no-trunc"</span>, <span class="literal">false</span>, <span class="string">"Don't truncate output"</span>)</div><div class="line">        flags.BoolVarP(&amp;options.nLatest, <span class="string">"latest"</span>, <span class="string">"l"</span>, <span class="literal">false</span>, <span class="string">"Show the latest created container (includes all states)"</span>)</div><div class="line">        flags.IntVarP(&amp;options.last, <span class="string">"last"</span>, <span class="string">"n"</span>, <span class="number">-1</span>, <span class="string">"Show n last created containers (includes all states)"</span>)</div><div class="line">        flags.StringVarP(&amp;options.format, <span class="string">"format"</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"Pretty-print containers using a Go template"</span>)</div><div class="line">        flags.VarP(&amp;options.filter, <span class="string">"filter"</span>, <span class="string">"f"</span>, <span class="string">"Filter output based on conditions provided"</span>)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cmd</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newListCommand</span><span class="params">(dockerCli *command.DockerCli)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</div><div class="line">        cmd := *NewPsCommand(dockerCli)</div><div class="line">        cmd.Aliases = []<span class="keyword">string</span>&#123;<span class="string">"ps"</span>, <span class="string">"list"</span>&#125;</div><div class="line">        cmd.Use = <span class="string">"ls [OPTIONS]"</span></div><div class="line">        <span class="keyword">return</span> &amp;cmd</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NewPsCommand</code>对应的是<code>docker ps</code>, <code>newListCommand</code>对应的是<code>docker container ls</code>，可以看出来， <code>newListCommand</code>里的command就是<code>NewPsCommand</code>返回的，只是加了一下说明而已。</p>
<blockquote>
<p>这里还漏了一点，docker container ls是3个命令，我们知道docker是root命令，按照cobra的写法，container和ls应该是分开的。他们的关系是这样的，在<code>cli/command/commands/commands.go</code>文件中<code>container.NewContainerCommand(dockerCli)</code>加入了<code>container</code>命令，<code>NewContainerCommand</code>的实现在<code>cli/command/container/cmd.go</code>中，在<code>NewContainerCommand</code>函数中通过<code>newListCommand(dockerCli)</code>加入了ls命令，可以看到还添加了很多别的方法，那些都是<code>container</code>支持的子命令。这样就回到了我们上面提到的内容了，没有魔法</p>
</blockquote>
<p>我们继续看<code>NewPsCommand</code>:</p>
<p>里面定义了<code>docker ps</code>（下面所有的内容对<code>docker container ls</code>都适用）支持的一些选项（flag）,选项被放在了psOptions这个结构体中，最终传给runPs函数.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">runPs</span><span class="params">(dockerCli *command.DockerCli, options *psOptions)</span> <span class="title">error</span></span> &#123;</div><div class="line">        ctx := context.Background()</div><div class="line"></div><div class="line">        listOptions, err := buildContainerListOptions(options)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        containers, err := dockerCli.Client().ContainerList(ctx, *listOptions)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        format := options.format</div><div class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(format) == <span class="number">0</span> &#123;</div><div class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(dockerCli.ConfigFile().PsFormat) &gt; <span class="number">0</span> &amp;&amp; !options.quiet &#123;</div><div class="line">                        format = dockerCli.ConfigFile().PsFormat</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        format = formatter.TableFormatKey</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        containerCtx := formatter.Context&#123;</div><div class="line">                Output: dockerCli.Out(),</div><div class="line">                Format: formatter.NewContainerFormat(format, options.quiet, listOptions.Size),</div><div class="line">                Trunc:  !options.noTrunc,</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> formatter.ContainerWrite(containerCtx, containers)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>listOptions, err := buildContainerListOptions(options)</code>对选项进行了处理，重点在<code>dockerCli.Client().ContainerList(ctx, *listOptions)</code>，<code>ContainerList</code>是一个interface。</p>
<p>实现在<code>vendor/github.com/docker/docker/client/container_list.go</code>（vendor在当前目录下，我是go新手，所以担心大家不知道，高手忽略）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">ContainerList</span><span class="params">(ctx context.Context, options types.ContainerListOptions)</span> <span class="params">([]types.Container, error)</span></span> &#123;</div><div class="line">        query := url.Values&#123;&#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.All &#123;</div><div class="line">                query.Set(<span class="string">"all"</span>, <span class="string">"1"</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.Limit != <span class="number">-1</span> &#123;</div><div class="line">                query.Set(<span class="string">"limit"</span>, strconv.Itoa(options.Limit))</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.Since != <span class="string">""</span> &#123;</div><div class="line">                query.Set(<span class="string">"since"</span>, options.Since)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.Before != <span class="string">""</span> &#123;</div><div class="line">                query.Set(<span class="string">"before"</span>, options.Before)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.Size &#123;</div><div class="line">                query.Set(<span class="string">"size"</span>, <span class="string">"1"</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.Filters.Len() &gt; <span class="number">0</span> &#123;</div><div class="line">                filterJSON, err := filters.ToParamWithVersion(cli.version, options.Filters)</div><div class="line"></div><div class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                query.Set(<span class="string">"filters"</span>, filterJSON)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        resp, err := cli.get(ctx, <span class="string">"/containers/json"</span>, query, <span class="literal">nil</span>)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> containers []types.Container</div><div class="line">        err = json.NewDecoder(resp.body).Decode(&amp;containers)</div><div class="line">        ensureReaderClosed(resp)</div><div class="line">        <span class="keyword">return</span> containers, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面是在拼请求的参数，<code>resp, err := cli.get(ctx, &quot;/containers/json&quot;, query, nil)</code>这里发起了请求，返回了container的列表。我们可以通过curl或nc来获得原始的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  curl -XGET --unix-socket /var/run/docker.sock http://localhost/containers/json</div><div class="line">或者</div><div class="line">➜  echo 'GET /containers/json HTTP/1.0\r\n\r\n' | nc -U /var/run/docker.sock</div><div class="line"></div><div class="line">[&#123;"Id":"c64ea306f74980555521ad2fcbb4c54e1b05e7ca0d597838557d4d613ed12039","Names":["/brave_swirles"],"Image":"docker-cli-dev","ImageID":"sha256:b123a157eaf7e4d468647b42be4c8e339e9e4b9e84058a56575dbfa7249161c9","Command":"ash","Created":1505218585,"Ports":[],"Labels":&#123;&#125;,"State":"running","Status":"Up 25 hours","HostConfig":&#123;"NetworkMode":"default"&#125;,"NetworkSettings":&#123;"Networks":&#123;"bridge":&#123;"IPAMConfig":null,"Links":null,"Aliases":null,"NetworkID":"4b149c263b9a12caef2b16482db33fded74eac5396a57da1724428948464e00f","EndpointID":"6a3fb06309f2142b23db84303cbdb5d55b3a41e91cf2468649bd5f2adee11c66","Gateway":"172.17.0.1","IPAddress":"172.17.0.2","IPPrefixLen":16,"IPv6Gateway":"","GlobalIPv6Address":"","GlobalIPv6PrefixLen":0,"MacAddress":"02:42:ac:11:00:02","DriverOpts":null&#125;&#125;&#125;,"Mounts":[&#123;"Type":"bind","Source":"/Users/youwangqiu/go_code/src/github.com/docker/cli","Destination":"/go/src/github.com/docker/cli","Mode":"","RW":true,"Propagation":"rprivate"&#125;,&#123;"Type":"bind","Source":"/var/run/docker.sock","Destination":"/var/run/docker.sock","Mode":"","RW":true,"Propagation":"rprivate"&#125;]&#125;]</div></pre></td></tr></table></figure>
<p>可以看到数据是以json格式返回的，是一个列表。</p>
<p>回到<code>cli/command/container/list.go</code>，接收到返回值之后，这时候还是上面看到的json，下面进行了格式化输出，大家应该都有做打印<code>9*9乘法表</code>的经历，这里的格式化是同样的道理，不明白的同学可以继续往挖，我偷个懒，就不继续了。</p>
<p>至此<code>docker ps</code>的流程就走完了，大家可以对源码做一些修改，然后进到容器中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make binary</div></pre></td></tr></table></figure>
<p>就可以生产新的docker client，执行一下就能得到想要的输出啦。</p>
<p>谢谢大家，欢迎大家指正🙂</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">166</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="michaelseu2011@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
