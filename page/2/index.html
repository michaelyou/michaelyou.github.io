<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/img/lufei.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/浙江大学SEL实验室docker系列文章目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/浙江大学SEL实验室docker系列文章目录/" itemprop="url">浙江大学SEL实验室Docker系列文章目录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-07T17:24:33+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.sel.zju.edu.cn/?p=112" target="_blank" rel="external">DOCKER源码分析（一）：DOCKER架构</a>-2014.12.02</p>
<p><a href="http://www.sel.zju.edu.cn/?p=147" target="_blank" rel="external">DOCKER源码分析（二）：DOCKER CLIENT创建与命令执行</a>-2014.12.02</p>
<p><a href="http://www.sel.zju.edu.cn/?p=158" target="_blank" rel="external">DOCKER源码分析（三）：DOCKER DAEMON启动</a>-2014.12.02</p>
<p><a href="http://www.sel.zju.edu.cn/?p=165" target="_blank" rel="external">DOCKER源码分析（四）：DOCKER DAEMON之NEWDAEMON实现</a>-2014.12.02</p>
<p><a href="http://www.sel.zju.edu.cn/?p=259" target="_blank" rel="external">DOCKER源码分析（五）：DOCKER SERVER的创建</a>-2014.12.09</p>
<p><a href="http://www.sel.zju.edu.cn/?p=399" target="_blank" rel="external">DOCKER源码分析（六）：DOCKER DAEMON网络</a>-2015.01.05</p>
<p><a href="http://www.sel.zju.edu.cn/?p=508" target="_blank" rel="external">DOCKER源码分析（七）：DOCKER CONTAINER网络 （上）</a>-2015.01.26</p>
<p><a href="http://www.sel.zju.edu.cn/?p=537" target="_blank" rel="external">DOCKER源码分析（八）：DOCKER CONTAINER网络（下）</a>-2015.03.12</p>
<p><a href="http://www.sel.zju.edu.cn/?p=549" target="_blank" rel="external">DOCKER源码分析（九）：DOCKER镜像</a>-2015.03.12</p>
<p><a href="http://www.sel.zju.edu.cn/?p=444" target="_blank" rel="external">DOCKER网络详解及PIPEWORK源码解读与实践</a>-2015.01.16</p>
<p><a href="http://www.sel.zju.edu.cn/?p=556" target="_blank" rel="external">DOCKER背后的内核知识——NAMESPACE资源隔离</a>-2015.03.13</p>
<p><a href="http://www.sel.zju.edu.cn/?p=573" target="_blank" rel="external">DOCKER背后的内核知识——CGROUPS资源限制</a>-2015.04.22</p>
<p><a href="http://www.sel.zju.edu.cn/?p=577" target="_blank" rel="external">DOCKER背后的容器管理——LIBCONTAINER深度解析</a>-2015.06.03</p>
<p><a href="http://www.sel.zju.edu.cn/?p=296" target="_blank" rel="external">玩转DOCKER镜像</a>-2014.12.16</p>
<p><a href="http://www.sel.zju.edu.cn/?p=467" target="_blank" rel="external">深入理解ETCD技术分享PPT</a>-2015.01.20</p>
<p><a href="http://www.sel.zju.edu.cn/?p=523" target="_blank" rel="external">ETCD：从应用场景到实现原理的全方位解读</a>-2015.02.01</p>
<p><a href="http://www.sel.zju.edu.cn/?p=283" target="_blank" rel="external">GOOGLE KUBERNETES设计文档之安全篇</a>-2014.12.11</p>
<p><a href="http://www.sel.zju.edu.cn/?p=331" target="_blank" rel="external">GOOGLE KUBERNETES设计文档之POD篇</a>-2014.12.19</p>
<p><a href="http://www.sel.zju.edu.cn/?p=360" target="_blank" rel="external">GOOGLE KUBERNETES设计文档之服务篇</a>-2014.12.23</p>
<p><a href="http://www.sel.zju.edu.cn/?p=353" target="_blank" rel="external">GOOGLE KUBERNETES设计文档之网络篇</a>-2014.12.29</p>
<p><a href="http://www.sel.zju.edu.cn/?p=394" target="_blank" rel="external">GOOGLE KUBERNETES设计文档之VOLUMES</a>-2015.01.02</p>
<p><a href="http://www.sel.zju.edu.cn/?p=417" target="_blank" rel="external">KUBERNETES MINION NODE 组件 之 KUBELET</a>-2015.01.13</p>
<p><a href="http://www.sel.zju.edu.cn/?p=484" target="_blank" rel="external">KUBERNETES代码走读之MINION NODE 组件 KUBE-PROXY</a>-2015.01.22</p>
<p><a href="http://www.sel.zju.edu.cn/?p=588" target="_blank" rel="external">4S: SERVICES ACCOUNT, SECRET, SECURITY CONTEXT AND SECURITY IN KUBERNETES</a>-2015.07.30</p>
<p><a href="http://www.sel.zju.edu.cn/?p=595" target="_blank" rel="external">KUBERNETES NODE COMPONENTS – KUBELET</a>-2015.08.07</p>
<p><a href="http://www.sel.zju.edu.cn/?p=609" target="_blank" rel="external">KUBERNETES APISERVER源码分析——API请求的认证过程</a>-2015.08.09</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/02/python字符编码和字符串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/02/python字符编码和字符串/" itemprop="url">python字符编码和字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-02T22:35:33+08:00">
                2017-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>背景：我司代码都是基于python2</p>
<p>今天接到一个需求，用户提交的评论字数如果大于20个字要给用户发红包。毫不迟疑，我写下了下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> len(content) &gt; <span class="number">20</span>:</div><div class="line">	<span class="comment"># 发红包</span></div></pre></td></tr></table></figure>
<p>我转念一想，事情不大对，我这算的是字符数（这个表述是正确的，是字符）啊</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">len(<span class="string">"abcd"</span>)  <span class="comment"># 等于4</span></div><div class="line">len(<span class="string">"I love python"</span>)  <span class="comment"># 等于13</span></div></pre></td></tr></table></figure>
<p>上面的例子显而易见，小学生水平，再看下面的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">len(<span class="string">"我爱北京天安门"</span>)  <span class="comment"># 这个该是多少呢？</span></div><div class="line">len(<span class="string">u"我爱北京天安门"</span>)  <span class="comment"># 这个又该是多少呢？</span></div></pre></td></tr></table></figure>
<p>大家可以本地打开python试一下，结果是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">len(<span class="string">"我爱北京天安门"</span>)  <span class="comment"># 等于21</span></div><div class="line">len(<span class="string">u"我爱北京天安门"</span>)  <span class="comment"># 等于7</span></div></pre></td></tr></table></figure>
<p>其实我想要的是下面这个，但是我在代码里直接那么写，我操作的字符串前面到底有没有<code>u</code>呢，这个<code>u</code>我知道是<code>unicode</code>字符串，它和没有<code>u</code>的字符串到底区别在哪里？</p>
<p>几年前我曾经下决心弄懂这个问题，可能当时也确实明白了，但是现在差不多已经全忘了。我自己总结了一下，一是之前一直是用python3，python3做了一些修改。二是这个问题确实不应该交给程序员来解决（我承认我的记性确实不好）。</p>
<p>然而，旧的系统那么多，难保你下次跳槽的公司没有一些上了年纪的代码，我们还是来梳理一下吧。</p>
<h2 id="字符与字节"><a href="#字符与字节" class="headerlink" title="字符与字节"></a>字符与字节</h2><p>一个字符不等价于一个字节，字符是人类能够识别的符号，而这些符号要保存到计算机的存储中就需要用计算机能够识别的字节来表示。一个字符往往有多种表示方法，不同的表示方法会使用不同的字节数。这里所说的不同的表示方法就是指<code>字符编码</code>，比如字母A-Z都可以用<code>ASCII</code>码表示（占用一个字节），也可以用<code>UNICODE</code>表示（占两个字节），还可以用<code>UTF-8</code>表示（占用一个字节）。字符编码的作用就是将人类可识别的字符转换为机器可识别的字节码，以及反向过程。</p>
<p><strong>UNICDOE才是真正的字符串，而用ASCII、UTF-8、GBK等字符编码表示的是字节串</strong>。关于这点，我们可以在Python的官方文档中经常可以看到这样的描述<strong>“Unicode string”</strong> , <strong>“translating a Unicode string into a sequence of bytes”</strong>。（注意：英文中string是我们说的字符串，bytes是字节串）</p>
<p>我们写<code>代码</code>是写在<code>文件</code>中的，而<code>字符</code>是以<code>字节</code>形式保存在<code>文件</code>中的，因此当我们在文件中定义个<code>字符串</code>时被当做<code>字节串</code>也是可以理解的。但是，我们需要的是<code>字符串</code>，而不是<code>字节串</code>（我们写代码处理的是我们能想象的数据，也就是字符串，应该不会有人想象字节串吧）。一个优秀的编程语言，应该严格区分两者的关系并提供巧妙的完美的支持。JAVA语言就很好，我认识的JAVA程序员从来没有考虑过这些不应该由程序员来处理的问题（我一直这么认为）。遗憾的是，很多编程语言试图混淆<code>“字符串”</code>和<code>“字节串”</code>，他们<em>把字节串当做字符串来使用</em>，PHP和Python2都属于这种编程语言。最能说明这个问题的操作就是取一个包含中文字符的字符串的长度：</p>
<ul>
<li>对<code>字符串</code>取长度，结果应该是所有<code>字符</code>的个数，无论中文还是英文</li>
<li>对<code>字符串</code>对应的<code>字节串</code>取长度，就跟编码(encode)过程使用的<code>字符编码</code>有关了(比如：<code>UTF-8编码</code>，一个<code>中文字符</code>需要用<code>3个字节</code>来表示；<code>GBK编码</code>，一个<code>中文字符</code>需要<code>2个字节</code>来表示)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">7</span>]: a = <span class="string">u"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">9</span>]: <span class="keyword">print</span> len(a), type(a)</div><div class="line"><span class="number">2</span> &lt;type <span class="string">'unicode'</span>&gt;</div><div class="line"></div><div class="line">In [<span class="number">10</span>]: b = a.encode(<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line">In [<span class="number">11</span>]: <span class="keyword">print</span> len(b), type(b)</div><div class="line"><span class="number">6</span> &lt;type <span class="string">'str'</span>&gt;</div><div class="line"></div><div class="line">In [<span class="number">12</span>]: c = a.encode(<span class="string">'gbk'</span>)</div><div class="line"></div><div class="line">In [<span class="number">13</span>]: <span class="keyword">print</span> len(c), type(c)</div><div class="line"><span class="number">4</span> &lt;type <span class="string">'str'</span>&gt;</div></pre></td></tr></table></figure>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>UNICODE字符编码，也是一张字符与数字的映射，但是这里的数字被称为代码点(code point), 实际上就是十六进制的数字。</p>
<p><a href="https://docs.python.org/2/howto/unicode.html#encodings" target="_blank" rel="external">Python官方文档</a>中对Unicode字符串、字节串与编码之间的关系有这样一段描述：</p>
<pre><code>a Unicode string is a sequence of code points, which are numbers from 0 to 0x10ffff.
This sequence needs to be represented as a set of bytes (meaning, values from 0–255) in memory.
The rules for translating a Unicode string into a sequence of bytes are called an encoding.

Unicode字符串是一个代码点（code point）序列，代码点取值范围为0到0x10FFFF（对应的十进制为1114111）。
这个代码点序列在存储（包括内存和物理磁盘）中需要被表示为一组字节(0到255之间的值)，
而将Unicode字符串转换为字节序列的规则称为编码。
</code></pre><p>这里说的编码不是指字符编码，而是指<strong>编码的过程以及这个过程中所使用到的Unicode字符的代码点与字节的映射规则</strong>。这个映射不必是简单的一对一映射，因此编码过程也不必处理每个可能的Unicode字符，例如：</p>
<p>将<code>Unicode字符串</code>转换为<code>ASCII编码</code>的规则很简单–对于每个<code>代码点</code>：</p>
<ul>
<li>如果代码点数值&lt;128，则每个<code>字节</code>与代码点的值相同</li>
<li>如果代码点数值&gt;=128，则<code>Unicode字符</code>无法在此编码中进行表示（这种情况下，Python会引发一个<code>UnicodeEncodeError</code>异常）</li>
</ul>
<p>将<code>Unicode字符串</code>转换为<code>UTF-8编码</code>使用以下规则：</p>
<ul>
<li>如果代码点数值&lt;128，则由相应的<code>字节值</code>表示（与Unicode转ASCII字节一样）</li>
<li>如果代码点数值&gt;=128，则将其转换为一个2个字节，3个字节或4个字节的序列，该序列中的每个字节都在128到255之间。</li>
</ul>
<p>简单总结：</p>
<ul>
<li>编码(<code>encode</code>)：将<code>Unicode字符串</code>（中的代码点)转换特定<code>字符编码</code>对应的<code>字节串</code>的过程和规则</li>
<li>解码(decode)：将<strong>特定字符编码的字节串</strong>转换为对应的<strong>Unicode字符串</strong>(中的代码点)的过程和规则</li>
</ul>
<p>可见，无论是编码还是解码，都需要一个重要因素，就是特定的字符编码。因为一个字符用不同的字符编码进行编码后的字节值以及字节个数大部分情况下是不同的，反之亦然。</p>
<p>而且很容易看到，编码和解码都是基于<strong>Unicode字符串</strong>，<em>没有第二种字符串掺和</em>，其他都是编码方式，一定要深刻地认识到这一点。</p>
<h2 id="Python编码"><a href="#Python编码" class="headerlink" title="Python编码"></a>Python编码</h2><h3 id="Python源代码文件的执行过程"><a href="#Python源代码文件的执行过程" class="headerlink" title="Python源代码文件的执行过程"></a>Python源代码文件的执行过程</h3><p>我们都知道，磁盘上的文件都是以<code>二进制格式</code>存放的，其中<code>文本文件</code>都是以<code>某种特定编码</code>的<code>字节</code>形式存放的。对于程序源代码文件的字符编码是由编辑器指定的，比如我们使用vim来编写Python程序时会指定文件编码为UTF-8，那么Python代码被保存到磁盘时就会被转换为UTF-8编码对应的字节（encode过程）后写入磁盘。当执行Python代码文件中的代码时，Python解释器在读取Python代码文件中的字节串之后，需要将其转换为UNICODE字符串（decode过程）之后才执行后续操作。</p>
<p>上面已经解释过，这个转换过程（decode，解码）需要我们指定文件中保存的字节使用的字符编码是什么，才能知道这些字节在UNICODE这张万国码和统一码中找到其对应的代码点是什么。这里指定字符编码的方式大家都很熟悉，一图胜千言：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div></pre></td></tr></table></figure>
<p><img src="/img/python_source_file_execute.png" alt="python源文件文件的执行过程"></p>
<h3 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h3><p>那么，如果我们没有在代码文件开始的部分指定字符编码，Python解释器会使用哪种字符编码把从代码文件中读取到的字节转换为<strong>UNICODE代码点</strong>呢？就像我们配置某些软件时，有很多默认选项一样，Python解释器内部设置了默认的<code>字符编码</code>。因此大家所说的Python中文字符问题就可以总结为一句话：当无法通过<strong>默认的字符编码</strong>对字节进行转换时，就会出现解码错误(UnicodeEncodeError)。</p>
<p>Python2和Python3的解释器使用的默认编码是不一样的，我们可以通过<code>sys.getdefaultencoding()</code>来获取默认编码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># python2</span></div><div class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> sys</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: sys.getdefaultencoding()</div><div class="line">Out[<span class="number">3</span>]: <span class="string">'ascii'</span></div><div class="line"></div><div class="line"><span class="comment"># python3</span></div><div class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> sys</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: sys.getdefaultencoding()</div><div class="line">Out[<span class="number">3</span>]: <span class="string">'utf-8'</span></div></pre></td></tr></table></figure>
<p>因此，对于Python2来讲，Python解释器在读取到中文字符的字节码尝试解码操作时，会先查看当前代码文件头部是否有指明当前代码文件中保存的字节码对应的字符编码是什么。如果没有指定则使用默认字符编码”ASCII”进行解码导致解码失败，导致如下错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SyntaxError: Non-ASCII character <span class="string">'\xc4'</span> <span class="keyword">in</span> file xxx.py on line <span class="number">11</span>, but no encoding declared; see http://python.org/dev/peps/pep<span class="number">-0263</span>/ <span class="keyword">for</span> details</div></pre></td></tr></table></figure>
<p>对于Python3来讲，执行过程是一样的，只是Python3的解释器以”UTF-8”作为默认编码，但是这并不表示可以完全兼容中文问题。比如我们在Windows上进行开发时，Python工程及代码文件都使用的是默认的GBK编码，也就是说Python代码文件是被转换成GBK格式的字节码保存到磁盘中的。Python3的解释器执行该代码文件时，试图用UTF-8进行解码操作时，同样会解码失败，导致如下错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SyntaxError: Non-UTF<span class="number">-8</span> code starting <span class="keyword">with</span> <span class="string">'\xc4'</span> <span class="keyword">in</span> file xxx.py on line <span class="number">11</span>, but no encoding declared; see http://python.org/dev/peps/pep<span class="number">-0263</span>/ <span class="keyword">for</span> details</div></pre></td></tr></table></figure>
<h2 id="再谈python2和python3中的字符串"><a href="#再谈python2和python3中的字符串" class="headerlink" title="再谈python2和python3中的字符串"></a>再谈python2和python3中的字符串</h2><p>其实Python3中对字符串支持的改进，不仅仅是更改了默认编码，而是重新进行了字符串的实现，而且它已经实现了<strong>对UNICODE的内置支持</strong>，从这方面来讲Python已经和JAVA等语言一样优秀。下面我们来看下Python2与Python3中对字符串的支持有什么区别：</p>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>Python2中对字符串的支持由以下三个类提供</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">basestring</span><span class="params">(object)</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">str</span><span class="params">(basestring)</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">unicode</span><span class="params">(basestring)</span></span></div></pre></td></tr></table></figure>
<p>执行<code>help(str)</code>和<code>help(bytes)</code>会发现结果都是<code>str类</code>的定义，这也说明Python2中str就是<strong>字节串</strong>，而后来的<strong>unicode对象对应才是真正的字符串</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: a = <span class="string">"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">2</span>]: b = <span class="string">u"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">3</span>]: <span class="keyword">print</span> type(a), len(a)</div><div class="line">&lt;type <span class="string">'str'</span>&gt; <span class="number">6</span></div><div class="line"></div><div class="line">In [<span class="number">4</span>]: <span class="keyword">print</span> type(b), len(b)</div><div class="line">&lt;type <span class="string">'unicode'</span>&gt; <span class="number">2</span></div></pre></td></tr></table></figure>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><p>Python3中对字符串的支持进行了实现类层次的上简化，去掉了unicode类，添加了一个bytes类。从表面上来看，可以认为Python3中的str和unicode合二为一了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">bytes</span><span class="params">(object)</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">str</span><span class="params">(object)</span></span></div></pre></td></tr></table></figure>
<p>实际上，Python3中已经意识到之前的错误，开始明确的区分字符串与字节。因此Python3中的str已经是真正的字符串，而字节是用单独的bytes类来表示。也就是说，Python3默认定义的就是字符串，实现了对UNICODE的内置支持，减轻了程序员对字符串处理的负担。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: a = <span class="string">"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">2</span>]: b = <span class="string">u"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">3</span>]: c = a.encode(<span class="string">"gbk"</span>)</div><div class="line"></div><div class="line">In [<span class="number">4</span>]: print(type(a), len(a))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt; 2</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class"><span class="title">In</span> [5]:</span> print(type(b), len(b))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt; 2</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class"><span class="title">In</span> [6]:</span> print(type(c), len(c))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bytes</span>'&gt; 4</span></div></pre></td></tr></table></figure>
<h2 id="字符编码转换"><a href="#字符编码转换" class="headerlink" title="字符编码转换"></a>字符编码转换</h2><p>上面提到，UNICODE字符串可以与任意字符编码的字节进行相互转换，如图：</p>
<p><img src="/img/unicode_string.png" alt="unicode 字符串"></p>
<p>那么大家很容易想到一个问题，就是不同的字符编码的字节可以通过Unicode相互转换吗？答案是肯定的。</p>
<p><strong>Python2中的字符串进行字符编码转换过程是</strong>：</p>
<p>字节串–&gt;decode(‘原来的字符编码’)–&gt;Unicode字符串–&gt;encode(‘新的字符编码’)–&gt;字节串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: a = <span class="string">"中国"</span>  <span class="comment"># utf-8编码的字节串</span></div><div class="line"></div><div class="line">In [<span class="number">2</span>]: b = a.decode(<span class="string">'utf-8'</span>).encode(<span class="string">'gbk'</span>)  <span class="comment"># 先转换成unicode字符串，再进行gbk编码</span></div><div class="line"></div><div class="line">In [<span class="number">3</span>]: <span class="keyword">print</span> b.decode(<span class="string">'gbk'</span>)  <span class="comment"># 解码成unicode字符串</span></div><div class="line">中国</div></pre></td></tr></table></figure>
<p><strong>Python3中定义的字符串默认就是unicode，因此不需要先解码，可以直接编码成新的字符编码：</strong></p>
<p>字符串–&gt;encode(‘新的字符编码’)–&gt;字节串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: a = <span class="string">"中国"</span></div><div class="line"></div><div class="line">In [<span class="number">2</span>]: b = a.encode(<span class="string">"gbk"</span>)</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: print(b.decode(<span class="string">"gbk"</span>))</div><div class="line">中国</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>python字符串编码差不多就是这些内容了，搞清楚原理其实记忆也不难。祝大家不会再掉到python字符编码的坑中，祝我司能尽快迁移到python3！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/30/go和python变量赋值的一个小问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/30/go和python变量赋值的一个小问题/" itemprop="url">go和python变量赋值的一个小问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-30T19:37:23+08:00">
                2017-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>平时写得多的是python，最近看了一点go，今天碰到了一个问题，和大家分享一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</div><div class="line">    Name <span class="keyword">string</span></div><div class="line">    Age  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pase_student</span><span class="params">()</span></span> &#123;</div><div class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</div><div class="line">    stus := []student&#123;</div><div class="line">        &#123;Name: <span class="string">"zhou"</span>, Age: <span class="number">24</span>&#125;,</div><div class="line">        &#123;Name: <span class="string">"li"</span>, Age: <span class="number">23</span>&#125;,</div><div class="line">        &#123;Name: <span class="string">"wang"</span>, Age: <span class="number">22</span>&#125;,</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</div><div class="line">        m[stu.Name] = &amp;stu</div><div class="line">    &#125;</div><div class="line">    fmt.Println(m[<span class="string">"zhou"</span>].Name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    pase_student()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单，大家可以思考一下会打印出什么。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">time.sleep(<span class="number">60</span>)  <span class="comment"># 思考</span></div></pre></td></tr></table></figure>
<p>结果是<code>wang</code>!，惊喜不惊喜！遍历赋值啊同学们，这么简单的操作都能出幺蛾子，WTF！</p>
<p>为什么是<code>wang</code>呢？<del>你tm给我</del>解释解释<del>什么是惊喜</del>：</p>
<p>for循环的时候，变量stu的指针是不变的，每次循环仅仅是对student结构体的<strong>值</strong>拷贝，上面的for循环和下面是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stu student </div><div class="line"><span class="keyword">for</span> _, stu = <span class="keyword">range</span> stus &#123;</div><div class="line">	m[stu.Name] = &amp;stu</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以<code>&amp;stu</code>自始至终都是一个地址，变化的是这个地址上存储的值。<code>&amp;stu</code>最终存储的值是<code>student{Name: &quot;wang&quot;, Age: 22}</code>结构体，所以拿出来的是<code>wang</code>。</p>
<p>可以将<code>m</code>打出来看一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">map</span>[zhou:<span class="number">0xc42000a260</span> li:<span class="number">0xc42000a260</span> wang:<span class="number">0xc42000a260</span>]</div></pre></td></tr></table></figure>
<p>验证了我们上面的想法，大家的value都是同一个地址。</p>
<p>看到这里，如果是一个日常写c，c++等强类型语言的同学可能会说，神经病啊！这有什么好说的！不就是这样的吗！请原谅我，我日常写python的 [捂脸]。</p>
<p>从上面的例子可以看出来，在go中，变量名是<code>存储地址的名字</code>。它在编译时绑定已经完成，运行时是不可以改变的，你只能改变地址中存储的值。</p>
<p>而在python中，变量是对象的名字，运行时变量可以绑定到任意的对象上。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">4</span>]: a = <span class="number">123456</span></div><div class="line"></div><div class="line">In [<span class="number">5</span>]: id(a)</div><div class="line">Out[<span class="number">5</span>]: <span class="number">4426596208</span></div><div class="line"></div><div class="line">In [<span class="number">6</span>]: a = <span class="number">1234567</span></div><div class="line"></div><div class="line">In [<span class="number">7</span>]: id(a)</div><div class="line">Out[<span class="number">7</span>]: <span class="number">4426592592</span></div></pre></td></tr></table></figure>
<p>注意：由于python对int类型实现了<strong>小整数对象池</strong>，不要用<strong>0-255</strong>的整数做实验，不然你得到id会是一样的。</p>
<p>也就是说，当你循环一个list的时候，每次得到的是不同对象，变量指向了不同的地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">9</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">2222</span>, <span class="number">2223</span>, <span class="number">2224</span>]:</div><div class="line">   ...:     print(id(i))</div><div class="line">   ...:</div><div class="line"><span class="number">4426596208</span></div><div class="line"><span class="number">4426592336</span></div><div class="line"><span class="number">4426596080</span></div></pre></td></tr></table></figure>
<p>上面这段代码，python为我们创建了3个<code>PyIntObject</code>，<strong>i</strong>只是他们的名字。而在go中，可以认为只有一个object，值变化了3次。</p>
<p>python中说的<code>赋值就是建立一个对象的引用</code>，是实话。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/ssl-traffic-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/13/ssl-traffic-analysis/" itemprop="url">SSL/TLS 会话流量分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T12:50:39+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="http://blog.fourthbit.com/2014/12/23/traffic-analysis-of-an-ssl-slash-tls-session" target="_blank" rel="external">http://blog.fourthbit.com/2014/12/23/traffic-analysis-of-an-ssl-slash-tls-session</a></p>
<p>在这篇文章中，我将会给大家展示当我们使用SSL/TLS的时候，在协议层面上发生了什么。为了便于分析，我将会使用一个基于OpenSSL实现的非阻塞TCP客户端和服务端。</p>
<p>我们要记住，SSL/TLS能让应用像底层基础设施（网络和主机）一样安全，确保通信安全是它唯一做的事。SSL/TLS是一个独立的协议，它处于应用层（一般来说是HTTP，其他同样也可以）和传输层（TCP）之间。如此，TLS不需要上下层协议有大的改动，对用户而言，它几乎是透明的，也就是说用户根本不需要知道这个协议的存在。当然，这也带来了一些弊端，它在一些基础方面对协议做了限制（比如不支持UDP）。</p>
<p>自SSL/TLS诞生以来，它已经有了相当大的改进。现在，SSL 2.0和3.0被认为是不安全的，他们已经被TLS 1.0/1.1/1.2 替换。这些协议的历史是一个很有趣的话题。</p>
<h2 id="协议描述"><a href="#协议描述" class="headerlink" title="协议描述"></a>协议描述</h2><p>就像上面提到的，TLS协议在应用层和传输层中间。它被分割成两个主要的子层。下面是这个协议的主要结构和它在网络协议栈中的位置。</p>
<p><img src="/img/protocol_description.png" alt="tls structure"></p>
<p>下面的子层在TCP之上，因为TCP是一个面向连接的可靠的协议。这一层主要包括TLS记录协议。简而言之，记录协议首先将上层协议的数据变成2^14bytes或更少的块，然后对数据进行压缩（可选），加上一个消息认证码（Message Authentication Code），最后，根据协商的加密细则对数据进行加密并添加一个SSL记录头。值得注意的是，每一个块都会被打包进一个结构体，这个结构体并不保存应用层消息的边界，这就意味着多条相同类型的消息可能会被合并到一个结构体中。</p>
<p>下面的图描述了建立一个SSL Record的过程</p>
<p><img src="/img/ssl_record.png" alt="ssl record"></p>
<p>上面的子层在SSL记录协议(SSL Record Protocol)之上，它由四个子协议组成。每个子协议都有非常明确的目的，并在通信的不同阶段被应用：</p>
<ol>
<li><p>握手协议（HandShake Protocol）：它使双方可以相互认证，以及为本次连接协商出一个加密套件（cipher suite）和其他参数。SSL握手协议涉及到客户端和服务端之间4组消息交换。每一组都是在独立的TCP段（segment）中传输。下面的图为这个过程做了总结，它包含好几个步骤，一些步骤是可选的。注意，<em>ChangeCipherSpec</em>不属于这个协议，他们是独立的协议，下面会讲到。<br><img src="/img/handshake.png" alt="handshake"></p>
</li>
<li><p>ChangeCipherSpec协议：它使之前双方协商得到的参数起作用，通信变成加密的。</p>
</li>
<li>Alert协议：用于通信异常，并预警可能降低通信安全性的问题</li>
<li>应用数据协议（Application Data Protocol）：它接受任意大小的数据（通常是应用层数据），将数据喂给安全通道（feeds it through the secure channel）。</li>
</ol>
<p>多条消息可以被串联成一条记录层（Record Layer）消息，但是这些消息必须归属于相同的子协议。结果是，这4个协议的每个都必须是自定界的（比如，都需要包含自己的长度字段）。</p>
<h2 id="记录协议格式（Record-Protocol-format）"><a href="#记录协议格式（Record-Protocol-format）" class="headerlink" title="记录协议格式（Record Protocol format）"></a>记录协议格式（Record Protocol format）</h2><p>TLS 记录头（Record header）包含3个字段，高层协议建立在它之上：</p>
<ol>
<li>Byte 0：TLS记录类型（TLS recode type）</li>
<li>Bytes 1-2: TLS version (major/minor)</li>
<li>Bytes 3-4: Length of data in the record (excluding the header itself). The maximum supported is 16384 (16K)</li>
</ol>
<p><img src="/img/record_protocol_format.png" alt="record protocol format"></p>
<h2 id="握手协议格式（Handshake-Protocol-format）"><a href="#握手协议格式（Handshake-Protocol-format）" class="headerlink" title="握手协议格式（Handshake Protocol format）"></a>握手协议格式（Handshake Protocol format）</h2><p>这是TLS种最复杂的子协议。TLS标准主要也在这一部分，因为它为建立一个安全的连接处理了所有细节。下面的图展示了握手协议消息的主体结构。TLS标准存在10种（不包括扩展）握手消息类型，下面一一做了展示。</p>
<p><img src="/img/handshake_message_structure.png" alt="handshake message general structure"></p>
<ul>
<li>HelloRequest：允许服务器重启握手协商。不常用。如果一个连接被挂起了足够长时间只是安全性下降，服务器可以使用此消息迫使客户端重新协商新的会话秘钥（keys）。</li>
</ul>
<p><img src="/img/hello_request.png" alt="hello request"></p>
<ul>
<li>ClientHello：这条消息代表了一个TLS握手协商的开始。发送它的同时会带上客户端支持的加密套件列表，服务端会挑选最合适的那个（安全性最强的那个），此外还有一个压缩方法列表，一个扩展列表。通过包含<code>SessionId</code>字段，它也赋予了客户端重新开始之前的会话的能力。</li>
</ul>
<p><img src="/img/client_hello.png" alt="client hello"></p>
<ul>
<li>ServerHello：ServerHello消息和ClientHello消息很类似，除了它只包含一个密码套件和一个加密方法。如果他包含了一个SessionId（例如：SessionId长度大于0），就是通知客户端在以后重用这个会话。</li>
</ul>
<p><img src="/img/server_hello.png" alt="server hello"></p>
<ul>
<li>Certificate：这个消息的消息体包含了一个公钥证书链。证书链使TLS支持证书分层和公钥基础设施（PKI：Public Key Infrastructures）</li>
</ul>
<p><img src="/img/certificate.png" alt="certificate"></p>
<ul>
<li>ServerKeyExchange：该消息携带客户端需要从服务器获得的密钥交换算法参数，以便之后能使用对称加密。这是可选的，因为并非所有密钥交换都要求服务器明确地发送此消息。实际上，在大多数情况下，Certificate消息足以使客户端与服务器安全地通信一个预先密钥。这些参数的格式完全取决于所选择的密钥套件（CipherSuite），它先前由服务器通过ServerHello消息设置。</li>
</ul>
<p><img src="/img/server_key_exchange.png" alt="server key exchange"></p>
<ul>
<li>CertificateRequest：当服务器需要客户端身份验证时使用它。在Web服务器中不常用，但在某些情况下非常重要。该消息不仅向客户端询问证书，还会告知哪些证书类型是可接受的。此外，它还指出那些证书机构是可信赖的。</li>
</ul>
<p><img src="/img/certificate_request.png" alt="certificate request"></p>
<ul>
<li>ServerHelloDone：该消息完成了握手协商的服务器部分。它没有附加信息。</li>
</ul>
<p><img src="/img/server_hello_done.png" alt="server hello done"></p>
<ul>
<li>ClientKeyExchange：它为服务器提供必要的数据，以生成对称加密的密钥。消息格式与ServerKeyExchange非常相似，因为它主要取决于服务器选择的密钥交换算法。</li>
</ul>
<p><img src="/img/client_key_exchange.png" alt="client key exchange"></p>
<ul>
<li>CertificateVerify：客户端使用该消息来证明服务器拥有与其公钥证书相对应的私钥。该消息保存有客户端数字签名的散​​列信息。如果服务器向客户端发出CertificateRequest，则需要发送需要验证的证书。同样的，信息的确切尺寸和结构取决于商定的算法。在所有情况下，输入到哈希函数的信息是相同的。</li>
</ul>
<p><img src="/img/certificate_verify.png" alt="certificate verify"></p>
<ul>
<li>Finished：此消息表示TLS协商已完成，密码套件（CipherSuite）已激活。应该发送已经加密，因为协商成功完成，所以必须在此之前发送一个<code>ChangeCipherSpec</code>协议消息来激活加密。Finish消息包含一个用所有先前的握手消息组合的哈希，其后是识别服务器/客户端角色的特殊号码，主密钥和填充。所产生的哈希与<code>CertificateVerify</code>哈希不同，因为存在更多的握手消息。</li>
</ul>
<p><img src="/img/finish.png" alt="finish"></p>
<h2 id="ChangeCipherSpec协议格式"><a href="#ChangeCipherSpec协议格式" class="headerlink" title="ChangeCipherSpec协议格式"></a>ChangeCipherSpec协议格式</h2><p>这是最简单的协议：它只有一条消息。该消息必须是单独的协议而不是握手协议的一部分的原因是由于记录层封装（Record Layer encapsulation）。 TLS协议同时对整个记录层消息进行加密。 ChangeCipherSpec消息表示加密的激活，并且由于加密不能应用于消息的一部分，因此任何其他消息都不可能遵循ChangeCipherSpec。避免这些组合的最佳方法是将此消息升级为协议状态。</p>
<p>下面展示ChangeCipherSpec消息是如何构造的：</p>
<p><img src="/img/change_cipher_spec.png" alt="change cipher spec"></p>
<h2 id="Alert协议格式"><a href="#Alert协议格式" class="headerlink" title="Alert协议格式"></a>Alert协议格式</h2><p>警报协议也很简单。它定义了两个字段：严重性级别和警报描述。第一个字段表示警报的严重性（警告为1，致命的2），而第二个字段则表示准确的条件。支持的警报描述取决于SSL/TLS版本。</p>
<p><img src="/img/alert_protocol_format.png" alt="alert protocol format"></p>
<h2 id="ApplicationData协议格式"><a href="#ApplicationData协议格式" class="headerlink" title="ApplicationData协议格式"></a>ApplicationData协议格式</h2><p>该协议的任务是正确地封装来自网络堆栈的应用层的数据，从而可以通过底层协议（TCP）无缝地处理数据，而不会强制更改任何这些层。此协议中消息的格式遵循与以前协议相同的结构。</p>
<p><img src="/img/application_protocol_format.png" alt="applicationdata protocol format"></p>
<h2 id="分析SSL-TLS流量"><a href="#分析SSL-TLS流量" class="headerlink" title="分析SSL/TLS流量"></a>分析SSL/TLS流量</h2><p>我将使用Wireshark进行抓包。客户端基于Scheme的方式支持SSL/TLS，服务端是OpenSSL分发的一部分（具有证书）。服务器监听在443端口，所有通信将通过环回设备进行。在Wireshark中将视图限制为TLS数据包的最简单方法是使用协议过滤器“ssl”。</p>
<h3 id="第一个包（客户端-gt-服务端）"><a href="#第一个包（客户端-gt-服务端）" class="headerlink" title="第一个包（客户端-&gt;服务端）"></a>第一个包（客户端-&gt;服务端）</h3><p>一旦服务器运行并等待连接，客户端就可以启动它。这是客户端发送的第一个数据包</p>
<p><img src="/img/first_flight.png" alt="first flight"></p>
<h3 id="第二个包（服务端-gt-客户端）"><a href="#第二个包（服务端-gt-客户端）" class="headerlink" title="第二个包（服务端-&gt;客户端）"></a>第二个包（服务端-&gt;客户端）</h3><p>第一个包只包含一个从客户端发送到服务器的TLS握手消息（ClientHello）。然而，服务器发送给客户端的作为ClientHello响应的下一个TCP数据包携带3个握手消息。这些消息是ServerHello，Certificate和ServerHelloDone（没有发送ServerKeyExchange或CertificateRequest）。在下一个数据包之后，我将省略较低的堆栈协议（TCP/IP）。</p>
<p><img src="/img/second_flight.png" alt="second flight"></p>
<h3 id="第三个包（客户端-gt-服务端）"><a href="#第三个包（客户端-gt-服务端）" class="headerlink" title="第三个包（客户端-&gt;服务端）"></a>第三个包（客户端-&gt;服务端）</h3><p>目前看上去都是正确的，与上述的协议一致。客户端和服务器现在已经同意使用的算法（密钥交换的RSA，对称加密的AES-256-CBC和消息散列的SHA），压缩（无压缩）和使用的TLS扩展（SessionTicket TLS，重新谈判信息）。此外，客户端现在拥有服务器的证书，因此可以决定是否信任服务器。下一个数据包由客户端发送，并携带以下消息：ClientKeyExchange，ChangeCipherSpec，Finished（已经加密）。</p>
<p><img src="/img/third_flight.png" alt="third flight"></p>
<h3 id="第四个包（服务端-gt-客户端）"><a href="#第四个包（服务端-gt-客户端）" class="headerlink" title="第四个包（服务端-&gt;客户端）"></a>第四个包（服务端-&gt;客户端）</h3><p>在客户端发送ChangeCipherSpec和Finished之后，服务器预期执行相同的操作，以便双向启动采用对称密钥和所有协商的密码套件参数的加密通信。服务器必须发送自己的ChangeCipherSpec和Finished的消息，以使握手过程可以被认为是成功的。在这个消息中发生的一件非常有趣的事情是，我们看到其中一个扩展，扩展名称为Transport Layer Security（传输层安全TLS）会话恢复，而无需服务器端状态，它明确说明了它的作用。你应该记得，它被要求作为我们的ClientHello的一部分，并由服务器在其ServerHello中实现。有关与此扩展相关的消息的信息，我们需要查找<a href="http://www.ietf.org/rfc/rfc5077.txt" target="_blank" rel="external">RFC5077</a>规范。如文档中所述，此扩展握手消息已被分配号码4。</p>
<p><img src="/img/fourth_flight.png" alt="fourth flight"></p>
<h3 id="应用层数据（客户端-lt-gt-服务端）"><a href="#应用层数据（客户端-lt-gt-服务端）" class="headerlink" title="应用层数据（客户端&lt;-&gt;服务端）"></a>应用层数据（客户端&lt;-&gt;服务端）</h3><p>此时，客户端和服务器完成握手。加密通信就位，应用数据可以安全传输。这是一个示例记录，单个TCP数据包可以携带几个消息：</p>
<p><img src="/img/application_data.png" alt="application data"></p>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>由于我们的连接是加密的，所以想知道在数据包中发送什么的唯一方法是使Wireshark或类似的工具知道传输中使用的密钥。尽管这是可能的，我认为为了分析的目的，当客户端或服务器主动关闭连接时，知道客户端会发出一个警告消息就足够了。此警报消息的类型应为CloseNotify（类型0），但是我们将无法从原始数据中看到它。在这种情况下，客户端是以下警报消息的发件人：</p>
<p><img src="/img/closing_connection.png" alt="closing message"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从流量分析可以看出，标准库和客户端的实现遵循了TLS 1.0规范。希望这对您了解SSL/TLS协议的内部机制是有用的。我发现检查十六进制原始数据（特别是像Wireshark这样强大的工具）是一种非常有意义和有趣的工作方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/19/Django外键赋值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/19/Django外键赋值/" itemprop="url">Django外键赋值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-19T10:46:48+08:00">
                2016-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>class Article(models.Model):
    title = models.CharField(max_length=1024, default=&apos;&apos;)
    ...
    def __str__(self):
        return &apos;Article pk:%d %s&apos; % (self.pk, self.title[:30])

class ArticleContent(models.Model):
    article = cached_fields.OneToOneField(Article)
    ...
</code></pre><p>写代码的的时候，发现了一个很奇怪的现象，当我给一个instance的外键（以_id结尾）赋值（数字）的时候    ，这个外键对应的instance的值并不会改变。</p>
<pre><code>In [44]: ac = ArticleContent.objects.get(article_id=14269)
In [45]: ac.article_id
Out[45]: 14269
In [46]: ac.article_id = 14266
In [47]: ac.save()
In [48]: ac.article
Out[48]: &lt;Article: Article pk:14266 EC: Russia, Ukraine to Meet in&gt;
In [49]: ac.article.pk
Out[49]: 14266
</code></pre><p>如上面的代码所示，为了找到答案，我翻了一下Django的源码：</p>
<pre><code>django/db/models/fields/related_descriptors.py 
145     def __get__(self, instance, cls=None):
146         &quot;&quot;&quot;
147         Get the related instance through the forward relation.
148
149         With the example above, when getting ``child.parent``:
150
151         - ``self`` is the descriptor managing the ``parent`` attribute
152         - ``instance`` is the ``child`` instance
153         - ``cls`` is the ``Child`` class (we don&apos;t need it)
154         &quot;&quot;&quot;
155         if instance is None:
156             return self
157
158         # The related instance is loaded from the database and then cached in
159         # the attribute defined in self.cache_name. It can also be pre-cached
160         # by the reverse accessor (ReverseOneToOneDescriptor).
161         try:
162             rel_obj = getattr(instance, self.cache_name)
163         except AttributeError:
164             val = self.field.get_local_related_value(instance)
165             if None in val:
166                 rel_obj = None
167             else:
168                 qs = self.get_queryset(instance=instance)
169                 qs = qs.filter(self.field.get_reverse_related_filter(instance))
170                 # Assuming the database enforces foreign keys, this won&apos;t fail.
171                 rel_obj = qs.get()
172                 # If this is a one-to-one relation, set the reverse accessor
173                 # cache on the related object to the current instance to avoid
174                 # an extra SQL query if it&apos;s accessed later on.
175                 if not self.field.remote_field.multiple:
176                     setattr(rel_obj, self.field.remote_field.get_cache_name(), instance)
177             setattr(instance, self.cache_name, rel_obj)
178
179         if rel_obj is None and not self.field.null:
180             raise self.RelatedObjectDoesNotExist(
181                 &quot;%s has no %s.&quot; % (self.field.model.__name__, self.field.name)
182             )
183         else:
184             return rel_obj
</code></pre><p>注释得非常到位，当我们请求<code>ac.article</code>的时候，会先去检查对应的cache（在这里是<code>_article_cache</code>，感兴趣可以去看<code>cache_name</code>的生成规则，就是外键名前面加下划线，后面加cache）存不存在，如果不存在那么就进行数据库请求，请求完之后会保存到cache中。</p>
<p>我们再看看<code>__set__</code>，代码太长就不贴了（就在<code>__get__</code>方法下面）。除了给外键字段（<code>article</code>）赋值外，还会将pk字段（<code>article_id</code>，是<code>lh_field.attname</code>的值）设置为None，这样下次请求的时候就能拿到正确的值。</p>
<p>以上都是ForeignKey的Magic，而当我们给<code>article_id</code>赋值的时候，只是在给一个普通的attribute赋值而已，没有任何magic，不会清理对应外键的cache，这时候拿到的instance仍然是cache中原来的那个instance。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/03/Django-redis如何支持存取整型和布尔值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/03/Django-redis如何支持存取整型和布尔值/" itemprop="url">Django-redis如何支持存取整型和布尔值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-03T05:16:48+08:00">
                2016-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>redis支持5种数据类型，分别是string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。整型值和布尔值并不在其中。存储整型和布尔值时，redis会将其转换为字符串</p>
<pre><code>127.0.0.1:6379&gt; SET test_key 1
OK
127.0.0.1:6379&gt; GET test_key
&quot;1&quot;
127.0.0.1:6379&gt; SET test_key True
OK
127.0.0.1:6379&gt; GET test_key
&quot;True&quot;
127.0.0.1:6379&gt; SET test_key TRUE
OK
127.0.0.1:6379&gt; GET test_key
&quot;TRUE&quot;
127.0.0.1:6379&gt; SET test_key true
OK
127.0.0.1:6379&gt; GET test_key
&quot;true&quot;
</code></pre><p>但是当我们使用了<code>django-redis</code>之后发现，我们可以正常存取整型和布尔值，这是怎么做的呢？答案自然是在源码中，直觉告诉我们，<code>set函数</code>里一定做了什么事情。</p>
<pre><code># django_redis.client.default.py
def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None, client=None, nx=False, xx=False):
    &quot;&quot;&quot;
    Persist a value to the cache, and set an optional expiration time.
    Also supports optional nx parameter. If set to True - will use redis setnx instead of set.
    &quot;&quot;&quot;

    if not client:
        client = self.get_client(write=True)

    nkey = self.make_key(key, version=version)
    nvalue = self.encode(value)

    ......
</code></pre><p><code>set</code>方法中调用了类的<code>encode</code>的方法对<code>value</code>进行了处理，我们再看<code>encode</code>：</p>
<pre><code>django_redis.client.default.py
def encode(self, value): &quot;&quot;&quot; Encode the given value. &quot;&quot;&quot;

if isinstance(value, bool) or not isinstance(value, integer_types):
    value = self._serializer.dumps(value)
    value = self._compressor.compress(value)
    return value

return value
</code></pre><p>看到了吧，如果是<code>布尔值</code>，那么要调用一个<code>dumps</code>方法，我们找到这个<code>dumps</code>方法：</p>
<pre><code>django_redis.serializers.pickle.py
class PickleSerializer(BaseSerializer): ......

def dumps(self, value):
    return pickle.dumps(value, self._pickle_version)

def loads(self, value):
    return pickle.loads(force_bytes(value))
</code></pre><p>原来是用了<a href="https://docs.python.org/3/library/pickle.html" target="_blank" rel="external">pickle</a>来做了序列化，这样拿出来的时候调用<code>pickle.loads</code>方法，就可以还原为原来的对象了。这也是<code>django-redis</code>支持存储任意<code>python</code>对象的原因，<a href="https://docs.python.org/3/library/pickle.html" target="_blank" rel="external">pickle</a>帮了大忙。</p>
<p>至于<code>int</code>的存取就简单了，我们从<code>get</code>方法看过去：</p>
<pre><code>django_redis.client.default.py
def get(self, key, default=None, version=None, client=None): &quot;&quot;&quot; Retrieve a value from the cache. Returns decoded value if key is found, the default if not. &quot;&quot;&quot; if client is None: client = self.get_client(write=False)

key = self.make_key(key, version=version)

try:
    value = client.get(key)
except _main_exceptions as e:
    raise ConnectionInterrupted(connection=client, parent=e)

if value is None:
    return default

return self.decode(value)
</code></pre><p>可以看到对从<code>redis</code>中取出来的值调用了<code>decode</code>方法：</p>
<pre><code>django_redis.client.default.py
def decode(self, value): 
&quot;&quot;&quot; 
Decode the given value. 
&quot;&quot;&quot; 
try: 
    value = int(value)
except (ValueError, TypeError):
    try:
        value = self._compressor.decompress(value)
    except CompressorError:
        # Handle little values, chosen to be not compressed pass
        value = self._serializer.loads(value) return value
</code></pre><p>一目了然了吧，总结的话就是：<code>redis</code>存的时候还是存的字符串，但是取出来的时候会尝试去<code>int</code>一下。</p>
<p>大家可能会有这样的疑问，如果值是<code>&#39;123&#39;</code>这样的字符串怎么办呢？这样并不会有问题啦，因为字符串存到数据库之前会先做<code>pickle.dumps</code>，这样就可以区分开<strong>数字转换成的字符串</strong>和<strong>真实的字符串</strong>了。</p>
<p>另外，将<code>整型</code>进行<code>pickle</code>也是可以的，但是我觉得因为数字的存储是很平常的需求，而<code>pickle</code>之后会带上对象的各种附加信息，会增加空间消耗，所以作者才有了这样的设计。</p>
<p>如果大家需要写自己的<code>redis client</code>的话，可以参考一下这些设计，会给使用带来很大的方便。</p>
<p><strong>Note</strong>: <code>Python3</code> 中<code>pickle</code>和<code>cPickle</code>已经合并为<code>pickle</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/17/Django-model去掉unique_together报错/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/17/Django-model去掉unique_together报错/" itemprop="url">Django model去掉unique_together报错</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-17T08:46:48+08:00">
                2016-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>事情是这样的，我有一个存储考试的表</p>
<pre><code>class Exam(models.Model):
    category = models.ForiegnKey(Category)
    name = models.CharField(max_length=128)
    date = models.DateField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = (&apos;category&apos;, &apos;date&apos;)
</code></pre><p>category表示考试的类型，date表示考试的日期。建表的时候考虑到一个类型的考试在同一个应该只有一个考试，所以就加了一个<code>unique_together</code>。但是由于业务需要，这个unique_together不需要了。</p>
<p>用过django的人都知道，这不是个大问题，删掉<code>unique_together</code>的代码，然后makemigrations呗，确实，我就这么做了。但是当我migrate的时候却报错了，错误如下：</p>
<pre><code>django.db.utils.OperationalError: (1553, &quot;Cannot drop index &apos;insurance_exam_category_id_a430e581_uniq&apos;: needed in a foreign key constraint&quot;)
</code></pre><p>数据库不让我删除这个index，并且告诉我有一个外键约束用到了这个它。我就奇怪了，category是外键没错，但是我这个是<code>unique_together</code>啊，怎么可能有哪个外键用到了它呢？</p>
<p>没办法，我只能到数据库里寻找答案，<code>show create table exam</code>，输出如下：</p>
<pre><code>| insurance_exam | CREATE TABLE `insurance_exam` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) NOT NULL,
  `date` date NOT NULL,
  `created_at` datetime(6) NOT NULL,
  `updated_at` datetime(6) NOT NULL,
  `category_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `insurance_exam_category_id_a430e581_uniq` (`category_id`,`date`),
  CONSTRAINT `insurance_exam_category_id_a2238260_fk_insurance_category_id` FOREIGN KEY (`category_id`) REFERENCES `insurance_category` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1062 DEFAULT CHARSET=utf8mb4 |
</code></pre><p>可以看到UNIQUE KEY那一行就是<code>unique_together</code>，下面一行是category外键。没有其他东西了啊，到底哪个外键用到了我们的<code>unique_together</code>？</p>
<p>外键只能是category了，也没有别的外键啊。到底是怎么回事呢？</p>
<p>原因是这样的：在Mysql中外键会自动在表上添加一个index，也就说如果没有unique_together，我们的表应该是这样的：</p>
<pre><code>| insurance_exam | CREATE TABLE `insurance_exam` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) NOT NULL,
  `date` date NOT NULL,
  `created_at` datetime(6) NOT NULL,
  `updated_at` datetime(6) NOT NULL,
  `category_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `category_id` (`category_id`),
  CONSTRAINT `insurance_exam_category_id_a2238260_fk_insurance_category_id` FOREIGN KEY (`category_id`) REFERENCES `insurance_category` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1062 DEFAULT CHARSET=utf8mb4 |
</code></pre><p>但是因为有了<code>unique_together</code>的<code>unique_key</code>，并且category在联合索引的左边，根据最左前缀原则，category的索引就有了，所以就不会另外建索引，这个时候category的外键约束就依赖了这个<code>unique_key</code>，所以删除的时候会出现那样的报错。</p>
<p>机智的小伙伴应该想到了，如果我们要去掉<code>unique_together</code>，我们可以将category的KEY加回去，这样就可以将<code>unique_together</code>删掉了。sql如下：</p>
<pre><code>alter table exam add index(category_id);
</code></pre><p>这样，migrate就能成功了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/10/python-string-intern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/10/python-string-intern/" itemprop="url">python string intern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-10T10:12:09+08:00">
                2016-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章会介绍<code>CPython 2.7.12</code>中字符串<code>intern</code>的知识。</p>
<p>首先举一个例子说明内置的<code>intern</code>函数的用法：</p>
<pre><code>&gt;&gt;&gt; s1 = &apos;foo!&apos;
&gt;&gt;&gt; s2 = &apos;foo!&apos;
&gt;&gt;&gt; s1 is s2
False
&gt;&gt;&gt; s1 = intern(&apos;foo!&apos;)
&gt;&gt;&gt; s1
&apos;foo!&apos;
&gt;&gt;&gt; s2 = intern(&apos;foo!&apos;)
&gt;&gt;&gt; s1 is s2
True
</code></pre><p>你应该已经体会到了用法，但是，在<code>python</code>内部它是怎么工作的呢？</p>
<h2 id="String-Intern（字符串驻留）"><a href="#String-Intern（字符串驻留）" class="headerlink" title="String Intern（字符串驻留）"></a>String Intern（字符串驻留）</h2><h3 id="PyStringObject结构体"><a href="#PyStringObject结构体" class="headerlink" title="PyStringObject结构体"></a><code>PyStringObject</code>结构体</h3><p>我们需要深入<code>CPython</code>的源码，表示<code>Python</code>字符串的<code>C</code>结构体<code>PyStringObject</code>在<code>stringobject.h</code>文件中：</p>
<pre><code>typedef struct {
    PyObject_VAR_HEAD
    long ob_shash;
    int ob_sstate;
    char ob_sval[1];

    /* Invariants:
     *     ob_sval contains space for &apos;ob_size+1&apos; elements.
     *     ob_sval[ob_size] == 0.
     *     ob_shash is the hash of the string or -1 if not computed yet.
     *     ob_sstate != 0 iff the string object is in stringobject.c&apos;s
     *       &apos;interned&apos; dictionary; in this case the two references
     *       from &apos;interned&apos; to this object are *not counted* in ob_refcnt.
     */
} PyStringObject;
</code></pre><p>根据注释，如果字符串被<code>interned</code>，变量<code>ob_sstate</code>的值将不再等于<code>0</code>。一般来说，我们不会直接接触这个变量，而是通过下面定义的宏<code>PyString_CHECK_INTERNED</code>来读取它：</p>
<pre><code>#define PyString_CHECK_INTERNED(op) (((PyStringObject *)(op))-&gt;ob_sstate)
</code></pre><h3 id="interned字典"><a href="#interned字典" class="headerlink" title="interned字典"></a>interned字典</h3><p>然后，让我们来看<code>stringobject.c</code>。<code>24行</code>定义了一个对象的引用，<code>interned</code>字符串将会存放在这个对象里。</p>
<pre><code>static PyObject *interned;
</code></pre><p>实际上，这个对象就是一个正常的<code>Python</code>字典，在第<code>4744行</code>被初始化</p>
<pre><code>interned = PyDict_New();
</code></pre><p>最终，所有的魔法都在第<code>4731行``PyString_InternInPlace</code>函数中发生。下面是函数实现：</p>
<pre><code>PyString_InternInPlace(PyObject **p)
{
    register PyStringObject *s = (PyStringObject *)(*p);
    PyObject *t;
    if (s == NULL || !PyString_Check(s))
        Py_FatalError(&quot;PyString_InternInPlace: strings only please!&quot;);
    /* If it&apos;s a string subclass, we don&apos;t really know what putting
       it in the interned dict might do. */
    if (!PyString_CheckExact(s))
        return;
    if (PyString_CHECK_INTERNED(s))
        return;
    if (interned == NULL) {
        interned = PyDict_New();
        if (interned == NULL) {
            PyErr_Clear(); /* Don&apos;t leave an exception */
            return;
        }
    }
    t = PyDict_GetItem(interned, (PyObject *)s);
    if (t) {
        Py_INCREF(t);
        Py_DECREF(*p);
        *p = t;
        return;
    }

    if (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) &lt; 0) {
        PyErr_Clear();
        return;
    }
    /* The two references in interned are not counted by refcnt.
       The string deallocator will take care of this */
    Py_REFCNT(s) -= 2;
    PyString_CHECK_INTERNED(s) = SSTATE_INTERNED_MORTAL;
}
</code></pre><p>可以看到，<code>interned</code>字典中的<code>keys</code>都是指向字符串对象的指针，<code>values</code>也是同样的指针。另外，字符串的派生类不能被<code>intern</code>。不考虑<code>错误检查</code>和<code>引用计数</code>，我们可以用如下伪代码重写这个函数：</p>
<pre><code>interned = None

def intern(string):
    if string is None or not type(string) is str:
        raise TypeError

    if string.is_interned:
        return string

    if interned is None:
        global interned
        interned = {}

    t = interned.get(string)
    if t is not None:
        return t

    interned[string] = string
    string.is_interned = True
    return string
</code></pre><p>简单吧！</p>
<h3 id="字符串intern的好处"><a href="#字符串intern的好处" class="headerlink" title="字符串intern的好处"></a>字符串intern的好处</h3><h4 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h4><p>为什么你要使用字符串<code>intern</code>？首先，共享字符串对象可以减少内存占用。让我们回到第一个例子，一开始，变量<code>s1</code>和<code>s2</code>指向两个不同的对象。</p>
<p><img src="http://guilload.com/assets/media/python-string-interning/foo.png" alt="The two variables reference two different objects"></p>
<p>在<code>intern</code>之后，他们都指向了同一个对象。第二个对象占用的内存被节省下来了。</p>
<p><img src="http://guilload.com/assets/media/python-string-interning/bar.png" alt="Now, the two variables reference the same object"></p>
<p>在处理一些低信息熵的大列表的时候，<code>intern</code>非常有用。例如，当我们解析一个语料库，we could benefit from the very heavy-tailed distribution of word frequencies in human languages to intern strings to our advantage。下面的例子中，我们会使用<code>NLTK</code>来导入<code>Hamlet by Shakespeare</code>，使用<code>Heapy</code>来观察<code>intern</code>前后对象的堆栈使用：</p>
<pre><code>import guppy
import nltk

hp = guppy.hpy()
hp.setrelheap()

hamlet = nltk.corpus.shakespeare.words(&apos;hamlet.xml&apos;)
print hp.heap()

hamlet = [intern(wrd) for wrd in nltk.corpus.shakespeare.words(&apos;hamlet.xml&apos;)]
print hp.heap()



$ python intern.py

Partition of a set of 31187 objects. Total size = 1725752 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0  31166 100  1394864  81   1394864  81 str
...

Partition of a set of 4555 objects. Total size = 547840 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0      4   0   328224  60    328224  60 list
     1   4529  99   215776  39    544000  99 str
...
</code></pre><p>如你所见，我们极大地减少了字符串对象的数量（从<code>31187</code>减少到<code>4555</code>），并且内存占用减少了<code>6.5</code>倍</p>
<h4 id="指针比较"><a href="#指针比较" class="headerlink" title="指针比较"></a>指针比较</h4><p>第二，我们可以用<code>O(1)</code>的指针比较来代替<code>O(n)</code>的字节比较</p>
<p>为了验证这个，我测量了在比较两个字符串是否相等的时，<code>intern</code>与否分别的时间。下面的图应该能说服你：</p>
<p><img src="http://guilload.com/assets/media/python-string-interning/qux.png" alt="Pointer comparison vs. byte-per-byte comparison"></p>
<h3 id="Native-interning"><a href="#Native-interning" class="headerlink" title="Native interning"></a>Native interning</h3><p>在一些条件下，字符串会被原生<code>interning</code>。还是第一个例子，如果我用<code>foo</code>而不是<code>foo！</code>，字符串<code>s1</code>和<code>s2</code>就会被自动地<code>intern</code>。</p>
<pre><code>&gt;&gt;&gt; s1 = &apos;foo&apos;
&gt;&gt;&gt; s2 = &apos;foo&apos;
&gt;&gt;&gt; s1 is s2
True
</code></pre><h3 id="Interned-or-not-interned"><a href="#Interned-or-not-interned" class="headerlink" title="Interned or not interned?"></a>Interned or not interned?</h3><p>写这篇文章之前，我一直在想，在后台，字符串会根据一个参考字符串长度和构成它们的字符的规则来执行<code>intern</code>。我的想法离正确答案很近，但是，当我操作几组创建方法不同的字符串时，我无法推测出这条规则到底是什么！</p>
<pre><code>&gt;&gt;&gt; &apos;foo&apos; is &apos;foo&apos;
True
&gt;&gt;&gt; &apos;foo!&apos; is &apos;foo!&apos;
False
&gt;&gt;&gt; &apos;foo&apos; + &apos;bar&apos; is &apos;foobar&apos;
True
&gt;&gt;&gt; &apos;&apos;.join([&apos;f&apos;]) is &apos;&apos;.join([&apos;f&apos;])
True
&gt;&gt;&gt; &apos;&apos;.join([&apos;f&apos;, &apos;o&apos;, &apos;o&apos;]) is &apos;&apos;.join([&apos;f&apos;, &apos;o&apos;, &apos;o&apos;])
False
&gt;&gt;&gt; &apos;a&apos; * 20 is &apos;aaaaaaaaaaaaaaaaaaaa&apos;
True
&gt;&gt;&gt; &apos;a&apos; * 21 is &apos;aaaaaaaaaaaaaaaaaaaaa&apos;
False
&gt;&gt;&gt; &apos;foooooooooooooooooooooooooooooo&apos; is &apos;foooooooooooooooooooooooooooooo&apos;
True
</code></pre><p>在看完这些例子后，你要承认，确实非常难以确定系统是根据什么来执行原生的<code>intern</code>。我们还需要阅读更多的<code>CPython</code>代码来找出答案。</p>
<h4 id="Fact-1-all-length-0-and-length-1-strings-are-interned"><a href="#Fact-1-all-length-0-and-length-1-strings-are-interned" class="headerlink" title="Fact 1: all length 0 and length 1 strings are interned"></a>Fact 1: all length 0 and length 1 strings are interned</h4><p>还是在<code>stringobject.c</code>，我们这些要看<code>PyString_FromStringAndSize</code>和 <code>PyString_FromString</code>函数中都有的一些代码：</p>
<pre><code>/* share short strings */
if (size == 0) {
    PyObject *t = (PyObject *)op;
    PyString_InternInPlace(&amp;t);
    op = (PyStringObject *)t;
    nullstring = op;
    Py_INCREF(op);
} else if (size == 1 &amp;&amp; str != NULL) {
    PyObject *t = (PyObject *)op;
    PyString_InternInPlace(&amp;t);
</code></pre><p>非常清晰：所有长度为<code>0</code>和<code>1</code>的字符串都会被<code>intern</code>。</p>
<h4 id="Fact-2-在编译期间字符串会被interned"><a href="#Fact-2-在编译期间字符串会被interned" class="headerlink" title="Fact 2: 在编译期间字符串会被interned"></a>Fact 2: 在编译期间字符串会被<code>interned</code></h4><p>你写的<code>Python</code>代码并不是直接被解释器执行，代码会通过一个经典的编译链来生成一种中间语言：<code>bytecode</code>（字节码）。<code>python</code>字节码是被<code>Python</code>解释器这个虚拟机执行的一系类指令。你可以在<a href="https://docs.python.org/2/library/dis.html#bytecodes" target="_blank" rel="external">这里</a>看到所有的指令。通过使用<code>dis</code>模块，你可以看到一个函数或模块执行了哪些指令：</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def foo():
...     print &apos;foo!&apos;
...
&gt;&gt;&gt; dis.dis(foo)
  2           0 LOAD_CONST               1 (&apos;foo!&apos;)
              3 PRINT_ITEM
              4 PRINT_NEWLINE       
              5 LOAD_CONST               0 (None)
              8 RETURN_VALUE
</code></pre><p>正如你知道的，在<code>Python</code>中，一切皆对象。代码也是<code>Python</code>对象，它表示了一块字节码。一个代码对象带有执行时所需要的所有信息：常量，变量名等。我们发现，当在<code>Python</code>中创建代码对象的时候，有一些字符串被<code>intern</code>了：</p>
<pre><code>PyCodeObject *
PyCode_New(int argcount, int nlocals, int stacksize, int flags,
           PyObject *code, PyObject *consts, PyObject *names,
           PyObject *varnames, PyObject *freevars, PyObject *cellvars,
           PyObject *filename, PyObject *name, int firstlineno,
           PyObject *lnotab)

           ...
           /* Intern selected string constants */
           for (i = PyTuple_Size(consts); --i &gt;= 0; ) {
               PyObject *v = PyTuple_GetItem(consts, i);
               if (!PyString_Check(v))
                   continue;
               if (!all_name_chars((unsigned char *)PyString_AS_STRING(v)))
                   continue;
               PyString_InternInPlace(&amp;PyTuple_GET_ITEM(consts, i));
           }
</code></pre><p>在<code>codeobject.c</code>中，<code>consts元组</code>包含了在编译期间定义的字面量：<code>布尔值</code>，<code>浮点数</code>，<code>整数</code>和在你的程序中声明的字符串。在这个元祖中存储的字符串，如果没有被<code>all_name_chars</code>函数过滤掉的话，将会被全部<code>intern</code>。</p>
<p>下面的例子中，<code>s1</code>是在编译期间被声明的。相反的是，<code>s2</code>是在运行时产生的：</p>
<pre><code>s1 = &apos;foo&apos;
s2 = &apos;&apos;.join([&apos;f&apos;, &apos;o&apos;, &apos;o&apos;])
</code></pre><p>结果是，<code>s1</code>将会被<code>intern</code>，<code>s2</code>不会。</p>
<p><code>all_name_chars</code>方法将会过滤掉不是由<code>ascii字符</code>，<code>数字</code>和<code>下划线</code>构成的字符串（Python中变量名的命令规范）：</p>
<pre><code>#define NAME_CHARS \
    &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&quot;

/* all_name_chars(s): true if all chars in s are valid NAME_CHARS */

static int
all_name_chars(unsigned char *s)
{
    static char ok_name_char[256];
    static unsigned char *name_chars = (unsigned char *)NAME_CHARS;

    if (ok_name_char[*name_chars] == 0) {
        unsigned char *p;
        for (p = name_chars; *p; p++)
            ok_name_char[*p] = 1;
    }
    while (*s) {
        if (ok_name_char[*s++] == 0)
            return 0;
    }
    return 1;
}
</code></pre><p>理解了这些，我们就知道了为什么<code>&#39;foo!&#39; is &#39;foo!&#39;</code>等于<code>False</code>，而<code>&#39;foo&#39; is &#39;foo&#39;</code>等于<code>True</code>，胜利了吗？还没有！</p>
<h4 id="字节码优化产生了更多字符串常量"><a href="#字节码优化产生了更多字符串常量" class="headerlink" title="字节码优化产生了更多字符串常量"></a>字节码优化产生了更多字符串常量</h4><p>这听起来和直觉不符，但是在下面的例子中，字符串连接的输出不是在运行时，而是在编译时：</p>
<pre><code>&gt;&gt;&gt; &apos;foo&apos; + &apos;bar&apos; is &apos;foobar&apos;
True
</code></pre><p>这就是为什么<code>&#39;foo&#39; + &#39;bar&#39;</code>也被<code>intern</code>了，表达式等于<code>True</code>。</p>
<p>怎么做到的？倒数第二的源码编译器生成了第一个版本的字节码。这个原始的字节码最终会进入最后一个编译器，被称作<code>“窥孔优化”</code>(<code>peephole optimization</code>)</p>
<p><img src="http://guilload.com/assets/media/python-string-interning/baz.png" alt="Compilation chain"></p>
<p>这一步的目标是通过替换更快的指令来产生更加高效的字节码。</p>
<h2 id="常量合并Constant-folding"><a href="#常量合并Constant-folding" class="headerlink" title="常量合并Constant folding"></a>常量合并<code>Constant folding</code></h2><p>在<code>窥孔优化</code>期间，应用到的一项技术就是常量合并，使用更加简单的常量。想象你是一个编译器，你看到了下面这行：</p>
<pre><code>SECONDS = 24 * 60 * 60
</code></pre><p>你能做什么来简化这个表达式以在运行时节约几个时钟周期。你可以用计算好的值<code>86400</code>来替换这个表达式。这就是<code>foo&#39; + &#39;bar&#39;</code>发生的事。让我们定义一个<code>foobar</code>函数，分解相关的字节码：</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def foobar():
...         return &apos;foo&apos; + &apos;bar&apos;
&gt;&gt;&gt; dis.dis(foobar)
  2           0 LOAD_CONST               3 (&apos;foobar&apos;)
              3 RETURN_VALUE
</code></pre><p>看到了吧！根本没有看到加法和初始的两个常量<code>&#39;foo&#39;</code>和<code>&#39;bar&#39;</code>。如果<code>CPython</code>字节码没有被优化，那么输出应该是这样的：</p>
<pre><code>&gt;&gt;&gt; dis.dis(foobar)
  2           0 LOAD_CONST               1 (&apos;foo&apos;)
              3 LOAD_CONST               2 (&apos;bar&apos;)
              6 BINARY_ADD    
              7 RETURN_VALUE
</code></pre><p>我们解决为什么下面的表达式正确的问题：</p>
<pre><code>&gt;&gt;&gt; &apos;a&apos; * 20 is &apos;aaaaaaaaaaaaaaaaaaaa&apos;
</code></pre><h4 id="避免大的-pyc-文件"><a href="#避免大的-pyc-文件" class="headerlink" title="避免大的 .pyc 文件"></a>避免大的 .pyc 文件</h4><p>那么为什么<code>&#39;a&#39; * 21 is &#39;aaaaaaaaaaaaaaaaaaaaa&#39;</code>不等于<code>True</code>呢？你还记得在你的包里面会看到的<code>.pyc</code>文件吗。如果一个人写了诸如<code>[&#39;foo!&#39;] * 10**9</code>的代码会怎么样呢？这样会导致<code>.pyc</code>文件非常巨大！为了避免这个现象，<code>窥孔优化</code>中产生的序列长度如果大于<code>20</code>，将会被丢弃。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="窥孔优化"><a href="#窥孔优化" class="headerlink" title="窥孔优化"></a>窥孔优化</h3><p>顾名思义，是一种很局部的优化方式，编译器仅仅在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则，或者通过整体的分析，通过指令转换，提升代码性能。别看这些代码转换很局部，很小，但可能会带来很大的性能提升。</p>
<p>这个窥孔，你可以认为是一个滑动窗口，编译器在实施窥孔优化时，就仅仅分析这个窗口内的指令。每次转换之后，可能还会暴露相邻窗口之间的某些优化机会，所以可以多次调用窥孔优化，尽可能提升性能。</p>
<p>窥孔优化可以在四个方面寻找优化机会：冗余指令删除，包括冗余的load和store指令以及死代码(不会执行的代码);控制流优化；强度削弱；利用特有指令。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/06/05/Python-面试题集锦-转载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/05/Python-面试题集锦-转载/" itemprop="url">Python 面试题集锦[转载]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-05T16:59:45+08:00">
                2016-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python语言特性"><a href="#Python语言特性" class="headerlink" title="Python语言特性"></a>Python语言特性</h1><h2 id="Python的函数参数传递"><a href="#Python的函数参数传递" class="headerlink" title="Python的函数参数传递"></a>Python的函数参数传递</h2><p>看两个例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></div><div class="line">    a = <span class="number">2</span></div><div class="line">fun(a)</div><div class="line"><span class="keyword">print</span> a  <span class="comment"># 1</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = []</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></div><div class="line">    a.append(<span class="number">1</span>)</div><div class="line">fun(a)</div><div class="line"><span class="keyword">print</span> a  <span class="comment"># [1]</span></div></pre></td></tr></table></figure>
<p>所有的变量都可以理解是内存中一个对象的<code>“引用”</code>，或者，也可以看似<code>c</code>中<code>void*</code>的感觉。</p>
<p>这里记住的是类型是属于对象的，而不是变量。而对象有两种,<code>“可更改”（mutable）</code>与<code>“不可更改”（immutable）</code>对象。在python中，<code>strings</code>, <code>tuples</code>, 和<code>numbers</code>是不可更改的对象，而<code>list</code>,<code>dict</code>等则是可以修改的对象。(这就是这个问题的重点)</p>
<p>当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.</p>
<p>如果还不明白的话,这里有更好的解释: <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference" target="_blank" rel="external">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p>
<h2 id="Python中的元类-metaclass"><a href="#Python中的元类-metaclass" class="headerlink" title="Python中的元类(metaclass)"></a>Python中的元类(metaclass)</h2><p>这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>
<h2 id="staticmethod和-classmethod"><a href="#staticmethod和-classmethod" class="headerlink" title="@staticmethod和@classmethod"></a>@staticmethod和@classmethod</h2><p>Python其实有3个方法,即<code>静态方法(staticmethod)</code>,<code>类方法(classmethod)</code>和<code>实例方法</code>,如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"executing foo(%s)"</span>%(x)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self,x)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"executing foo(%s,%s)"</span>%(self,x)</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls,x)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"executing class_foo(%s,%s)"</span>%(cls,x)</div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">(x)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"executing static_foo(%s)"</span>%x</div><div class="line"></div><div class="line">a=A()</div></pre></td></tr></table></figure>
<p>这里先理解下函数参数里面的<code>self</code>和<code>cls</code>. 这个<code>self</code>和<code>cls</code>是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p>
<p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p>
<table>
<thead>
<tr>
<th style="text-align:left">\</th>
<th style="text-align:left">实例方法</th>
<th style="text-align:left">类方法</th>
<th style="text-align:left">静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a = A()</td>
<td style="text-align:left">a.foo(x)</td>
<td style="text-align:left">a.class_foo(x)</td>
<td style="text-align:left">a.static_foo(x)</td>
</tr>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">不可用</td>
<td style="text-align:left">A.class_foo(x)</td>
<td style="text-align:left">A.static_foo(x)</td>
</tr>
</tbody>
</table>
<p>更多关于这个问题:<a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></p>
<h2 id="类变量和实例变量"><a href="#类变量和实例变量" class="headerlink" title="类变量和实例变量"></a>类变量和实例变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line">    name=<span class="string">"aaa"</span></div><div class="line"></div><div class="line">p1=Person()</div><div class="line">p2=Person()</div><div class="line">p1.name=<span class="string">"bbb"</span></div><div class="line"><span class="keyword">print</span> p1.name  <span class="comment"># bbb</span></div><div class="line"><span class="keyword">print</span> p2.name  <span class="comment"># aaa</span></div><div class="line"><span class="keyword">print</span> Person.name  <span class="comment"># aaa</span></div></pre></td></tr></table></figure>
<p>类变量就是供类使用的变量,实例变量就是供实例使用的.</p>
<p>这里<code>p1.name=&quot;bbb&quot;</code>是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,<code>p1.name</code>一开始是指向的类变量<code>name=&quot;aaa&quot;</code>,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,<code>self.name</code>不再引用<code>Person</code>的类变量<code>name</code>了.</p>
<p>可以看看下面的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line">    name=[]</div><div class="line"></div><div class="line">p1=Person()</div><div class="line">p2=Person()</div><div class="line">p1.name.append(<span class="number">1</span>)</div><div class="line"><span class="keyword">print</span> p1.name  <span class="comment"># [1]</span></div><div class="line"><span class="keyword">print</span> p2.name  <span class="comment"># [1]</span></div><div class="line"><span class="keyword">print</span> Person.name  <span class="comment"># [1]</span></div></pre></td></tr></table></figure>
<p>参考:<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block" target="_blank" rel="external">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p>
<h2 id="Python自省"><a href="#Python自省" class="headerlink" title="Python自省"></a>Python自省</h2><p>这个也是python彪悍的特性.</p>
<p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如<code>type()</code>,<code>dir()</code>,<code>getattr()</code>,<code>hasattr()</code>,<code>isinstance()</code>.</p>
<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d = &#123;key: value <span class="keyword">for</span> (key, value) <span class="keyword">in</span> iterable&#125;</div></pre></td></tr></table></figure>
<h2 id="Python中单下划线和双下划线"><a href="#Python中单下划线和双下划线" class="headerlink" title="Python中单下划线和双下划线"></a>Python中单下划线和双下划线</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>            self.__superprivate = <span class="string">"Hello"</span></div><div class="line"><span class="meta">... </span>            self._semiprivate = <span class="string">", world!"</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mc = MyClass()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__superprivate</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: myClass instance has no attribute <span class="string">'__superprivate'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc._semiprivate</div><div class="line">, world!</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__dict__</div><div class="line">&#123;<span class="string">'_MyClass__superprivate'</span>: <span class="string">'Hello'</span>, <span class="string">'_semiprivate'</span>: <span class="string">', world!'</span>&#125;</div></pre></td></tr></table></figure>
<p><code>__foo__</code>: 一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突.</p>
<p><code>_foo</code>: 一种约定,用来指定变量私有. 程序员用来指定私有变量的一种方式.</p>
<p><code>__foo</code>: 这个有真正的意义: 解析器用<code>_classname__foo</code>来代替这个名字,以区别和其他类相同的命名.</p>
<p>详情见: <a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></p>
<p>或者: <a href="http://www.zhihu.com/question/19754941" target="_blank" rel="external">http://www.zhihu.com/question/19754941</a></p>
<h2 id="字符串格式化-和-format"><a href="#字符串格式化-和-format" class="headerlink" title="字符串格式化:%和.format"></a>字符串格式化:%和.format</h2><p><code>.format</code>在许多方面看起来更便利.对于<code>%</code>最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;hi there %s&quot; % name</div></pre></td></tr></table></figure>
<p>但是,如果name恰好是<code>(1,2,3)</code>,它将会抛出一个<code>TypeError</code>异常.为了保证它总是正确的,你必须这样做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;hi there %s&quot; % (name,)   # 提供一个单元素的数组而不是一个参数</div></pre></td></tr></table></figure>
<p>但是有点丑. <code>.format</code>就没有这些问题. 你给的第二个问题也是这样, <code>.format</code>好看多了.</p>
<p>你为什么不用它?</p>
<ul>
<li>不知道它(在读这个之前)</li>
<li>为了和Python2.5兼容(譬如logging库建议使用<code>%</code>(<a href="https://github.com/taizilongxu/interview_python/issues/4" target="_blank" rel="external">issue #4</a>))</li>
</ul>
<p><a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format" target="_blank" rel="external">http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format</a></p>
<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><p>这个是<code>stackoverflow</code>里python排名第一的问题,值得一看: <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python</a></p>
<p>这是中文版: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html" target="_blank" rel="external">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a></p>
<h2 id="args-and-kwargs"><a href="#args-and-kwargs" class="headerlink" title="*args and **kwargs"></a><code>*args</code> and <code>**kwargs</code></h2><p>用<code>*args</code>和<code>**kwargs</code>只是为了方便并没有强制使用它们.</p>
<p>当你不确定你的函数里将要传递多少参数时你可以用<code>*args</code>.例如,它可以传递任意数量的参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_everything</span><span class="params">(*args)</span>:</span></div><div class="line">        <span class="keyword">for</span> count, thing <span class="keyword">in</span> enumerate(args):</div><div class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'&#123;0&#125;. &#123;1&#125;'</span>.format(count, thing)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print_everything(<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'cabbage'</span>)</div><div class="line"><span class="number">0.</span> apple</div><div class="line"><span class="number">1.</span> banana</div><div class="line"><span class="number">2.</span> cabbage</div></pre></td></tr></table></figure>
<p>相似的,<code>**kwargs</code>允许你使用没有事先定义的参数名:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">table_things</span><span class="params">(**kwargs)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</div><div class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'&#123;0&#125; = &#123;1&#125;'</span>.format(name, value)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>table_things(apple = <span class="string">'fruit'</span>, cabbage = <span class="string">'vegetable'</span>)</div><div class="line">cabbage = vegetable</div><div class="line">apple = fruit</div></pre></td></tr></table></figure>
<p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>.命名参数在列表的最前端.例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def table_things(titlestring, **kwargs)</div></pre></td></tr></table></figure>
<p><code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中,但是<code>*args</code>必须在<code>**kwargs</code>前面.</p>
<p>当调用函数时你也可以用<code>*</code>和<code>**</code>语法.例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_three_things</span><span class="params">(a, b, c)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;'</span>.format(a,b,c)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="string">'aardvark'</span>, <span class="string">'baboon'</span>, <span class="string">'cat'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print_three_things(*mylist)</div><div class="line"></div><div class="line">a = aardvark, b = baboon, c = cat</div></pre></td></tr></table></figure>
<p>就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.</p>
<p><a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="external">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p>
<h2 id="面向切面编程AOP和装饰器"><a href="#面向切面编程AOP和装饰器" class="headerlink" title="面向切面编程AOP和装饰器"></a>面向切面编程AOP和装饰器</h2><p>这个AOP一听起来有点懵,同学面阿里的时候就被问懵了…</p>
<p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有<code>插入日志</code>、<code>性能测试</code>、<code>事务处理</code>等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，<strong>装饰器的作用就是为已经存在的对象添加额外的功能。</strong></p>
<p>这个问题比较大,推荐: <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a></p>
<p>中文: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html" target="_blank" rel="external">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></p>
<h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><blockquote>
<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>
</blockquote>
<p>我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。</p>
<p>比如在python中，有很多<code>file-like</code>的东西，比如<code>StringIO</code>, <code>GzipFile ,</code>socket`。它们有很多相同的方法，我们把它们当作文件使用。</p>
<p>又比如<code>list.extend()</code>方法中,我们并不关心它的参数是不是<code>list</code>,只要它是可迭代的,所以它的参数可以是<code>list/tuple/dict/字符串/生成器</code>等.</p>
<p>鸭子类型在动态语言中经常使用，非常灵活，<strong>使得python不想java那样专门去弄一大堆的设计模式</strong>。</p>
<h2 id="Python中重载"><a href="#Python中重载" class="headerlink" title="Python中重载"></a>Python中重载</h2><p>引自知乎: <a href="http://www.zhihu.com/question/20053359" target="_blank" rel="external">http://www.zhihu.com/question/20053359</a></p>
<p>函数重载主要是为了解决两个问题。</p>
<ol>
<li>可变参数类型。</li>
<li>可变参数个数。</li>
</ol>
<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p>
<p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p>
<p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p>
<p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p>
<h2 id="新式类和旧式类"><a href="#新式类和旧式类" class="headerlink" title="新式类和旧式类"></a>新式类和旧式类</h2><p>这个面试官问了,我说了老半天,不知道他问的真正意图是什么.</p>
<p><a href="http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python</a></p>
<p><a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html" target="_blank" rel="external">这篇文章</a>很好的介绍了新式类的特性</p>
<p>新式类很早在2.2就出现了,所以旧式类完全是兼容的问题, <strong>Python3里的类全部都是新式类</strong>. 这里有一个<code>MRO</code>问题可以了解下(新式类是广度优先, 旧式类是深度优先), <python核心编程>里讲的也很多.</python核心编程></p>
<h2 id="new-和-init-的区别"><a href="#new-和-init-的区别" class="headerlink" title="__new__和__init__的区别"></a><code>__new__</code>和<code>__init__</code>的区别</h2><ol>
<li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li>
<li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li>
<li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</li>
<li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li>
</ol>
<p><a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init" target="_blank" rel="external">http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init</a></p>
<p>ps: <code>__metaclass__</code>是创建类时起作用.所以我们可以分别使用<code>__metaclass__</code>,<code>__new__</code>和<code>__init__</code>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.</p>
<h3 id="使用-new-方法"><a href="#使用-new-方法" class="headerlink" title="使用__new__方法"></a>使用<code>__new__</code>方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</div><div class="line">            orig = super(Singleton, cls)</div><div class="line">            cls._instance = orig.__new__(cls, *args, **kw)</div><div class="line">        <span class="keyword">return</span> cls._instance</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></div><div class="line">    a = <span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="共享属性"><a href="#共享属性" class="headerlink" title="共享属性"></a>共享属性</h3><p>创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></div><div class="line">    _state = &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></div><div class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</div><div class="line">        ob.__dict__ = cls._state</div><div class="line">        <span class="keyword">return</span> ob</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></div><div class="line">    a = <span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="装饰器版本"><a href="#装饰器版本" class="headerlink" title="装饰器版本"></a>装饰器版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls, *args, **kw)</span>:</span></div><div class="line">    instances = &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</div><div class="line">            instances[cls] = cls(*args, **kw)</div><div class="line">        <span class="keyword">return</span> instances[cls]</div><div class="line">    <span class="keyword">return</span> getinstance</div><div class="line"></div><div class="line"><span class="meta">@singleton</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></div><div class="line">  ...</div></pre></td></tr></table></figure>
<h3 id="import方法"><a href="#import方法" class="headerlink" title="import方法"></a>import方法</h3><p>作为python的模块是天然的单例模式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mysingleton.py</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">my_singleton = My_Singleton()</div><div class="line"></div><div class="line"><span class="comment"># to use</span></div><div class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</div><div class="line"></div><div class="line">my_singleton.foo()</div></pre></td></tr></table></figure>
<h2 id="Python中的作用域"><a href="#Python中的作用域" class="headerlink" title="Python中的作用域"></a>Python中的作用域</h2><p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p>
<p>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</p>
<p><code>本地作用域（Local）</code>→ <code>当前作用域被嵌入的本地作用域（Enclosing locals）</code>→ <code>全局/模块作用域（Global）</code>→ <code>内置作用域（Built-in）</code></p>
<h2 id="GIL线程全局锁"><a href="#GIL线程全局锁" class="headerlink" title="GIL线程全局锁"></a>GIL线程全局锁</h2><p>线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.</p>
<p>见<a href="http://www.oschina.net/translate/pythons-hardest-problem" target="_blank" rel="external">Python 最难的问题</a></p>
<p>解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>知乎被问到了,呵呵哒,跪了</p>
<p>简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</p>
<p>Python里最常见的yield就是协程的思想!可以查看第九个问题.</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p>
<p>当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</p>
<ol>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数中的变量</li>
<li>外部函数的返回值必须是内嵌函数</li>
</ol>
<p>感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.</p>
<p>重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.</p>
<p>闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.</p>
<h2 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h2><p>其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.</p>
<p>推荐: <a href="http://www.zhihu.com/question/20125256" target="_blank" rel="external">知乎</a></p>
<h2 id="Python函数式编程"><a href="#Python函数式编程" class="headerlink" title="Python函数式编程"></a>Python函数式编程</h2><p>这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.</p>
<p>推荐: <a href="http://coolshell.cn/articles/10822.html" target="_blank" rel="external">酷壳</a></p>
<p>python中函数式编程支持:</p>
<p>filter 函数的功能相当于过滤器。调用一个布尔函数<code>bool_func</code>来迭代遍历每个seq中的元素；返回一个使<code>bool_seq</code>返回值为true的元素的序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</div><div class="line">&gt;&gt;&gt;b = filter(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, a)</div><div class="line">&gt;&gt;&gt;<span class="keyword">print</span> b</div><div class="line">&gt;&gt;&gt;[<span class="number">6</span>,<span class="number">7</span>]</div></pre></td></tr></table></figure>
<p>map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = map(<span class="keyword">lambda</span> x:x*<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(a)</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<p>reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x*y,range(<span class="number">1</span>,<span class="number">4</span>))</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<h2 id="Python里的拷贝"><a href="#Python里的拷贝" class="headerlink" title="Python里的拷贝"></a>Python里的拷贝</h2><p>引用和copy(),deepcopy()的区别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> copy</div><div class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]  <span class="comment">#原始对象</span></div><div class="line"></div><div class="line">b = a  <span class="comment">#赋值，传对象的引用</span></div><div class="line">c = copy.copy(a)  <span class="comment">#对象拷贝，浅拷贝</span></div><div class="line">d = copy.deepcopy(a)  <span class="comment">#对象拷贝，深拷贝</span></div><div class="line"></div><div class="line">a.append(<span class="number">5</span>)  <span class="comment">#修改对象a</span></div><div class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>)  <span class="comment">#修改对象a中的['a', 'b']数组对象</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'a = '</span>, a</div><div class="line"><span class="keyword">print</span> <span class="string">'b = '</span>, b</div><div class="line"><span class="keyword">print</span> <span class="string">'c = '</span>, c</div><div class="line"><span class="keyword">print</span> <span class="string">'d = '</span>, d</div><div class="line"></div><div class="line">输出结果：</div><div class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</div><div class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</div><div class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</div><div class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</div></pre></td></tr></table></figure>
<h2 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h2><p><code>Python GC</code>主要使用引用计数（<code>reference counting</code>）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（<code>mark and sweep</code>）解决容器对象可能产生的循环引用问题，通过“分代回收”（<code>generation collection</code>）以空间换时间的方法提高垃圾回收效率。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>PyObject是每个对象必有的内容，其中<code>ob_refcnt</code>就是做为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt</code>就会减少.引用计数为0时，该对象生命就结束了。</p>
<p>优点:</p>
<ol>
<li>简单</li>
<li>实时性</li>
</ol>
<p>缺点:</p>
<ol>
<li>维护引用计数消耗资源</li>
<li>循环引用</li>
</ol>
<h3 id="标记-清除机制"><a href="#标记-清除机制" class="headerlink" title="标记-清除机制"></a>标记-清除机制</h3><p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>
<h3 id="分代技术"><a href="#分代技术" class="headerlink" title="分代技术"></a>分代技术</h3><p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p>
<p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p>
<p>举例：<br>当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。</p>
<h2 id="Python的List"><a href="#Python的List" class="headerlink" title="Python的List"></a>Python的List</h2><p>推荐: <a href="http://www.jianshu.com/p/J4U6rR" target="_blank" rel="external">http://www.jianshu.com/p/J4U6rR</a></p>
<h2 id="Python的is"><a href="#Python的is" class="headerlink" title="Python的is"></a>Python的is</h2><p><strong>is是对比地址,==是对比值</strong></p>
<h2 id="read-readline和readlines"><a href="#read-readline和readlines" class="headerlink" title="read,readline和readlines"></a>read,readline和readlines</h2><ul>
<li>read        读取整个文件</li>
<li>readline    读取下一行,使用生成器方法</li>
<li>readlines   读取整个文件到一个迭代器以供我们遍历</li>
</ul>
<h2 id="Python2和3的区别"><a href="#Python2和3的区别" class="headerlink" title="Python2和3的区别"></a>Python2和3的区别</h2><p>推荐：<a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/" target="_blank" rel="external">Python 2.7.x 与 Python 3.x 的主要差异</a></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="select-poll和epoll"><a href="#select-poll和epoll" class="headerlink" title="select,poll和epoll"></a>select,poll和epoll</h2><p>其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.</p>
<p>这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.</p>
<p><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="external">selec,poll和epoll区别总结</a></p>
<p>基本上select有3个缺点:</p>
<ol>
<li>连接数受限</li>
<li>查找配对速度慢</li>
<li>数据由内核拷贝到用户态</li>
</ol>
<p>poll改善了第一个缺点</p>
<p>epoll改了三个缺点.</p>
<p>关于epoll的: <a href="http://www.cnblogs.com/my_life/articles/3968782.html" target="_blank" rel="external">http://www.cnblogs.com/my_life/articles/3968782.html</a></p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ol>
<li>先来先服务(FCFS, First Come First Serve)</li>
<li>短作业优先(SJF, Shortest Job First)</li>
<li>最高优先权调度(Priority Scheduling)</li>
<li>时间片轮转(RR, Round Robin)</li>
<li>多级反馈队列调度(multilevel feedback queue scheduling)</li>
</ol>
<p>实时调度算法:</p>
<ol>
<li>最早截至时间优先 EDF</li>
<li>最低松弛度优先 LLF</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>原因:</p>
<ol>
<li>竞争资源</li>
<li>程序推进顺序不当</li>
</ol>
<p>必要条件:</p>
<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ol>
<p>处理死锁基本方法:</p>
<ol>
<li>预防死锁(摒弃除1以外的条件)</li>
<li>避免死锁(银行家算法)</li>
<li>检测死锁(资源分配图)</li>
<li>解除死锁<ol>
<li>剥夺资源</li>
<li>撤销进程</li>
</ol>
</li>
</ol>
<h2 id="程序编译与链接"><a href="#程序编译与链接" class="headerlink" title="程序编译与链接"></a>程序编译与链接</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a></p>
<p>Bulid过程可以分解为4个步骤: <code>预处理(Prepressing)</code>, <code>编译(Compilation)</code>、<code>汇编(Assembly)</code>、<code>链接(Linking)</code></p>
<p>以c语言为例:</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有：</p>
<ol>
<li>将所有的“#define”删除，并展开所用的宏定义</li>
<li>处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的</li>
<li>删除所有注释</li>
<li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号</li>
<li>保留所有的#pragma编译器指令。</li>
</ol>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File)</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。<br>链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。</p>
<h2 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h2><p>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来<br>静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库</p>
<p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序</p>
<h2 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h2><p>虚拟存储器是值具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统.</p>
<h2 id="分页和分段"><a href="#分页和分段" class="headerlink" title="分页和分段"></a>分页和分段</h2><p>分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p>
<p>分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</p>
<h3 id="分页与分段的主要区别"><a href="#分页与分段的主要区别" class="headerlink" title="分页与分段的主要区别"></a>分页与分段的主要区别</h3><ol>
<li>页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.</li>
<li>页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.</li>
<li>分页的作业地址空间是一维的.分段的地址空间是二维的.</li>
</ol>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ol>
<li>最佳置换算法OPT:不可能实现</li>
<li>先进先出FIFO</li>
<li>最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换.</li>
<li>clock算法</li>
</ol>
<h2 id="边沿触发和水平触发"><a href="#边沿触发和水平触发" class="headerlink" title="边沿触发和水平触发"></a>边沿触发和水平触发</h2><p>边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>数据库事务(<code>Database Transaction</code>) ，是指作为单个逻辑工作单元执行的一系列操作，<strong>要么完全地执行，要么完全地不执行</strong>。</p>
<h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>推荐: <a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="external">http://tech.meituan.com/mysql-index.html</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></p>
<p><code>聚集索引</code>, <code>非聚集索引</code>, <code>B-Tree</code>, <code>B+Tree</code>, <code>最左前缀原理</code></p>
<h2 id="Redis原理"><a href="#Redis原理" class="headerlink" title="Redis原理"></a>Redis原理</h2><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h2 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h2><p><code>MyISAM</code> 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要<code>update</code>一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 <code>SELECT COUNT(*)</code> 这类的计算是超快无比的。</p>
<p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol>
<li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数 A。</li>
<li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。</li>
<li>最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。</li>
</ol>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>地址解析协议(<code>Address Resolution Protocol</code>): 根据IP地址获取物理地址的一个TCP/IP协议</p>
<h2 id="urllib和urllib2的区别"><a href="#urllib和urllib2的区别" class="headerlink" title="urllib和urllib2的区别"></a>urllib和urllib2的区别</h2><p>这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.</p>
<ol>
<li>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li>
<li>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。</li>
</ol>
<h2 id="Post和Get"><a href="#Post和Get" class="headerlink" title="Post和Get"></a>Post和Get</h2><p><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html" target="_blank" rel="external">GET和POST有什么区别？及为什么网上的多数答案都是错的</a></p>
<p>get: <a href="http://tools.ietf.org/html/rfc2616#section-9.3" target="_blank" rel="external">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a><br>post: <a href="http://tools.ietf.org/html/rfc2616#section-9.5" target="_blank" rel="external">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a></p>
<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Cookie</th>
<th style="text-align:left">Session</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">储存位置</td>
<td style="text-align:left">客户端</td>
<td style="text-align:left">服务器端</td>
</tr>
<tr>
<td style="text-align:left">目的</td>
<td style="text-align:left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>
<td style="text-align:left">跟踪会话</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:left">不安全</td>
<td style="text-align:left">安全</td>
</tr>
</tbody>
</table>
<p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p>
<h2 id="apache和nginx的区别"><a href="#apache和nginx的区别" class="headerlink" title="apache和nginx的区别"></a>apache和nginx的区别</h2><p>nginx 相对 apache 的优点：</p>
<ul>
<li>轻量级，同样起web 服务，比apache 占用更少的内存及资源</li>
<li>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</li>
<li>配置简洁</li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>社区活跃</li>
</ul>
<p>apache 相对nginx 的优点：</p>
<ul>
<li>rewrite ，比nginx 的rewrite 强大</li>
<li>模块超多，基本想到的都可以找到</li>
<li>少bug ，nginx 的bug 相对较多</li>
<li>超稳定</li>
</ul>
<h2 id="网站用户密码保存"><a href="#网站用户密码保存" class="headerlink" title="网站用户密码保存"></a>网站用户密码保存</h2><ol>
<li>明文保存</li>
<li>明文hash后保存,如md5</li>
<li>MD5+Salt方式,这个salt可以随机</li>
<li>知乎使用了Bcrypy(好像)加密</li>
</ol>
<h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1xx 报告</td>
<td style="text-align:left">接收到请求，继续进程</td>
</tr>
<tr>
<td style="text-align:left">2xx 成功</td>
<td style="text-align:left">步骤成功接收，被理解，并被接受</td>
</tr>
<tr>
<td style="text-align:left">3xx 重定向</td>
<td style="text-align:left">为了完成请求,必须采取进一步措施</td>
</tr>
<tr>
<td style="text-align:left">4xx 客户端出错</td>
<td style="text-align:left">请求包括错的顺序或不能完成</td>
</tr>
<tr>
<td style="text-align:left">5xx 服务器出错</td>
<td style="text-align:left">服务器无法完成显然有效的请求</td>
</tr>
</tbody>
</table>
<p><code>403: Forbidden</code><br><code>404: Not Found</code></p>
<p>HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA</p>
<h2 id="XSRF和XSS"><a href="#XSRF和XSS" class="headerlink" title="XSRF和XSS"></a>XSRF和XSS</h2><ul>
<li>CSRF(Cross-site request forgery)跨站请求伪造</li>
<li>XSS(Cross Site Scripting)跨站脚本攻击</li>
</ul>
<p>CSRF重点在请求, XSS重点在脚本</p>
<h2 id="幂等-Idempotence"><a href="#幂等-Idempotence" class="headerlink" title="幂等 Idempotence"></a>幂等 Idempotence</h2><p>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的<strong>副作用</strong>。(注意是副作用)</p>
<p><code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。<code>GET http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</p>
<p>DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：<code>DELETE http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p>
<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。</p>
<p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p>
<h2 id="RESTful架构-SOAP-RPC"><a href="#RESTful架构-SOAP-RPC" class="headerlink" title="RESTful架构(SOAP,RPC)"></a>RESTful架构(SOAP,RPC)</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
<h2 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h2><p>SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<p>总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap. 当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.</p>
<p>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</p>
<h2 id="CGI和WSGI"><a href="#CGI和WSGI" class="headerlink" title="CGI和WSGI"></a>CGI和WSGI</h2><p>CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。</p>
<p>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p>
<p>WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p>
<p>官方说明：<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="external">PEP-3333</a></p>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>在GFW里屡见不鲜的,呵呵.</p>
<p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<h2 id="c10k问题"><a href="#c10k问题" class="headerlink" title="c10k问题"></a>c10k问题</h2><p>所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。<br>推荐: <a href="http://www.kegel.com/c10k.html" target="_blank" rel="external">http://www.kegel.com/c10k.html</a></p>
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>推荐: <a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml" target="_blank" rel="external">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p>
<p>Socket = Ip address + TCP/UDP + port</p>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>推荐: <a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p>
<p>304 Not Modified</p>
<h2 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h2><p>推荐: <a href="http://blog.csdn.net/elifefly/article/details/3964766" target="_blank" rel="external">http://blog.csdn.net/elifefly/article/details/3964766</a></p>
<ol>
<li>请求头Host字段,一个服务器多个网站</li>
<li>长链接</li>
<li>文件断点续传</li>
<li>身份认证,状态管理,Cache缓存</li>
</ol>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p>
<h1 id="NIX"><a href="#NIX" class="headerlink" title="*NIX"></a>*NIX</h1><h2 id="unix进程间通信方式-IPC"><a href="#unix进程间通信方式-IPC" class="headerlink" title="unix进程间通信方式(IPC)"></a>unix进程间通信方式(IPC)</h2><ol>
<li>管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li>
<li>命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>
<li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li>
<li>消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li>
<li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li>
<li>内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>
<li>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树与AVL的比较：</p>
<p>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</p>
<p>红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；</p>
<p>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="台阶问题-斐波纳挈"><a href="#台阶问题-斐波纳挈" class="headerlink" title="台阶问题/斐波纳挈"></a>台阶问题/斐波纳挈</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt;= <span class="number">2</span> <span class="keyword">else</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>第二种记忆方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">memo</span><span class="params">(func)</span>:</span></div><div class="line">    cache = &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(*args)</span>:</span></div><div class="line">        <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> cache:</div><div class="line">            cache[args] = func(*args)</div><div class="line">        <span class="keyword">return</span> cache[args]</div><div class="line">    <span class="keyword">return</span> wrap</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@memo</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">if</span> i &lt; <span class="number">2</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> fib(i<span class="number">-1</span>) + fib(i<span class="number">-2</span>)</div></pre></td></tr></table></figure>
<p>第三种方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></div><div class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n):</div><div class="line">        a, b = b, a + b</div><div class="line">    <span class="keyword">return</span> b</div></pre></td></tr></table></figure>
<h2 id="变态台阶问题"><a href="#变态台阶问题" class="headerlink" title="变态台阶问题"></a>变态台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span> * fib(n - <span class="number">1</span>)</div></pre></td></tr></table></figure>
<h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p>
<blockquote>
<p>第<code>2*n</code>个矩形的覆盖方法等于第<code>2*(n-1)</code>加上第<code>2*(n-2)</code>的方法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f = <span class="keyword">lambda</span> n: <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h2 id="杨氏矩阵查找"><a href="#杨氏矩阵查找" class="headerlink" title="杨氏矩阵查找"></a>杨氏矩阵查找</h2><p>在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="去除列表中的重复元素"><a href="#去除列表中的重复元素" class="headerlink" title="去除列表中的重复元素"></a>去除列表中的重复元素</h2><p>用集合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list(set(l))</div></pre></td></tr></table></figure>
<p>用字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</div><div class="line">l2 = &#123;&#125;.fromkeys(l1).keys()</div><div class="line"><span class="keyword">print</span> l2</div></pre></td></tr></table></figure>
<p>用字典并保持顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</div><div class="line">l2 = list(set(l1))</div><div class="line">l2.sort(key=l1.index)</div><div class="line"><span class="keyword">print</span> l2</div></pre></td></tr></table></figure>
<p>列表推导式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</div><div class="line">l2 = []</div><div class="line">[l2.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> l2]</div></pre></td></tr></table></figure>
<p>面试官提到的,先排序然后删除.</p>
<h2 id="链表成对调换"><a href="#链表成对调换" class="headerlink" title="链表成对调换"></a>链表成对调换</h2><p><code>1-&gt;2-&gt;3-&gt;4</code>转换成<code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param a ListNode</span></div><div class="line">    <span class="comment"># @return a ListNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="keyword">if</span> head != <span class="keyword">None</span> <span class="keyword">and</span> head.next != <span class="keyword">None</span>:</div><div class="line">            next = head.next</div><div class="line">            head.next = self.swapPairs(next.next)</div><div class="line">            next.next = head</div><div class="line">            <span class="keyword">return</span> next</div><div class="line">        <span class="keyword">return</span> head</div></pre></td></tr></table></figure>
<h2 id="创建字典的方法"><a href="#创建字典的方法" class="headerlink" title="创建字典的方法"></a>创建字典的方法</h2><h3 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dict = &#123;<span class="string">'name'</span>:<span class="string">'earth'</span>, <span class="string">'port'</span>:<span class="string">'80'</span>&#125;</div></pre></td></tr></table></figure>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">items=[(<span class="string">'name'</span>,<span class="string">'earth'</span>),(<span class="string">'port'</span>,<span class="string">'80'</span>)]</div><div class="line">dict2=dict(items)</div><div class="line">dict1=dict(([<span class="string">'name'</span>,<span class="string">'earth'</span>],[<span class="string">'port'</span>,<span class="string">'80'</span>]))</div></pre></td></tr></table></figure>
<h3 id="fromkeys-方法"><a href="#fromkeys-方法" class="headerlink" title="fromkeys()方法"></a>fromkeys()方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dict1=&#123;&#125;.fromkeys((<span class="string">'x'</span>,<span class="string">'y'</span>),<span class="number">-1</span>)</div><div class="line">dict=&#123;<span class="string">'x'</span>:<span class="number">-1</span>,<span class="string">'y'</span>:<span class="number">-1</span>&#125;</div><div class="line">dict2=&#123;&#125;.fromkeys((<span class="string">'x'</span>,<span class="string">'y'</span>))</div><div class="line">dict2=&#123;<span class="string">'x'</span>:<span class="keyword">None</span>, <span class="string">'y'</span>:<span class="keyword">None</span>&#125;</div></pre></td></tr></table></figure>
<h2 id="合并两个有序列表"><a href="#合并两个有序列表" class="headerlink" title="合并两个有序列表"></a>合并两个有序列表</h2><p>知乎远程面试要求编程</p>
<p>尾递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_recursion_merge_sort2</span><span class="params">(l1, l2, tmp)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(l1) == <span class="number">0</span> <span class="keyword">or</span> len(l2) == <span class="number">0</span>:</div><div class="line">        tmp.extend(l1)</div><div class="line">        tmp.extend(l2)</div><div class="line">        <span class="keyword">return</span> tmp</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">if</span> l1[<span class="number">0</span>] &lt; l2[<span class="number">0</span>]:</div><div class="line">            tmp.append(l1[<span class="number">0</span>])</div><div class="line">            <span class="keyword">del</span> l1[<span class="number">0</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            tmp.append(l2[<span class="number">0</span>])</div><div class="line">            <span class="keyword">del</span> l2[<span class="number">0</span>]</div><div class="line">        <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, tmp)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_merge_sort2</span><span class="params">(l1, l2)</span>:</span></div><div class="line">    <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, [])</div></pre></td></tr></table></figure>
<p>循环算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def loop_merge_sort(l1, l2):</div><div class="line">    tmp = []</div><div class="line">    while len(l1) &gt; 0 and len(l2) &gt; 0:</div><div class="line">        if l1[0] &lt; l2[0]:</div><div class="line">            tmp.append(l1[0])</div><div class="line">            del l1[0]</div><div class="line">        else:</div><div class="line">            tmp.append(l2[0])</div><div class="line">            del l2[0]</div><div class="line">    tmp.extend(l1)</div><div class="line">    tmp.extend(l2)</div><div class="line">    return tmp</div></pre></td></tr></table></figure>
<h2 id="交叉链表求交点"><a href="#交叉链表求交点" class="headerlink" title="交叉链表求交点"></a>交叉链表求交点</h2><p>去哪儿的面试,没做出来.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span><span class="params">(l1, l2)</span>:</span></div><div class="line">    length1, lenth2 = <span class="number">0</span>, <span class="number">0</span></div><div class="line">    <span class="comment"># 求两个链表长度</span></div><div class="line">    <span class="keyword">while</span> l1.next:</div><div class="line">        l1 = l1.next</div><div class="line">        length1 += <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> l2.next:</div><div class="line">        l2 = l2.next</div><div class="line">        length2 += <span class="number">1</span></div><div class="line">    <span class="comment"># 长的链表先走</span></div><div class="line">    <span class="keyword">if</span> length1 &gt; lenth2:</div><div class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(length1 - length2):</div><div class="line">            l1 = l1.next</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(length2 - length1):</div><div class="line">            l2 = l2.next</div><div class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</div><div class="line">        <span class="keyword">if</span> l1.next == l2.next:</div><div class="line">            <span class="keyword">return</span> l1.next</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            l1 = l1.next</div><div class="line">            l2 = l2.next</div></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(l, t)</span>:</span></div><div class="line">    low, high = <span class="number">0</span>, len(l) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> low &lt; high:</div><div class="line">        <span class="keyword">print</span> low, high</div><div class="line">        mid = (low + high) / <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> l[mid] &gt; t:</div><div class="line">            high = mid</div><div class="line">        <span class="keyword">elif</span> l[mid] &lt; t:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">    <span class="keyword">return</span> low <span class="keyword">if</span> l[low] == t <span class="keyword">else</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    l = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">120</span>, <span class="number">444</span>]</div><div class="line">    <span class="keyword">print</span> binarySearch(l, <span class="number">12</span>)</div><div class="line">    <span class="keyword">print</span> binarySearch(l, <span class="number">1</span>)</div><div class="line">    <span class="keyword">print</span> binarySearch(l, <span class="number">13</span>)</div><div class="line">    <span class="keyword">print</span> binarySearch(l, <span class="number">444</span>)</div></pre></td></tr></table></figure>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(seq)</span>:</span></div><div class="line">    <span class="keyword">if</span> seq==[]:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        pivot=seq[<span class="number">0</span>]</div><div class="line">        lesser=qsort([x <span class="keyword">for</span> x <span class="keyword">in</span> seq[<span class="number">1</span>:] <span class="keyword">if</span> x&lt;pivot])</div><div class="line">        greater=qsort([x <span class="keyword">for</span> x <span class="keyword">in</span> seq[<span class="number">1</span>:] <span class="keyword">if</span> x&gt;=pivot])</div><div class="line">        <span class="keyword">return</span> lesser+[pivot]+greater</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    seq=[<span class="number">5</span>,<span class="number">6</span>,<span class="number">78</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-65</span>,<span class="number">12</span>]</div><div class="line">    print(qsort(seq))</div></pre></td></tr></table></figure>
<h2 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span>  <span class="title">coinChange</span><span class="params">(values, money, coinsUsed)</span>:</span></div><div class="line">    <span class="comment">#values    T[1:n]数组</span></div><div class="line">    <span class="comment">#valuesCounts   钱币对应的种类数</span></div><div class="line">    <span class="comment">#money  找出来的总钱数</span></div><div class="line">    <span class="comment">#coinsUsed   对应于目前钱币总数i所使用的硬币数目</span></div><div class="line">    <span class="keyword">for</span> cents <span class="keyword">in</span> range(<span class="number">1</span>, money+<span class="number">1</span>):</div><div class="line">        minCoins = cents     <span class="comment">#从第一个开始到money的所有情况初始</span></div><div class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</div><div class="line">            <span class="keyword">if</span> value &lt;= cents:</div><div class="line">                temp = coinsUsed[cents - value] + <span class="number">1</span></div><div class="line">                <span class="keyword">if</span> temp &lt; minCoins:</div><div class="line">                    minCoins = temp</div><div class="line">        coinsUsed[cents] = minCoins</div><div class="line">        print(<span class="string">'面值为：&#123;0&#125; 的最小硬币数目为：&#123;1&#125; '</span>.format(cents, coinsUsed[cents]) )</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    values = [ <span class="number">25</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</div><div class="line">    money = <span class="number">63</span></div><div class="line">    coinsUsed = &#123;i:<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(money+<span class="number">1</span>)&#125;</div><div class="line">    coinChange(values, money, coinsUsed)</div></pre></td></tr></table></figure>
<h2 id="广度遍历和深度遍历二叉树"><a href="#广度遍历和深度遍历二叉树" class="headerlink" title="广度遍历和深度遍历二叉树"></a>广度遍历和深度遍历二叉树</h2><p>给定一个数组，构建二叉树，并且按层次打印这个二叉树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 14 二叉树节点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, left=None, right=None)</span>:</span></div><div class="line">        self.data = data</div><div class="line">        self.left = left</div><div class="line">        self.right = right</div><div class="line"></div><div class="line">tree = Node(<span class="number">1</span>, Node(<span class="number">3</span>, Node(<span class="number">7</span>, Node(<span class="number">0</span>)), Node(<span class="number">6</span>)), Node(<span class="number">2</span>, Node(<span class="number">5</span>), Node(<span class="number">4</span>)))</div><div class="line"></div><div class="line"><span class="comment">## 层次遍历</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span><span class="params">(root)</span>:</span></div><div class="line">    stack = [root]</div><div class="line">    <span class="keyword">while</span> stack:</div><div class="line">        current = stack.pop(<span class="number">0</span>)</div><div class="line">        <span class="keyword">print</span> current.data</div><div class="line">        <span class="keyword">if</span> current.left:</div><div class="line">            stack.append(current.left)</div><div class="line">        <span class="keyword">if</span> current.right:</div><div class="line">            stack.append(current.right)</div><div class="line"><span class="comment">## 深度遍历</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span><span class="params">(root)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="keyword">print</span> root.data</div><div class="line">    deep(root.left)</div><div class="line">    deep(root.right)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    lookup(tree)</div><div class="line">    deep(tree)</div></pre></td></tr></table></figure>
<h2 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h2><p>深度遍历改变顺序就OK了</p>
<h2 id="求最大树深"><a href="#求最大树深" class="headerlink" title="求最大树深"></a>求最大树深</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(root)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="求两棵树是否相同"><a href="#求两棵树是否相同" class="headerlink" title="求两棵树是否相同"></a>求两棵树是否相同</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(p, q)</span>:</span></div><div class="line">    <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">elif</span> p <span class="keyword">and</span> q :</div><div class="line">        <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> isSameTree(p.left,q.left) <span class="keyword">and</span> isSameTree(p.right,q.right)</div><div class="line">    <span class="keyword">else</span> :</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h2 id="前序中序求后序"><a href="#前序中序求后序" class="headerlink" title="前序中序求后序"></a>前序中序求后序</h2><p>推荐: <a href="http://blog.csdn.net/hinyunsin/article/details/6315502" target="_blank" rel="external">http://blog.csdn.net/hinyunsin/article/details/6315502</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebuild</span><span class="params">(pre, center)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    cur = Node(pre[<span class="number">0</span>])</div><div class="line">    index = center.index(pre[<span class="number">0</span>])</div><div class="line">    cur.left = rebuild(pre[<span class="number">1</span>:index + <span class="number">1</span>], center[:index])</div><div class="line">    cur.right = rebuild(pre[index + <span class="number">1</span>:], center[index + <span class="number">1</span>:])</div><div class="line">    <span class="keyword">return</span> cur</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span><span class="params">(root)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    deep(root.left)</div><div class="line">    deep(root.right)</div><div class="line">    <span class="keyword">print</span> root.data</div></pre></td></tr></table></figure>
<h2 id="单链表逆置"><a href="#单链表逆置" class="headerlink" title="单链表逆置"></a>单链表逆置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data=None, next=None)</span>:</span></div><div class="line">        self.data = data</div><div class="line">        self.next = next</div><div class="line"></div><div class="line">link = Node(<span class="number">1</span>, Node(<span class="number">2</span>, Node(<span class="number">3</span>, Node(<span class="number">4</span>, Node(<span class="number">5</span>, Node(<span class="number">6</span>, Node(<span class="number">7</span>, Node(<span class="number">8</span>, Node(<span class="number">9</span>)))))))))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rev</span><span class="params">(link)</span>:</span></div><div class="line">    pre = link</div><div class="line">    cur = link.next</div><div class="line">    pre.next = <span class="keyword">None</span></div><div class="line">    <span class="keyword">while</span> cur:</div><div class="line">        tmp = cur.next</div><div class="line">        cur.next = pre</div><div class="line">        pre = cur</div><div class="line">        cur = tmp</div><div class="line">    <span class="keyword">return</span> pre</div><div class="line"></div><div class="line">root = rev(link)</div><div class="line"><span class="keyword">while</span> root:</div><div class="line">    <span class="keyword">print</span> root.data</div><div class="line">    root = root.next</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/19/python-metaclass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/19/python-metaclass/" itemprop="url">Python Metaclass</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-19T22:55:30+08:00">
                2016-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是<a href="http://stackoverflow.com/users/9951/e-satis" target="_blank" rel="external">e-satis同学</a>在stackoverflow上的<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/6581949#6581949" target="_blank" rel="external">回答</a></p>
<h2 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h2><p>在理解<code>metaclass</code>之前（<code>metaclass</code>也被称为<code>元类</code>，这里就不翻译了），你要先掌握python中的class。python中class的概念非常奇特（一切皆对象），这一点借鉴了<code>Smalltalk</code>这门语言。</p>
<p>在大部分语言中，class只是用来描述如何产生一个object（翻译成<code>对象</code>，这里也不翻译了）的代码段。这在python中也成立：<br>In most languages, classes are just pieces of code that describe how to produce an object. That’s kinda true in Python too:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_object)</div><div class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8974f2c</span>&gt;</div></pre></td></tr></table></figure>
<p>但是Python中的class不止如此。class也是object。</p>
<p>对，类也是对象</p>
<p>只要你使用了class关键字，Python就会创建一个object。下面的代码段在内存中创建了一个名为<code>ObjectCreator</code>的object：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      <span class="keyword">pass</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个object（这个class）本身就具有创建object的能力，这就是为什么它是一个类。</p>
<p>但是，它同时也是一个object，所以你可以：</p>
<ul>
<li>将它赋值给一个变量</li>
<li>复制它</li>
<li>给它添加属性</li>
<li>将它作为函数参数进行传递</li>
</ul>
<p>e.g.:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator) <span class="comment"># you can print a class because it's an object</span></div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></div><div class="line"><span class="class">&gt;&gt;&gt; <span class="title">def</span> <span class="title">echo</span><span class="params">(o)</span>:</span></div><div class="line"><span class="meta">... </span>      print(o)</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>echo(ObjectCreator) <span class="comment"># you can pass a class as a parameter</span></div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></div><div class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(hasattr<span class="params">(ObjectCreator, <span class="string">'new_attribute'</span>)</span>)</span></span></div><div class="line"><span class="class"><span class="title">False</span></span></div><div class="line">&gt;&gt;&gt; ObjectCreator.new_attribute = 'foo' # you can add attributes to a class</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class="string">'new_attribute'</span>))</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator.new_attribute)</div><div class="line">foo</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class="comment"># you can assign a class to a variable</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror.new_attribute)</div><div class="line">foo</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror())</div><div class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8997b4c</span>&gt;</div></pre></td></tr></table></figure>
<h2 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h2><p>因为类即是对象，所以你可以动态地创建它们，就像创建一个普通的object。</p>
<p>首先，你可以在一个函数中用class关键字来创建一个类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span><span class="params">(name)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> name == <span class="string">'foo'</span>:</div><div class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>            <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> Foo <span class="comment"># return the class, not an instance</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>            <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> Bar</div><div class="line"><span class="meta">... </span>    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass = choose_class(<span class="string">'foo'</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyClass) <span class="comment"># the function returns a class, not an instance</span></div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></div><div class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(MyClass<span class="params">()</span>)</span> # <span class="title">you</span> <span class="title">can</span> <span class="title">create</span> <span class="title">an</span> <span class="title">object</span> <span class="title">from</span> <span class="title">this</span> <span class="title">class</span></span></div><div class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">Foo</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x89c6d4c</span>&gt;</span></div></pre></td></tr></table></figure>
<p>但是这还不够动态，因为你还是需要自己写整个类。</p>
<p>因为类即是对象，它们一定是由什么东西生成的。</p>
<p>当你使用class关键字，Python会自动创建这个对象。但是就像Python中其他东西一样，Python总会给你提供一种方法来手动操作它。</p>
<p>还记得type函数吗？这个古老而强大的函数可以告诉我们一个对象的类型是什么：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="number">1</span>))</div><div class="line">&lt;type <span class="string">'int'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="string">"1"</span>))</div><div class="line">&lt;type <span class="string">'str'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator))</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator()))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>well，type还有一个截然不同的能力，它也能动态创建类。type可以接受一个类的描述作为参数，然后返回一个类。(我知道，同一个函数因为传入的参数不同而表现出完全不同的用法是很傻的。但是这是Python为了保持向后兼容)</p>
<p><code>type</code>这样工作：</p>
<pre><code>type(name of the class, 
     tuple of the parent class (for inheritance, can be empty), 
     dictionary containing attributes names and values)
</code></pre><p>e.g.:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyShinyClass</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      <span class="keyword">pass</span></div><div class="line">can be created manually this way:</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>MyShinyClass = type(<span class="string">'MyShinyClass'</span>, (), &#123;&#125;) <span class="comment"># returns a class object</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyShinyClass)</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">MyShinyClass</span>'&gt;</span></div><div class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(MyShinyClass<span class="params">()</span>)</span> # <span class="title">create</span> <span class="title">an</span> <span class="title">instance</span> <span class="title">with</span> <span class="title">the</span> <span class="title">class</span></span></div><div class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">MyShinyClass</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x8997cec</span>&gt;</span></div></pre></td></tr></table></figure>
<p>你可能注意到我们用<code>MyShinyClass</code>作为了类的名字，也用它来作为变量接受类的引用。我们可以给他们取不同的名字，但是没有必要将事情复杂化。</p>
<p><code>type</code>接受一个字典来定义类的属性，所以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      bar = <span class="keyword">True</span></div><div class="line">Can be translated to:</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = type(<span class="string">'Foo'</span>, (), &#123;<span class="string">'bar'</span>:<span class="keyword">True</span>&#125;)</div><div class="line">And used <span class="keyword">as</span> a normal <span class="class"><span class="keyword">class</span>:</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(Foo)</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></div><div class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(Foo.bar)</span></span></div><div class="line"><span class="class"><span class="title">True</span></span></div><div class="line">&gt;&gt;&gt; f = Foo()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(f)</div><div class="line">&lt;__main__.Foo object at <span class="number">0x8a9b84c</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.bar)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>并且，可以继承它:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>  <span class="class"><span class="keyword">class</span> <span class="title">FooChild</span><span class="params">(Foo)</span>:</span></div><div class="line">             <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>这个也可以写作为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(FooChild)</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">FooChild</span>'&gt;</span></div><div class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(FooChild.bar)</span> # <span class="title">bar</span> <span class="title">is</span> <span class="title">inherited</span> <span class="title">from</span> <span class="title">Foo</span></span></div><div class="line"><span class="class"><span class="title">True</span></span></div></pre></td></tr></table></figure>
<p>最终你可能会希望为你的类增加方法。只需要定义一个有恰当签名的函数并且作为属性赋值就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>      print(self.bar)</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;<span class="string">'echo_bar'</span>: echo_bar&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(Foo, <span class="string">'echo_bar'</span>)</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar'</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo = FooChild()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo.echo_bar()</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>动态创建了类之后，你能够给类添加更多的方法，就跟给一个正常创建的对象添加方法一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar_more</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>      print(<span class="string">'yet another method'</span>)</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild.echo_bar_more = echo_bar_more</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar_more'</span>)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>可以看到：在Python中，类是对象，你可以动态创建类。这些就是当你使用<code>class</code>关键字的时候，Python在幕后做的事。而这些，都是通过metaclass来实现。</p>
<h2 id="什么是metaclass-终于开始了"><a href="#什么是metaclass-终于开始了" class="headerlink" title="什么是metaclass(终于开始了)"></a>什么是<code>metaclass</code>(终于开始了)</h2><p>metaclass是创建class的“东西”。</p>
<p>你定义class是为了创建对象是吧？但是我们也知道Python中的类也是对象。</p>
<p>well，metaclass就是用来创建这些对象（类）的。它们是class的class，你可以理解为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyClass = MetaClass()</div><div class="line">MyObject = MyClass()</div></pre></td></tr></table></figure>
<p>你已经看到了<code>type</code>让你可以这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyClass = type(<span class="string">'MyClass'</span>, (), &#123;&#125;)</div></pre></td></tr></table></figure>
<p>这是因为<code>type</code>方法本质上就是一个metaclass。type是Python在背后用来创建所有类的metaclass。</p>
<p>现在你可能想搞清楚为什么<code>type</code>要全部用小写字母，而不是写成<code>Type</code>?</p>
<p>我想这是为了要和str、int保持一致。type只是用来创建类对象的类。你可以通过查看<code>__class__</code>属性来验证这一点。在Python中，一切，所有一切都是对象。包括整数，字符串，函数和类，它们都是对象。并且它们都是从一个类创建而来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">35</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__</div><div class="line">&lt;type <span class="string">'int'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'bob'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__</div><div class="line">&lt;type <span class="string">'str'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__</div><div class="line">&lt;type <span class="string">'function'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = Bar()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Bar</span>'&gt;</span></div><div class="line">Now, what is the __class__ of any __class__ ?</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div></pre></td></tr></table></figure>
<p>所以，一个metaclass仅仅是创建类对象的东西。如果你愿意，你可以称呼它为<code>类工厂</code>。</p>
<p><code>type</code>是Python使用的内置的metaclass，当然，你也可以创建自己的metaclass。</p>
<h2 id="metaclass属性"><a href="#metaclass属性" class="headerlink" title="metaclass属性"></a><strong>metaclass</strong>属性</h2><p>当你定义一个类的时候，你可以添加一个<code>__metaclass__</code>属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">  __metaclass__ = something...</div><div class="line">  [...]</div></pre></td></tr></table></figure>
<p>如果你这样做了，Python将会使用这个metaclass去创建Foo类。</p>
<p>注意了，这里面有一些技巧。</p>
<p>你首先写下了<code>class Foo(object)</code>，但是这个时候类对象Foo还没有被在内存中创建。</p>
<p>Python将会在类的定义中寻找<code>__metaclass__</code>属性。如果找到了，Python就会用它来创建类对象Foo。如果没有，那它就用<code>type</code>来创建这个类。</p>
<p>请把上面一段多读几遍。</p>
<p>当你写下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(Bar)</span>:</span></div><div class="line">  <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>Python做了下面的工作：</p>
<p>Foo中有<code>__metaclass__</code>属性吗？</p>
<p>如果有，使用<code>__metaclass__</code>的值在内存中创建一个类对象（我说的是类对象，请紧跟我的思路），取名为Foo。</p>
<p>如果Python找不到<code>__metaclass__</code>，他会在MODULE层面继续找<code>__metaclass__</code>（所谓MODULE层面，可以理解我类定义的文件内，把这个文件看成一个MODULE），并且做和前面相同的操作（但这只适用于没有继承的类，也就是旧式类）。</p>
<p>如果仍未找到<code>__metaclass__</code>，它会用Bar（第一父类）的metaclass（可能是默认的<code>type</code>）来创建类对象。</p>
<p>Be careful here that the <code>__metaclass__</code> attribute will not be inherited, the metaclass of the parent (<code>Bar.__class__</code>) will be. If <code>Bar</code> used a <code>__metaclass__</code> attribute that created <code>Bar</code> with <code>type()</code> (and not <code>type.__new__()</code>), the subclasses will not inherit that behavior.</p>
<p>现在最大的问题是，你能给<code>__metaclass__</code>赋什么值？</p>
<p>答案是：可以创建一个类的值。</p>
<p>那什么可以创建一个类呢？<code>type</code>或者它的子类，或者任意用到了它的东西。</p>
<h2 id="自定义-metaclass"><a href="#自定义-metaclass" class="headerlink" title="自定义 metaclass"></a>自定义 metaclass</h2><p>metaclass的主要目的就是在类创建的时候，动态地修改它。</p>
<p>通常你会为API做这些工作，因为你想创建符合当前上下文的类。想象一个很傻的例子，你想让你的模块内所有的类的属性都大写。有好几种方法能达到这个需求，其中一种就是在MODULE层面设置<code>__metaclass__</code>。</p>
<p>通过这种方法，所有这个模块内的类都会用这个metaclass来创建，我们只需要告诉这个metaclass来将所有的属性都转换成大写。</p>
<p>幸运的是，<code>__metaclass__</code>可以是任意可调用的东西，它并不需要是一个普通的类（我知道，某些名字里带有‘class’的东西并不需要是一个class，请理解这一点，这很有帮助）。所以我们用一个函数作为一个简单的例子开始。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># the metaclass will automatically get passed the same argument</span></div><div class="line"><span class="comment"># that you usually pass to `type`</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span><span class="params">(future_class_name, future_class_parents, future_class_attr)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line"><span class="string">    Return a class object, with the list of its attribute turned </span></div><div class="line"><span class="string">    into uppercase.</span></div><div class="line"><span class="string">  """</span></div><div class="line"></div><div class="line">  <span class="comment"># pick up any attribute that doesn't start with '__' and uppercase it</span></div><div class="line">  uppercase_attr = &#123;&#125;</div><div class="line">  <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</div><div class="line">      <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">          uppercase_attr[name.upper()] = val</div><div class="line">      <span class="keyword">else</span>:</div><div class="line">          uppercase_attr[name] = val</div><div class="line"></div><div class="line">  <span class="comment"># let `type` do the class creation</span></div><div class="line">  <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</div><div class="line"></div><div class="line">__metaclass__ = upper_attr <span class="comment"># this will affect all classes in the module</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span> <span class="comment"># global __metaclass__ won't work with "object" though</span></div><div class="line">  <span class="comment"># but we can define __metaclass__ here instead to affect only this class</span></div><div class="line">  <span class="comment"># and this will work with "object" children</span></div><div class="line">  bar = <span class="string">'bip'</span></div><div class="line"></div><div class="line">print(hasattr(Foo, <span class="string">'bar'</span>))</div><div class="line"><span class="comment"># Out: False</span></div><div class="line">print(hasattr(Foo, <span class="string">'BAR'</span>))</div><div class="line"><span class="comment"># Out: True</span></div><div class="line"></div><div class="line">f = Foo()</div><div class="line">print(f.BAR)</div><div class="line"><span class="comment"># Out: 'bip'</span></div></pre></td></tr></table></figure>
<p>现在，我们用一个真正的类作为metaclass来做相同的事情：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># remember that `type` is actually a class like `str` and `int`</span></div><div class="line"><span class="comment"># so you can inherit from it</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </div><div class="line">    <span class="comment"># __new__ is the method called before __init__</span></div><div class="line">    <span class="comment"># it's the method that creates the object and returns it</span></div><div class="line">    <span class="comment"># while __init__ just initializes the object passed as parameter</span></div><div class="line">    <span class="comment"># you rarely use __new__, except when you want to control how the object</span></div><div class="line">    <span class="comment"># is created.</span></div><div class="line">    <span class="comment"># here the created object is the class, and we want to customize it</span></div><div class="line">    <span class="comment"># so we override __new__</span></div><div class="line">    <span class="comment"># you can do some stuff in __init__ too if you wish</span></div><div class="line">    <span class="comment"># some advanced use involves overriding __call__ as well, but we won't</span></div><div class="line">    <span class="comment"># see this</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name, </span></span></div><div class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr)</span>:</span></div><div class="line"></div><div class="line">        uppercase_attr = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">                uppercase_attr[name.upper()] = val</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                uppercase_attr[name] = val</div><div class="line"></div><div class="line">        <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</div></pre></td></tr></table></figure>
<p>但是，这种写法并不<code>OOP</code>（<code>Object-oriented programming</code>，面向对象编程）,我们直接调用了<code>type</code>，并且我们没有覆盖或者调用父类的<code>__new__</code>方法，让我们这么做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name, </span></span></div><div class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr)</span>:</span></div><div class="line"></div><div class="line">        uppercase_attr = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">                uppercase_attr[name.upper()] = val</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                uppercase_attr[name] = val</div><div class="line"></div><div class="line">        <span class="comment"># reuse the type.__new__ method</span></div><div class="line">        <span class="comment"># this is basic OOP, nothing magic in there</span></div><div class="line">        <span class="keyword">return</span> type.__new__(upperattr_metaclass, future_class_name, </div><div class="line">                            future_class_parents, uppercase_attr)</div></pre></td></tr></table></figure>
<p>你可能已经注意到了有个额外的参数<code>upperattr_metaclass</code>，这并没有什么特别的。<code>__new__</code>方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。</p>
<p>当然了，为了清晰起见，这里的名字我起的比较长。但是就像self一样，所有的参数都有它们约定俗成的名称。因此，在真实的产品代码中一个元类应该是像这样的：                         </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, dct)</span>:</span></div><div class="line"></div><div class="line">        uppercase_attr = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">                uppercase_attr[name.upper()] = val</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                uppercase_attr[name] = val</div><div class="line"></div><div class="line">        <span class="keyword">return</span> type.__new__(cls, clsname, bases, uppercase_attr)</div></pre></td></tr></table></figure>
<p>我们还可以使用<code>super</code>让它更清晰一点，这会<code>ease inheritance</code>（因为你可以拥有metaclass，从metaclass继承，从type继承）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, dct)</span>:</span></div><div class="line"></div><div class="line">        uppercase_attr = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">                uppercase_attr[name.upper()] = val</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                uppercase_attr[name] = val</div><div class="line"></div><div class="line">        <span class="keyword">return</span> super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr)</div></pre></td></tr></table></figure>
<p>就是这样，除此之外，对于metaclass真的没什么可说的了。</p>
<p>使用了metaclass的代码看起来复杂的原因并不是因为metaclass本身，而是因为你通常会用metaclass做一些晦涩的事情，依赖于自省、控制继承，和像<code>__dict__</code>这样的变量等。</p>
<p>诚然，metaclass用来搞<code>黑魔法</code>非常合适，因而会搞出来复杂的东西。但是就metaclass本身而言，他们非常简单：</p>
<ul>
<li>拦截类的创建</li>
<li>修改这个类</li>
<li>返回被修改过的类</li>
</ul>
<h2 id="为什么要用metaclass而不是函数？"><a href="#为什么要用metaclass而不是函数？" class="headerlink" title="为什么要用metaclass而不是函数？"></a>为什么要用metaclass而不是函数？</h2><p>既然metaclass可以接受任意可调用的对象，那为什么我们还要用一个类来给它赋值，这样不是明显更复杂吗？</p>
<p>这样做有下面几个理由：</p>
<ul>
<li>意图会更加明显。当你读到<code>UpperAttrMetaclass(type)</code>的时候，你知道接下来会发生什么。</li>
<li>你可以使用OOP，metaclass可以继承自别的metaclass，覆写父类的方法。metaclass甚至可以使用metaclass。</li>
<li>你可以将代码组织得更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。</li>
<li>你可以使用<code>__new__</code>, <code>__init__</code>以及<code>__call__</code>这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在<code>__new__</code>里处理掉，有些人还是觉得用<code>__init__</code>更舒服些。</li>
<li>这些类被称为metaclass，靠，这肯定意味这什么，我要小心！</li>
</ul>
<h2 id="究竟为什么要使用metaclass"><a href="#究竟为什么要使用metaclass" class="headerlink" title="究竟为什么要使用metaclass"></a>究竟为什么要使用metaclass</h2><p>下面回答我们最大的问题，为什么我们要使用这个晦涩难懂且容易出错的特性？</p>
<p>好吧，一般来说，你根本用不上它：</p>
<blockquote>
<p>“元就是深 度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。”  —— Python界的领袖 Tim Peters</p>
</blockquote>
<p>metaclass最多的应用场景是创建API。一个典型的例子是Django的ORM系统。它允许你像下面一样定义一些东西：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></div><div class="line">  name = models.CharField(max_length=<span class="number">30</span>)</div><div class="line">  age = models.IntegerField()</div></pre></td></tr></table></figure>
<p>但是如果你这样做的话：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">guy = Person(name=<span class="string">'bob'</span>, age=<span class="string">'35'</span>)</div><div class="line">print(guy.age)</div></pre></td></tr></table></figure>
<p>它不会返回一个<code>IntegerField</code>对象，而是返回了一个整数，甚至可以从数据库里取出数据。</p>
<p>这个可能是因为<code>models.Model</code>定义了<code>__metaclass__</code>，它用了一些魔法来将你刚刚定义的简单的<code>Person</code>类转换成对数据库的一个复杂的hook。Django通过暴露一个使用metaclass的API让这些复杂的东西简化，通过这个API重新创建代码，在背后完成真正的工作。</p>
<p>##结语<br>首先，你要知道类其实是能够创建出类实例的对象。事实上，类本身也是实例，他们是metaclass的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>id(Foo)</div><div class="line"><span class="number">142630324</span></div></pre></td></tr></table></figure>
<p>在Python中，一切皆对象，它们不是类的实例就是metaclass的实例。</p>
<p><strong>除了<code>type</code></strong></p>
<p>type实际上是它自己的metaclass。在纯Python环境中这是不可能做到的（你不能创建一个类，metaclass是这个类自身），这是通过在实现层面通过一些手段做到的。</p>
<p>其次，metaclass很复杂。对于一些非常简单的类的更改，你并不需要使用metaclass。你可以用下面两个不同的技术来修改类</p>
<ul>
<li>monkey patching</li>
<li>class decorators</li>
</ul>
<p>当你需要动态修改类的时候，99%的情况下，你最好用上面两个方法。当然了，其实在99%的情况下，你根本不需要修改类:D</p>
<p>##The Metaclass Hook in Python 3</p>
<p><a href="http://python-3-patterns-idioms-test.readthedocs.io/en/latest/Metaprogramming.html#the-metaclass-hook-in-python-3" target="_blank" rel="external">metaclass在python3中语法有了变化</a></p>
<p>Python3改变了metaclass的语法。你仍然可以定义<code>__metaclass</code>属性，但是Python会忽略它。取而代之的是，你可以在基类列表中使用一个关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple1</span><span class="params">(object, metaclass = SimpleMeta1)</span>:</span></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>这意味着在Python3中，直接将<code>__metaclass__</code>定义成一个类或者一个方法都不再可行。所有的metaclass都必须被定义成单独的类。这种方法也有好处，它让metaclass更具有一致性，当然也更易读和理解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">165</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="michaelseu2011@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
