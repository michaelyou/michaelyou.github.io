<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Youmai の Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/08/Django-优化数据库查询/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/08/Django-优化数据库查询/" itemprop="url">Django-优化数据库查询</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-08T21:09:31+08:00">
                2015-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##一次检索你需要的所有东西</p>
<p>在不同的位置多次访问数据库，一次获取一个数据集，通常来说不如在一次查询中获取它们更高效。如果你在一个循环中执行查询，这尤其重要。有可能你会做很多次数据库查询，但只需要一次就够了。</p>
<p>我们需要充分了解并使用<code>select_related()</code>和<code>prefetch_related()</code></p>
<p>###select_related()<br>Returns a QuerySet that will <code>“follow”</code> foreign-key relationships, selecting additional related-object data when it executes its query. This is a performance booster which results in a single more complex query but means later use of foreign-key relationships won’t require database queries.</p>
<p>The following examples illustrate the difference between plain lookups and select_related() lookups. Here’s standard lookup:</p>
<pre><code># Hits the database.
e = Entry.objects.get(id=5)

# Hits the database again to get the related Blog object.
b = e.blog
</code></pre><p>And here’s select_related lookup:</p>
<pre><code># Hits the database.
e = Entry.objects.select_related(&apos;blog&apos;).get(id=5)

# Doesn&apos;t hit the database, because e.blog has been prepopulated
# in the previous query.
b = e.blog
</code></pre><p>You can use <code>select_related()</code> with any queryset of objects:</p>
<pre><code>from django.utils import timezone

# Find all the blogs with entries scheduled to be published in the future.
blogs = set()

for e in Entry.objects.filter(pub_date__gt=timezone.now()).select_related(&apos;blog&apos;):
    # Without select_related(), this would make a database query for each
    # loop iteration in order to fetch the related blog for each entry.
    blogs.add(e.blog)
</code></pre><p>The order of <code>filter()</code> and <code>select_related()</code> chaining isn’t important. These querysets are equivalent:</p>
<pre><code>Entry.objects.filter(pub_date__gt=timezone.now()).select_related(&apos;blog&apos;)
Entry.objects.select_related(&apos;blog&apos;).filter(pub_date__gt=timezone.now())
</code></pre><p>You can follow foreign keys in a similar way to querying them. If you have the following models:</p>
<pre><code>from django.db import models

class City(models.Model):
    # ...
    pass

class Person(models.Model):
    # ...
    hometown = models.ForeignKey(City)

class Book(models.Model):
    # ...
    author = models.ForeignKey(Person)
</code></pre><p>… then a call to <code>Book.objects.select_related(&#39;author__hometown&#39;).get(id=4)</code> will cache the related Person and the related City:</p>
<pre><code>b = Book.objects.select_related(&apos;author__hometown&apos;).get(id=4)
p = b.author         # Doesn&apos;t hit the database.
c = p.hometown       # Doesn&apos;t hit the database.

b = Book.objects.get(id=4) # No select_related() in this example.
p = b.author         # Hits the database.
c = p.hometown       # Hits the database.
</code></pre><p>###prefetch_related()<br>待补充</p>
<p>##不要查询你不需要的东西</p>
<p>###使用<code>QuerySet.values()</code>和<code>values_list()</code><br>当你仅仅想要一个带有值的字典或者列表，并不需要使用ORM模型对象时，可以适当使用<code>values()</code>。</p>
<p>###使用<code>QuerySet.count()</code><br>如果你想要获取大小，不要使用 <code>len(queryset)</code></p>
<p>###使用<code>QuerySet.exists()</code><br>如果你想要知道是否存在至少一个结果，不要使用<code>if queryset</code></p>
<p>###使用<code>QuerySet.update()</code>和<code>delete()</code><br>通过<code>QuerySet.update()</code>使用批量的SQL UPDATE语句，而不是获取大量对象，设置一些值再单独保存。与此相似，在可能的地方使用批量<code>deletes</code>。</p>
<p>但是要注意，这些批量的更新方法不会在单独的实例上面调用<code>save()</code>或者<code>delete()</code>方法，意思是任何你向这些方法添加的自定义行为都不会被执行，包括由普通数据库对象的信号驱动的任何方法。</p>
<p>###直接使用外键的值<br>如果你仅仅需要外键当中的一个值，要使用对象上你已经取得的外键的值，而不是获取整个关联对象再得到它的主键。例如，执行：</p>
<pre><code>entry.blog_id
</code></pre><p>而不是：</p>
<pre><code>entry.blog.id
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/23/Django-Interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/23/Django-Interview/" itemprop="url">Django Interview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-23T10:46:48+08:00">
                2015-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Django的Model的继承有几种形式，分别是什么？</p>
<p>###抽象继承：</p>
<p>顺便复习OOP思想，继承是面向对象的大前提。抽象类之所以被创建是用来被继承的；一个类如果包含任何一种抽象方法，那么它就是抽象类；抽象方法一定要在子类中被复写；在继承关系中，抽象类永远在树枝节点上，而且对于Python来说，已经没有这么多约束了。</p>
<p>回到Django的<code>Model</code>也一样，当我们需要某些公共方法字段时，就需要一个父类为其他子类服务，这个父类没有<code>manager</code>，Django也不为这个类创建表，这种继承的定义方法如下：</p>
<pre><code>class Animal(models.Model):
    name = models.CharField(max_length=50)
    age = models.PositiveIntegerField()

    # 下面这句决定了Animal是一个抽象类/Model
    class Meta:
        abstract = True


class Human(Animal):
    kind_hearted = models.BooleanField()
    sex = models.CharField(&apos;sex&apos;, choices=((&apos;m&apos;,&apos;male&apos;), (&apos;f&apos;, &apos;female&apos;)), max_length=1)
    #...
</code></pre><p>上例中，<code>Human</code>的子<code>model</code>中，自然包含了<code>name</code>和<code>age</code>的字段，但是Animal不能作为正常model使用，由于没有manager，所以也不能实例化、保存。在子类中，不可以建立与这个抽象父类中的相同的字段，Django表示对报错负责。</p>
<p>###正常的继承，多重继承，Joined映射<br>和抽象继承的主要区别是父类这时也可以拥有数据库表了，并且不在身为存储公共信息的抽象类了，父类也可以进行实例化，查询等操作了。</p>
<pre><code>class Country(models.Model):
    name = models.CharField(max_length=10)
    #...


class Province(Country):
    return = models.BooleanField()
    #...
</code></pre><p>###代理<br>即在子类中只能增加方法，而不能增加属性，在不影响父类数据存储的前提下，使子类继承父类，此时子类称为父类的<code>“代理”</code>。例如：</p>
<pre><code>from django.contrib.auth.models import User

class Person(User):
    # this makes a class proxy
    proxy = True

    def can_dance(self):
        return True


# both Yellow and Black can_dance :)
class Yellow(Person):
    hometown = models.CharField(max_length=30)


class Black(Person)
    tribe_name = models.CharField(max_length=100)
</code></pre><p>我们为<code>Person</code>类增加了一个方法，可以跳舞，并且保持了<code>User</code>的数据字段的不变。</p>
<p>##Django的Queryset是什么，objects是什么，objects在哪里可以定义</p>
<p><code>query + set</code>，已经能猜出大概，它对应着数据库中的若干条记录。</p>
<p>例如有一个叫做<code>Order</code>的模型，在project的根目录下进入shell进行操作：</p>
<pre><code>$python manage.py shell
&gt;&gt;&gt;from app.order.models import Order
&gt;&gt;&gt;type(Order.objects)
&lt;class &apos;django.db.models.models.manager.Manager&apos;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;order = Order.objects.all()
&gt;&gt;&gt;type(order)
&lt;class &apos;django.db.models.query.QuerySet&apos;&gt;
</code></pre><p>上述方法很常用，看继承关系去理解<code>Queryset</code>和<code>objets</code>。<code>objects</code>是每个<code>Model</code>默认的<code>manager</code>类，通过manager的方法(也可通过<code>QuerySet</code>的方法得到，当然<code>QuerySet</code>也来自于<code>manager</code>)，得到相应的<code>Queryset</code>，用以对数据库模型字段进行更多的操作。</p>
<p><code>objects(manager)</code>方法可以自定义添加，也可以直接赋值覆盖掉默认的管理方法。</p>
<p>试着添加一个新的管理器的步骤是这样，首先定义一个<code>manager</code>类继承自<code>models.Manager</code>，并在其中对self进行操作，如下：</p>
<pre><code># new manager
class OrderManager(models.Manager):
    def title_count(self, keyword):
        return self.filter(title__icontains=keyword).count()


class Order(models.Models):
    title = models.CharField(max_length=100)
    # ...
    #objects = models.Manager()
    objects = OrderManager()

    def __unicode__(self):
        return self.title
</code></pre><p>上述例子中我们把<code>OrderManager</code>赋值给了<code>objects</code>，替换了默认的管理器。</p>
<p><strong>tips</strong>:如果增加了新的管理器，且没有替换掉默认管理器，那么默认管理器需要显式的声明出来才可以使用。</p>
<p>##Django中查询queryset时什么情况下用Q?</p>
<p>在进行相对复杂的查询时，使用<code>django.db.models.Q</code>对象。</p>
<p>例如需要进行复合条件的查询的SQL语句如下：</p>
<pre><code>SELECT * FROM order WHERE id BETWEEN 20 ADN 100 AND(num &lt;= &apos;20&apos; or num &gt;= &apos;30&apos;);
</code></pre><p>使用Q就可以写成：</p>
<pre><code>from django.db.models import Q
from login.models import Order
#...
Order.objects.get(
Q(id &gt;= 20) &amp; (id &lt;= 100),
Q(num &lt;= 20) | (num &gt;= 30)
)
</code></pre><p>##Django中想验证表单提交是否格式正确需要用到Form中的哪个函数？</p>
<p><code>is_valid()</code>函数方法，用于检查表单提交是否正确。</p>
<p>##Django取消级联删除</p>
<p>这个文档写的比较清楚：</p>
<pre><code>user = models.ForeignKey(User, blank=True, null=True, on_delete=models.SET_NULL)
</code></pre><p>并且<code>SET_NULL</code>只有在<code>null</code>为<code>True</code>的时候，才可以使用。</p>
<p>##Django中如何在Model保存前做一定的固定操作，比如写一句日志？</p>
<p>关键词: <strong>信号</strong></p>
<p>利用<code>Django</code>的<code>Model</code>的<code>Signal Dispatcher</code>, 通过<code>django.db.models.signals.pre_save()</code>方法，在事件发生前，发射触发信号，这一切都被调度中的<code>receiver</code>方法深藏功与名的保存了。<br>信号的处理一般都写在<code>Model</code>中，举个例子：</p>
<pre><code>import logging
from django.db import models
from django.db.models.signals import pre_save
from django.dispatch import receiver

class Order(models.Model):
    # ...


logger = logging.getLogger(__name__)

@receiver(pre_save, sender=Order)
def pre_save_handler(sender, **kwargs):

    # 我们可以在Order这个Model保存之前尽情玩耍
    logger.debug(&quot;{},{}&quot;.format(sender, **kwargs))
    print &apos;fuck universe&apos;
</code></pre><p>这样应该就实现了题中的要求，类似的方法还有比如<code>pre_init</code>是在<code>Model</code>实例之前会触发，<code>post_init</code>在实例之后触发，同理就是<code>pre_save</code>和<code>post_save</code>了。</p>
<p>##Django中如何读取和保存session，整个session的运行机制是什么。</p>
<p>说到<code>session</code>的运行机制，就一定要先说一下<code>cookie</code>这一段信息。一般情况下<code>cookies</code>都是我们的浏览器生成的（显然可以人为修改），用于服务器对户进行筛选和维护，但是这个听上去很好吃的东西，能存的东西有点少而且容易被别人利用。这时候基于<code>cookies</code>的<code>session</code>的意义就比较明显了，在客户端的<code>cookies</code>中我们只保存<code>session id</code>，而将完整信息以加密信息的形式保存到服务器端，这样服务器可以根据<code>session id</code>相对安全的在数据库中查询用户的更细致的信息和状态。</p>
<p>在Django中<code>session</code>和<code>cookies</code>的操作方法一样，如下：</p>
<pre><code># 保存session
request.session[&apos;order_id&apos;] = order_id
# 删除session
del request.session[&apos;order_id&apos;]
# 读取session
session.get(&apos;order_id&apos;, False)
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/10/Django的F-表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/10/Django的F-表达式/" itemprop="url">Django的F()表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-10T23:00:20+08:00">
                2015-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>算是一些基本的高级用法吧，在Django文档的<a href="https://docs.djangoproject.com/en/1.7/ref/models/queries/" target="_blank" rel="external">Query-related classes</a>这一章中。主要讲了三个类，<code>F()</code>,<code>Q()</code>和<code>prefetch()</code>。我们下面讲一讲<code>F()</code>。</p>
<blockquote>
<p>class F()<br>F()是代表模型字段的值，也就是说对于一些特殊的字段的操作，我们不需要用python把数据先取到内存中，然后操作，在存储到db中了。</p>
</blockquote>
<p>##常见的使用场景</p>
<p>###字段加1(加减乘除运算)</p>
<p>例如我们有个统计点击量的字段，每次更新的操作其实就是把字段的值加1.</p>
<p>一般我们的做法是把这条记录取出来，把相应字段加+1，然后在save，类似下面的代码</p>
<pre><code># Tintin filed a news story!
reporter = Reporters.objects.get(name=&apos;Tintin&apos;)
reporter.stories_filed += 1
reporter.save()
</code></pre><p>当我们使用了<code>F()</code>之后呢？ 只需要一行代码</p>
<pre><code>Reporters.objects.filter(name=&apos;Tintin&apos;).update(stories_filed=F(&apos;stories_filed&apos;) + 1)
</code></pre><p>不仅代码量少了，而且这是直接在数据中操作，效率也变高了，特别是并发的情况，减少了多线程同时操作带来的隐患。 但是<strong>不支持字符串相加的操作</strong></p>
<p>###字段比较<br>例如一个合同有两个日期，一个叫做终止日期，一个叫做结束日期，现在要筛选出终止日期小于结束日期的合同。</p>
<pre><code>from django.db.models import F
from contracts.models import Contracts
contracts = Contracts.objects.filter(contract_stop_time__lt=F(&apos;end_time&apos;))
</code></pre><p>如果没有F对象，就没法直接使用rom来查询。</p>
<p>###补充–通过F()避免竞态条件</p>
<blockquote>
<p>Another useful benefit of <code>F()</code> is that having the database - rather than Python - update a field’s value avoids a race condition.</p>
<p>If two Python threads execute the code in the first example above, one thread could retrieve, increment, and save a field’s value after the other has retrieved it from the database. The value that the second thread saves will be based on the original value; the work of the first thread will simply be lost.</p>
<p>If the database is responsible for updating the field, the process is more robust: it will only ever update the field based on the value of the field in the database when the <code>save()</code> or <code>update()</code> is executed, rather than based on its value when the instance was retrieved.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/03/python-double-star-and-star/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/03/python-double-star-and-star/" itemprop="url">python (double star) and (star)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-03T19:43:55+08:00">
                2015-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这个东西我开始根本不知道该怎么搜，找了很久才在stackoverflow上得到了指点，如果你需要搜一些别的答案，可以尝试搜索(double star in python)， 下面是一个非常棒的回答。</p>
<p>原文<a href="http://stackoverflow.com/questions/2921847/what-does-the-star-operator-mean-in-python" target="_blank" rel="external">在此</a></p>
<p>The single star <code>*</code> unpacks the sequence/collection into positional arguments, so you can do this:</p>
<pre><code>def sum(a, b):
    return a + b

values = (1, 2)

s = sum(*values)
</code></pre><p>This will unpack the tuple so that it actually executes as:</p>
<pre><code>s = sum(1, 2)
</code></pre><p>The double star <code>**</code> does the same, only using a dictionary and thus named arguments:</p>
<pre><code>values = { &apos;a&apos;: 1, &apos;b&apos;: 2 }
s = sum(**values)
</code></pre><p>You can also combine:</p>
<pre><code>def sum(a, b, c, d):
    return a + b + c + d

values1 = (1, 2)
values2 = { &apos;c&apos;: 10, &apos;d&apos;: 15 }
s = sum(*values1, **values2)
</code></pre><p>will execute as:</p>
<pre><code>s = sum(1, 2, c=10, d=15)
</code></pre><p>Also see section <a href="http://docs.python.org/tutorial/controlflow.html#unpacking-argument-lists" target="_blank" rel="external">4.7.4 - Unpacking Argument Lists</a> of the Python documentation.</p>
<hr>
<p>Additionally you can define functions to take <code>*x</code> and <code>**y</code> arguments, this allows a function to accept any number of positional and/or named arguments that aren’t specifically named in the declaration.</p>
<p>Example:</p>
<pre><code>def sum(*values):
    s = 0
    for v in values:
        s = s + v
    return s

s = sum(1, 2, 3, 4, 5)
</code></pre><p>or with <code>**</code>:</p>
<pre><code>def get_a(**values):
    return values[&apos;a&apos;]

s = get_a(a=1, b=2)      # returns 1
</code></pre><p>this can allow you to specify a large number of optional parameters without having to declare them.</p>
<p>And again, you can combine:</p>
<pre><code>def sum(*values, **options):
    s = 0
    for i in values:
        s = s + i
    if &quot;neg&quot; in options:
        if options[&quot;neg&quot;]:
            s = -s
    return s

s = sum(1, 2, 3, 4, 5)            # returns 15
s = sum(1, 2, 3, 4, 5, neg=True)  # returns -15
s = sum(1, 2, 3, 4, 5, neg=False) # returns 15
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/28/上传文件到阿里云OSS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/28/上传文件到阿里云OSS/" itemprop="url">上传文件到阿里云OSS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-28T18:39:18+08:00">
                2015-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#上传文件到阿里云OSS<br><a href="https://docs.aliyun.com/?spm=5176.383663.9.4.phsH04#/pub/oss/sdk/python-sdk&amp;object" target="_blank" rel="external">阿里云oss python官方文档</a></p>
<p>##上传<br>上传文件到oss有两种方法：</p>
<ol>
<li><code>put_object_from_file</code></li>
<li><code>put_object_from_string</code><br>从名称就能看出，这两种方法传入的文件类型不同，第一种方法，传递给函数的第三个参数应该是一个文件路径，而第二个函数，传递的是一个字符串。</li>
</ol>
<p>第一种方法很容易理解和使用，问题在于第二种方法，我干嘛要写一个字符串到云端？</p>
<pre><code>from oss.oss_api import *
oss = OssAPI(endpoint, accessKeyId, accessKeySecret)
#直接上传字符串
res=oss.put_object_from_string(bucket,object,&quot;string content&quot;)
print &quot;%s\n%s&quot; % (res.status, res.read())
</code></pre><p>这是官方给出的例子，真的是仅仅示范一下，谁闲的蛋疼会这么用这个函数啊！</p>
<p>其实这个函数是用来传输IO文件的。</p>
<p>我们的程序不可能都从本地读取文件上传，更多的时候是从别的应用程序读到了一个文件，这个文件这时候是二进制形态，二进制也是一种字符串，所以可以通过这种方法传输。</p>
<p>比如网页向后台传输了一个照片，后台要把这个照片上传到oss。</p>
<pre><code>file = request.FILES.get(&apos;img&apos;)
res = oss.put_object_from_string(bucket, object, file.read())
</code></pre><p>这个函数取名取得不好，七牛实现相同功能使用的是<code>qiniu.io.put</code>，比较容易理解一些。</p>
<p>##文件验证<br>文件验证都是使用<code>md5</code>验证，也是两种方法：</p>
<ol>
<li>oss自带</li>
<li>自己验证</li>
</ol>
<p>oss自带的方法是：计算本地文件的<code>md5</code>值，上传文件的时候将此值放在<code>headers</code>中一起上传，剩下的就是阿里云的事了，上传结束后阿里云会计算云端文件的<code>md5</code>，如果与用户传递的<code>md5</code>不相同会返回错误，举例：</p>
<pre><code>header = {&apos;Conten-MD5&apos;: md5}
res=oss.put_object_from_file(bucket,object,&quot;test.txt&quot;,headers= header)
</code></pre><p>第二种方法完全需要我们自己来验证了，方法是，传完之后下载下来，计算下载下来的文件的<code>md5</code>，与原来的<code>md5</code>比较</p>
<p>这里存在一个问题，如果文件很大，那下载下来验证，花费的资源实在太多了，这是不允许的。</p>
<p>阿里云提供了另外一个方法，那就是<code>head_object</code>，通过<code>head_object</code>我们可以只获取<code>object</code>的头信息，阿里云会将云端文件的<code>md5</code>作为<code>etag</code>的<code>value</code>返回，我们通过读取<code>etag</code>就可以获取云端文件的<code>md5</code>.</p>
<pre><code>def check_aliyun_file(bucket, key, md5):
    res = oss.head_object(bucket, key)
    header = dict(check_file.getheaders())
    yun_md5 = header[&apos;etag&apos;].strip(&apos;&quot;&apos;).lower()
    return yun_md5 == md5
</code></pre><p>这里注意阿里云返回的MD5全部是是大写的，所以需要转换</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/22/Django-统计查询/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/22/Django-统计查询/" itemprop="url">Django-统计查询</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-22T19:24:08+08:00">
                2015-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##统计<br><a href="http://docs.oneele.com/django/topics/db/queries.html" target="_blank" rel="external">Django 数据库抽象 API</a> 描述了如何创建、检索、更新和删除独立的对象。但是，有时你会需要处理一些有关对象的集合的统计。本文描述如何使用 Django 查询来处理统计。<br>本文我们将使用以下模型。这些模型用于在线书店图书清单：</p>
<pre><code>class Author(models.Model):
   name = models.CharField(max_length=100)
   age = models.IntegerField()
   friends = models.ManyToManyField(&apos;self&apos;, blank=True)

class Publisher(models.Model):
   name = models.CharField(max_length=300)
   num_awards = models.IntegerField()

class Book(models.Model):
   isbn = models.CharField(max_length=9)
   name = models.CharField(max_length=300)
   pages = models.IntegerField()
   price = models.DecimalField(max_digits=10, decimal_places=2)
   rating = models.FloatField()
   authors = models.ManyToManyField(Author)
   publisher = models.ForeignKey(Publisher)
   pubdate = models.DateField()

class Store(models.Model):
   name = models.CharField(max_length=300)
   books = models.ManyToManyField(Book)
</code></pre><p>##生成整个查询集的统计<br>Django 提供两种方法来产生统计。第一种方法是产生整个 查询集 的统计。假设我们要统计所有书的平均价格。 Djnago 中查询所有书的语句为:</p>
<pre><code>&gt;&gt;&gt; Book.objects.all()
</code></pre><p>在这个语句后加上一个 <code>aggregate()</code> 子句就行了:</p>
<pre><code>&gt;&gt;&gt; from django.db.models import Avg
&gt;&gt;&gt; Book.objects.all().aggregate(Avg(&apos;price&apos;))
{&apos;price__avg&apos;: 34.35}
</code></pre><p>上例中的 <code>all()</code> 是多余的。所以可以简写为:</p>
<pre><code>&gt;&gt;&gt; Book.objects.aggregate(Avg(&apos;price&apos;))
{&apos;price__avg&apos;: 34.35}
</code></pre><p><code>aggregate()</code>子句的参数代表我们要统计的内容，本例中我们要统计 Book 模型中 <code>price</code> 字段的平均值。 查询集参考 中可以找到完整的统计函数列表。<br><code>aggregate()</code>是一个 查询集 的未端子句，调用后会返回一个由名称－值配对组成的字典。名称是指统计的名称，值就是统计的值。名称由字段名称加上函数名自动组成。如果你想手动指定统计名称，可以象下例在统计子句中定义:</p>
<pre><code>&gt;&gt;&gt; Book.objects.aggregate(average_price=Avg(&apos;price&apos;))
{&apos;average_price&apos;: 34.35}
</code></pre><p>如果你想要生成多个统计，那么只要在统计子句后加上另外的统计子句就可以了。例如，如果要计算所有书价中最高价和最低价，可以这样写:</p>
<pre><code>&gt;&gt;&gt; from django.db.models import Avg, Max, Min, Count
&gt;&gt;&gt; Book.objects.aggregate(Avg(&apos;price&apos;), Max(&apos;price&apos;), Min(&apos;price&apos;))
{&apos;price__avg&apos;: 34.35, &apos;price__max&apos;: Decimal(&apos;81.20&apos;), &apos;price__min&apos;: Decimal(&apos;12.99&apos;)}
</code></pre><p>##生成查询集中每一个项目的统计<br>第二种方法是为 查询集 中每个独立的对象生成统计。例如，当你检索一个书单时，可能想知道每本书有几个作者。每本书与每个作者之间是一个多对多的关系，我们要为每本书总结这个关系。</p>
<p>要产生每个对象的统计可以使用 <code>annotate()</code> 子句。当定义一个 <code>annotate()</code> 子句后， 查询集 中的每个对象就可以与特定值关联，相当于每个对象有一个 “注释”。<br>这种注释的语法与 <code>aggregate()</code> 相同。 <code>annotate()</code> 的每个参数代表一个统计。例如，要计算每本书的作者人数:</p>
<pre><code># Build an annotated queryset
&gt;&gt;&gt; q = Book.objects.annotate(Count(&apos;authors&apos;))
# Interrogate the first object in the queryset
&gt;&gt;&gt; q[0]
&lt;Book: The Definitive Guide to Django&gt;
&gt;&gt;&gt; q[0].authors__count
2
# Interrogate the second object in the queryset
&gt;&gt;&gt; q[1]
&lt;Book: Practical Django Projects&gt;
&gt;&gt;&gt; q[1].authors__count
1
</code></pre><p>和 <code>aggregate()</code> 一样，统计的名称自动由字段名和函数名组成。你也可以在定义统计时指定名称:</p>
<pre><code>&gt;&gt;&gt; q = Book.objects.annotate(num_authors=Count(&apos;authors&apos;))
&gt;&gt;&gt; q[0].num_authors
2
&gt;&gt;&gt; q[1].num_authors
1
</code></pre><p>与 <code>aggregate()</code> 不同的是, <code>annotate()</code> 不是 一个未端子句。 <code>annotate()</code> 子句的输出是一个 查询集 。 这个 查询集 可以和其他查询集一样操作，包括 <code>filter()</code> 、 <code>order_by</code> 或者甚至再调用另一个 <code>annotate()</code> 。</p>
<p>##联合和统计<br>至此，我们统计的对象都是被查询的模块本身的字段。但是，有时我们要统计的是被查询模块的相关联的模块字段。<br>在统计函数中定义字段时，可以使用与过滤器中用于指定关联字段的 双下划线符号 。通过这种方法， Django 会自动使用联合来统计相关联的字段。</p>
<p>例如，要统计每个书店中书的价格范围:</p>
<pre><code>&gt;&gt;&gt; Store.objects.annotate(min_price=Min(&apos;books__price&apos;), max_price=Max(&apos;books__price&apos;))
</code></pre><p>上面的例子告诉 Django 检索 Store 模型，联合（通过多对多关系） Book 模型，并且统计 book 模型中的价格字段，计算最大值和最小值。<br><code>aggergate()</code> 子句适用同样规则。如果你想知道所有书店中书的最高价和最低价，可以这样:</p>
<pre><code>&gt;&gt;&gt; Store.objects.aggregate(min_price=Min(&apos;books__price&apos;), max_price=Max(&apos;books__price&apos;))
</code></pre><p>联合的深度是无限的。例如，要统计所有书的作者的最小年龄，你可以这样:</p>
<pre><code>&gt;&gt;&gt; Store.objects.aggregate(youngest_age=Min(&apos;books__authors__age&apos;))
</code></pre><p>##统计和其他查询子句</p>
<p>###<code>filter()</code> 和 <code>exclude()</code><br>在过滤器中也可以使用统计。任何用于一般模型的 <code>filter()</code> （或 <code>exclude()</code> ）也可与统计联用。</p>
<p>当与 <code>annotate()</code> 子句联用时，过滤器作用于被统计的对象上。例如要统计书名以 “Django” 开头的书:</p>
<pre><code>&gt;&gt;&gt; Book.objects.filter(name__startswith=&quot;Django&quot;).annotate(num_authors=Count(&apos;authors&apos;))
</code></pre><p>当与 <code>aggregate()</code> 子句联用时，过滤器作用于被统计的所有对象上。例如要统计书名以 “Django” 开头的书的平均价格:</p>
<pre><code>&gt;&gt;&gt; Book.objects.filter(name__startswith=&quot;Django&quot;).aggregate(Avg(&apos;price&apos;))
</code></pre><p>###过滤统计的值<br>统计出来的值也可以被过滤。和其他模型一样，统计的结果也可以使用 <code>filter()</code> 和 <code>exclude()</code> 子句来过滤。</p>
<p>例如，要产生一个由两个以上作者的书单可以这样:</p>
<pre><code>&gt;&gt;&gt; Book.objects.annotate(num_authors=Count(&apos;authors&apos;)).filter(num_authors__gt=1)
</code></pre><p>上例先进行统计，然后在统计的结果上使用了过滤器。</p>
<p>###<code>annotate()</code> 和 <code>filter()</code> 子句的顺序<br>当使用同时包含 <code>annotate()</code> 和 <code>filter()</code> 子句的复杂查询时，要特别小心两种子句的顺序。</p>
<p>当一个 <code>annotate()</code> 子句作用于查询时，该统计只对子句之前的查询起作用。也就是说 <code>filter()</code> 和 <code>annotate()</code> 顺序不同，查询就不同了。查询:</p>
<pre><code>&gt;&gt;&gt; Publisher.objects.annotate(num_books=Count(&apos;book&apos;)).filter(book__rating__gt=3.0)
</code></pre><p>和查询:</p>
<pre><code>&gt;&gt;&gt; Publisher.objects.filter(book__rating__gt=3.0).annotate(num_books=Count(&apos;book&apos;))
</code></pre><p>是不同的。两个查询都会返回至少有一本好书（评分大于 3.0 ）的出版商。但是，第一个查询中的统计会提供出版商的所有书的数量；第二个查询中的统计只返回好书的数量。第一个查询中统计先于过滤器，所以过滤器对统计没有作用。而第二个查询过滤器先于统计，所以统计的对象是已经过滤过的。</p>
<p>###order_by()<br>统计可以作为排序的基础。当你定义一个 <code>order_by</code> 子句时，可以引用 <code>annotate()</code> 子句中的统计。</p>
<p>例如，要依据书的作者人数进行排序，可以这样:</p>
<pre><code>&gt;&gt;&gt; Book.objects.annotate(num_authors=Count(&apos;authors&apos;)).order_by(&apos;num_authors&apos;)
</code></pre><p>###values()<br>通常,统计会针对 查询集 中每一个对象返回一个结果。但是，当使用 <code>values</code> 子句来约束要统计的列时，返回的结果会有所不同。原先统计结果中，统计字段的值相同的项会分组合并统计。<br>例如，要统计每个作者各自所写的书的平均评分:</p>
<pre><code>&gt;&gt;&gt; Author.objects.annotate(average_rating=Avg(&apos;book__rating&apos;))
</code></pre><p>返回的结果会包含每一个作者及其所写的书的平均计分。</p>
<p>但是，如果使用 <code>values()</code> 子句，返回的结果会有所不同:</p>
<pre><code>&gt;&gt;&gt; Author.objects.values(&apos;name&apos;).annotate(average_rating=Avg(&apos;book__rating&apos;))
</code></pre><p>这个例子中会把作者按名字分组统计，返回的结果中不会有重复的作者名字。名字相同的作者在统计中会作为同一个作者来统计，同名作者所写的书的评分会合并为一个作者的书来统计。</p>
<p>###<code>annotate()</code> 和 <code>values()</code> 子句的顺序<br>当使用 <code>filter()</code> 子句时， <code>annotate()</code> 和 <code>values()</code> 子句的顺序是非常重要的。如果 <code>values()</code> 子句先于 <code>annotate()</code> 子句，会按照前文所述的方式统计。</p>
<p>但是，如果 <code>annotate()</code> 子句先于 <code>values()</code> 子句，那么统计会作用于整个查询集，而 <code>values()</code> 子句只约束统计输出的字段。</p>
<p>例如，如果我们把前一个例子中的 <code>values()</code> 和 <code>annotate()</code> 子句调换顺序:</p>
<pre><code>&gt;&gt;&gt; Author.objects.annotate(average_rating=Avg(&apos;book__rating&apos;)).values(&apos;name&apos;, &apos;average_rating&apos;)
</code></pre><p>这个例子会为每一个作者生成唯一的结果。但是在输了的数据中只会包含作者名和 <code>average_rating</code> 的统计。</p>
<p>你可以注意到 <code>average_rating</code> 在例子中显示地定义了。在 <code>annotate()</code> 和 <code>values()</code> 子句的顺序处于这种情况是必须显式定义。</p>
<p>如果 <code>values()</code> 子句先于 <code>annotate()</code> 子句，那么任何统计会自动添加到输出结果中。但是 <code>values()</code> 子句在 <code>annotate()</code> 子句之后，那么必须显式定义统计列。</p>
<p>###缺省排序或 order_by() 子句的副作用<br>一个查询集中 <code>order_by()</code> 子句中的字段（或一个模型中缺省排序字段）会对输了数据产生影响，即使在 <code>values()</code> 中没有这些字段的定义时也同样会影响。这些特殊的字段会影响统计结果,这种情况在计数统计时尤为明显。</p>
<p>假设有一个这样的模型:</p>
<pre><code>class Item(models.Model):
    name = models.CharField(max_length=10)
    data = models.IntegerField()

    class Meta:
        ordering = [&quot;name&quot;]
</code></pre><p>这里的重点是作为缺省排序的 name 字段。如果你想要统计不重复的 data 值出现了多少次，你可能会使用如下语句:</p>
<pre><code># 警告：这个语句不完全正确！
Item.objects.values(&quot;data&quot;).annotate(Count(&quot;id&quot;))
</code></pre><p>…这个语句看似会根据 data 值分组统计 Item 对象的 id 。但统计结果中 name 字段也会参与其中，所以这个语句实际的是不重复的 <code>(data, name)</code> 配对，而这不是我们所要的结果，因此我们应当这样统计:</p>
<pre><code>Item.objects.values(&quot;data&quot;).annotate(Count(&quot;id&quot;)).order_by()
</code></pre><p>…这里我们通过一个空的<code>“ order_by() ”</code>来清除副作用。</p>
<p>这个行为与在查询集文档中 <code>distinct()</code> 提到的一样。通常的规则是：当你不想要额外的字段在统计结果中产生作用时，必须清空排序的内容或者至少确认 <code>values()</code> 子句中的字段已经限制了这些额外字段。</p>
<p>####Note<br>你可以会问为什么 Django 不去除这些字段的影响。主要的原因是为维护 <code>distinct()</code> 的一贯性和一个原则： Django 从不 删除你的排序定义（我们不会改变那么模型方法的行为，否则就会违背我们 <a href="http://docs.oneele.com/django/misc/api-stability.html" target="_blank" rel="external">API stability</a> 策略）。</p>
<p>###对小计进行统计<br>你可以对小计的结果进行统计。在查询中，你可以使用 <code>aggregate()</code> 子句来对 <code>annotate()</code>的结果进行统计。</p>
<p>例如，假设你要统计每本书的作者人数的平均值，那么首先要计算每本书的作者人数，然后根据这个结果来统计平均值:</p>
<pre><code>&gt;&gt;&gt; Book.objects.annotate(num_authors=Count(&apos;authors&apos;)).aggregate(Avg(&apos;num_authors&apos;))
{&apos;num_authors__avg&apos;: 1.66}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/19/python排序函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/19/python排序函数/" itemprop="url">python排序函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-19T21:38:15+08:00">
                2015-07-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##sort和sorted<br>相比于<code>sort</code>，<code>sorted()</code>的使用更为广泛</p>
<pre><code>sorted(iterable, cmp, key, reverse)
s.sort(cmp, key, reverse)
</code></pre><p><code>sorted</code>可以作用域任意迭代对象，而<code>sort()</code>一般作用于列表。</p>
<p><code>reverse = True</code>表示按照逆序排序</p>
<p>##sorted</p>
<p><code>sorted</code>排序的关键是传入<code>key</code>：</p>
<pre><code>In [35]: students = [(&apos;john&apos;, &apos;A&apos;, 15), (&apos;jane&apos;, &apos;B&apos;, 12), (&apos;dave&apos;, &apos;B&apos;, 10), (&apos;michael&apos;, &apos;A&apos;, 13), (&apos;mike&apos;, &apos;B&apos;, 12), (&apos;jessey&apos;, &apos;C&apos;, 15)]

In [36]: students = sorted(students, key=lambda result: result[2], reverse=True)
</code></pre><p>结果：</p>
<pre><code>In [37]: students
Out[37]:
[(&apos;john&apos;, &apos;A&apos;, 15),
 (&apos;jessey&apos;, &apos;C&apos;, 15),
 (&apos;michael&apos;, &apos;A&apos;, 13),
 (&apos;jane&apos;, &apos;B&apos;, 12),
 (&apos;mike&apos;, &apos;B&apos;, 12),
 (&apos;dave&apos;, &apos;B&apos;, 10)]
</code></pre><p>如果我们对排序有更高的要求，比如在本例中，在按年龄排序之后，我们还希望对年龄相同的同学按照等级进行排序。我们可以这样写<code>key</code></p>
<pre><code>In [38]: students = sorted(students, key=lambda result: (result[2], result[1]), reverse=True)

In [39]: students
Out[39]:
[(&apos;jessey&apos;, &apos;C&apos;, 15),
 (&apos;john&apos;, &apos;A&apos;, 15),
 (&apos;michael&apos;, &apos;A&apos;, 13),
 (&apos;jane&apos;, &apos;B&apos;, 12),
 (&apos;mike&apos;, &apos;B&apos;, 12),
 (&apos;dave&apos;, &apos;B&apos;, 10)]
</code></pre><p><a href="http://stackoverflow.com/questions/4233476/sort-a-list-by-multiple-attributes" target="_blank" rel="external">stackoverflow: Sort a list by multiple attributes?</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/30/HTML5与CSS3基础教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/30/HTML5与CSS3基础教程/" itemprop="url">《HTML5与CSS3基础教程》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-30T14:21:36+08:00">
                2015-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##HTML</p>
<ol>
<li>html文件的文件名全部使用小写字母，用短横线分割单词</li>
<li>a = anchor(锚)</li>
<li>每个浏览器都有一个内置的CSS文件，它决定了每个HTML元素的默认样式。你自己创建的CSS可以覆盖这些样式。</li>
<li>small元素表示的含义是法律声明等条文细则</li>
<li>header用于创建页眉，通常情况下，页眉包括网站标志，主导航和其他全站链接，甚至搜索框。只在必要时使用header。大多数情况下，如果h1~h6能满足要求，就没有必要用header将其包起来。</li>
<li>main是HTML5新添加的元素，包围着代表页面主题的内容，在一个页面里仅使用一次</li>
<li>article是HTML5新增元素。内容可以包含任意数量的元素。元素类型包括段落，列表，音频，视频，图像，图形等</li>
<li>aside是HTML5的新增元素。用于页面的附注栏。内容可以包含任意数量的元素。元素类型包括段落，列表，音频，视频，图，图形等。</li>
<li>HTML5中引入了大量新的标签，很多就是为了取代div。在HTML5中，div并没有消失，只是使用它的场合变少了。P55</li>
<li>cite元素用于标识对艺术作品，电影，图书等内容的引用</li>
<li>strong标记重要文本，em标记想要强调的文本</li>
<li>blockquote用于标记引述的文本 P70</li>
<li>abbr元素标记缩写词并解释其含义</li>
<li>dfn标记要定义的术语</li>
<li>sub创建下标，sup创建上标</li>
<li>del标记已删除内容(在内容上划线)</li>
<li>mark标记是荧光笔效果，用于突出显示文本</li>
<li>span –P88</li>
</ol>
<p>##表单</p>
<ol>
<li>表单中的每个控件都有一个name属性，用于提交表单时对数据进行识别</li>
<li>有的表单元素有内置的验证功能，有的网站使用javascript进行验证，这些都不能完全代替服务器端的验证，因为旧的浏览器或完全禁用javascript的浏览器不会执行客户端验证。</li>
<li>分隔表单元素可以使用p和div</li>
<li>为表单添加标签。label元素有一个特殊的属性：for。如果for的值域一个表单字段的id值相同，该label就与该字段显式地关联起来了。这对提升表单的可用性和可访问性都有帮助。–P330</li>
<li>单选按钮中的value属性的值，在该按钮被选中提交后，将会提交给服务器。</li>
<li>访问者输入的信息不发送到服务器就没什么用。应该总是为表单创建提交按钮，让访问者将信息交给你。submit–P343</li>
<li></li>
</ol>
<p>##CSS</p>
<ol>
<li>注释写在<code>/*  */</code>中</li>
<li>当你为某个元素应用CSS属性时，这些属性不仅会影响该元素，还会影响其下的分支元素。也就是说，这些下层的元素继承了其祖先元素的属性</li>
<li>哪些属性会被继承–P128</li>
<li>按类或ID选择元素， 类用<code>.</code>(点号)，ID用<code>#</code>(井号)</li>
<li>创建斜体：<code>font-style:italic</code>  –P176</li>
<li>应用粗体：<code>font-weight:bold</code> –P177</li>
<li>设置行高：<code>line-height:xxx</code></li>
</ol>
<p>##用CSS进行布局</p>
<ol>
<li>CSS让页面富有活力，但是首先我们应该知道，高校网页的核心是结构良好，语义化的HTML</li>
<li>盒模型–P211，209<ul>
<li>内容区域</li>
<li>内容区域周围的空间（内边距–padding）</li>
<li>内边距的外边缘（边框–border）</li>
<li>边框外面将元素与相邻元素隔开的不可见区域（外边距–margin）</li>
</ul>
</li>
<li>设置边框–P219</li>
<li>让文本环绕元素–设置浮动。分栏就是这么设计的</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/30/JavaScript-DOM编程艺术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/30/JavaScript-DOM编程艺术/" itemprop="url">《JavaScript DOM编程艺术》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-30T14:19:00+08:00">
                2015-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>javascript语言的另两个名字是ECMAScript和JScript，它们都是同一种语言，随便你怎么称呼它。</li>
</ol>
<ul>
<li>DOM = Document Object Model = 文档对象模型</li>
<li>在js中，在每条语句的后面加上一个<code>;</code>，是一种良好的编程习惯。</li>
<li>js允许程序员直接对变量赋值而无需事先声明，但是提前声明是一种良好的编程习惯</li>
<li>Javascript 的数组<code>Array</code>,既是一个<strong>数组</strong>，也是一个<strong>字典</strong><code>(Dictionary)</code></li>
<li>js支持<code>++</code>和<code>+=</code>操作符，python不支持<code>++</code></li>
<li>js支持三元操作符<code>a?b:c</code>, python不支持</li>
<li>在几乎所有浏览器里，用<code>Tab</code>键移动到某个链接然后按下回车键的动作也会触发<code>onclick</code>事件</li>
<li>HTML DOM提供了很多属性，可以让我们更方便地处理网页(P93).</li>
<li>把新创建的节点插入某个文档的节点树的最简单的方法是，让他成为这个文档某个现有节点的一个子节点</li>
<li>DOM提供了insertBefore方法，但是没有提供insertAfter方法。但我们可以自己编写insertAfter方法(P110).</li>
<li>到目前为止，各大搜索引擎网站的搜索机器人还几乎不支持javascript</li>
</ul>
<p>##变量作用域<br>如果在某个函数中使用了var，那个变量就会被视为一个全局变量，它只存在于这个函数的上下文中；反之，如果没有使用var，那个变量就会被视为一个全局变量，如果脚本里已经存在一个与之同名的全局变量，这个函数就会改变那个全局变量的值。</p>
<p>##js文档放在哪里最好<br>最好的做法是把<code>&lt;script&gt;</code>标签放在<code>HTML</code>文档的最后，<code>&lt;/body&gt;</code>标签之前，这样能使浏览器更快地加载页面。</p>
<p>##在页面加载完毕后执行函数<br>最佳的解决方法是编写<code>addLoadEvent</code>方法(P83)，这个函数将会把那些在页面加载完毕时执行的函数创建为一个队列。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/30/jQuery选择器中的空格/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/30/jQuery选择器中的空格/" itemprop="url">jQuery选择器中的空格</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-30T11:23:25+08:00">
                2015-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jQuery/" itemprop="url" rel="index">
                    <span itemprop="name">jQuery</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#jQuery选择器中的空格<br>来自–《锋利的jQuery》</p>
<p>选择器中的空格是不容忽视的，多一个空格或少一个空格也许得到的结果会截然不同的。下面来看一个例子。</p>
<p>HTML代码如下：</p>
<pre><code>&lt;div class=&quot;test&quot;&gt;
&lt;div style=&quot;display:none;&quot;&gt;Jquery教程&lt;/div&gt;
&lt;div style=&quot;display:none;&quot;&gt;Jquery学习&lt;/div&gt;
&lt;div style=&quot;display:none;&quot;&gt;Jquery插件&lt;/div&gt;
&lt;div class=&quot;test&quot; style=&quot;display:none;&quot;&gt;PHP学习&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;test&quot; style=&quot;display:none;&quot;&gt;Jquery插件教程&lt;/div&gt;
&lt;div class=&quot;test&quot; style=&quot;display:none;&quot;&gt;Jquery插件学习&lt;/div&gt;
</code></pre><p>使用如下jQuery代码获取它们：</p>
<pre><code>var $test_a = $(&quot;.test :hidden&quot;);//带空格的jQuery选择器
var $test_b = $(&quot;.test:hidden&quot;);//不带空格的jQuery选择器
var len_a = $test_a.length;
var len_b = $test_b.length;
alert(&quot;带空格的jQuery选择器选出的jQuery元素是：&quot;+len_a+&quot;个&quot;);//输出为4个
alert(&quot;不带空格的jQuery选择器选出的jQuery元素是：&quot;+len_b+&quot;个&quot;);//输出为3个
</code></pre><p>之所以会出现不同的结果，这就是后代选择器和过滤选择器的不同了</p>
<pre><code>var $test_a = $(&quot;.test :hidden&quot;);//带空格的jQuery选择器
</code></pre><p>上面这段代码是选取class为“test”的元素里面的隐藏元素。（后代选择器）</p>
<pre><code>var $test_b = $(&quot;.test:hidden&quot;);//不带空格的jQuery选择器
</code></pre><p>这上面的代码则是选取隐藏的class为“test”的元素</p>
<p>###<strong>注意</strong>:<br>有的选择器的用法，必须是空格，如果不带空格的话，那就取不到元素，比如：</p>
<pre><code>$(&quot;select:selected&quot;).length;//不管任何时候，这个选择器都取不到元素，这个length必然是0
$(&quot;select :selected&quot;);//这样才是正确的
</code></pre><p>有的选择器的用法，必须不带空格，如果带空格的话，那就取不到元素，比如：</p>
<pre><code>$(&quot;input :checked&quot;).length;//不管任何时候，这个选择器都取不到元素，这个length必然是0
$(&quot;input:checked&quot;);//这样才是正确的
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">206</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
