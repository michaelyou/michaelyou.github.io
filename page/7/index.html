<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/img/lufei.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/"/>





  <title>Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/16/一些pythonic代码的例子/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/16/一些pythonic代码的例子/" itemprop="url">一些pythonic代码的例子</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-16T20:53:22+08:00">
                2015-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##百分号的使用：<br>通常我们都是这样格式化字符串的:</p>
<pre><code>print &apos;hello world programme by %s&apos; % &apos;python&apos;  
</code></pre><p> 但是如果格式化的字符串中有很多%s,那么程序的可读性就会依靠于%后面 的变量名起得是否好了。</p>
<p>这个时候有一种用dict来格式化的%，我觉得很有用，尤其是在记log的 时候，作为log的格式，可读性非常高。<br>代码如下：</p>
<pre><code>#字符串  
value = {&apos;what&apos;: &apos;hello, world&apos;, &apos;language&apos;: &apos;python&apos;}  
print &apos;%(what)s, %(language)s&apos; % value  
#也可以包含int的  
value = {&apos;name&apos;: &apos;jianpx&apos;, &apos;age&apos;: 23}  
print &apos;%(name)s &apos;s age is  %(age)i&apos; % value
</code></pre><h2 id="用两个元素之间有对应关系的list构造一个dict："><a href="#用两个元素之间有对应关系的list构造一个dict：" class="headerlink" title="用两个元素之间有对应关系的list构造一个dict："></a>用两个元素之间有对应关系的list构造一个dict：</h2><p>运用zip可以非常简单的实现：</p>
<pre><code>names = [&apos;jianpx&apos;, &apos;yue&apos;]  
ages = [23, 40]  
m = dict(zip(names,ages))  
</code></pre><p> zip的使用可以help(zip)或者查看官方文档。</p>
<p>##交换两个值：<br>在其他语言可能要一个临时变量和三句话：</p>
<pre><code>temp = a
a = b
b = temp
</code></pre><p>但是在python，一句就ok了，而且不需要临时变量：</p>
<pre><code>a,b = b,a
</code></pre><p>右边的b,a 其实可以理解成一个tuple。</p>
<p>##数量多的字符串相连用join：<br>python字符串效率问题之一就是在连接字符串的时候使用‘+’号，例如 <code>s = &#39;s1&#39; + &#39;s2&#39; + &#39;s3&#39; + ...+&#39;sN&#39;</code>，总共将N个字符串连接起来，但是使用+号的话，python需要申请N-1次内存空间，然后进行字符串拷贝。原因是字符串对象<code>PyStringObject</code>在python当中是<strong>不可变对象</strong>，所以每当需要合并两个字符串的时候，就要重新申请一个新的内存空间（大小为两个字符串长度之和）来给这个合并之后的新字符串，然后进行拷贝。所以用+号效率非常低。建议在连接字符串的时候使用字符串本身的方法<code>join（list）</code>，这个方法能提高效率，原因是它只是申请了一次内存空间，因为它可以遍历list中的元素计算出总共需要申请的内存空间的大小，一次申请完。所以上面的例子可以写成<code>s = &#39;&#39;.join([&#39;s1&#39;,&#39;s2&#39;,....,&#39;sN&#39;])</code></p>
<p>例子是：</p>
<pre><code>#以前是这样写的  
fruits = [&apos;apple&apos;, &apos;banana&apos;]  
result = &apos;&apos;  
for f in fruits:  
    result += f  

#现在可以这样：  
fruits = [&apos;apple&apos;, &apos;banana&apos;]  
result = &apos;&apos;.join(fruits)  
</code></pre><p>##判断一个key是否在一个dict里面：<br>以前很经常犯的一个<strong>mistake</strong>是这样做：</p>
<pre><code>if key in dict_example:  
    do something  
</code></pre><p> 现在要这样写，就不用使用in操作了。</p>
<pre><code>if dict_example.has_key(key):  
    do something  
</code></pre><p>##去掉list中的重复元素：</p>
<pre><code>old_list = [1,1,1,3,4]  
new_list = list(set(old_list))  
</code></pre><p>##判断元素是否在列表中<br>如果对没有重复元素的列表对象，要判断某个元素是否在列表里面的话，当这个列表很大的时候，用set会比list<br>的性能要好，因为对于list，本身允许重复元素存在，所以它不是用hash实现的，但是set不一样，它不允许重复元素，看了python源代码，从set的实现源码setobject.c 中查找key的函数</p>
<pre><code>static setentry *
set_lookkey(PySetObject *so, PyObject *key, register long hash)    
</code></pre><p>的接口可以看出它真的使用hash去实现的。</p>
<p>所以对于in操作，set的实现是计算这个元素的hash值然后判断，理论上可以达到O(1)</p>
<p>##读文件操作：<br>    以前是这样写的：</p>
<pre><code>#默认文件存在，不处理Exception的情况  
f = open(&apos;filename&apos;, &apos;r&apos;)  
while 1:  
    line = f.readline()  
    if not line:  
        break  
    print line  

if f:  
    f.close()  
</code></pre><p>用with关键字可以这样简写了，</p>
<pre><code>from __future__ import with_statement  
with open(&apos;filename&apos;,&apos;r&apos;) as f:  
    for line in f:  
        print line  
</code></pre><p>具体关于with的可以参考<a href="http://jianpx.iteye.com/blog/505469" target="_blank" rel="external">这篇文章</a></p>
<p>##输出数组的index和值：<br>以前是要这样写的：</p>
<pre><code>l = [1,3,4]  
for i in xrange(len(l)):  
    print &apos;%d, %d&apos; % (i , l[i])  
</code></pre><p>现在可以用<strong>enumerate</strong>函数帮助你简写：</p>
<pre><code>l = [1,3, 4]  
for index, value in enumerate(l):  
    print &apos;%d, %d&apos; % (index, value)  
</code></pre><p>##关于使用map、filter、reduce的例子网上很多，这里不细说了，它们的使用也是pythonic的examples</p>
<p>##分隔一个字符串，去里面的元素<code>，</code>,但是空白字符串不要：<br>例如， names = ‘jianpx, yy, mm, , kk’</p>
<pre><code>names = &apos;jianpx, mm, yy, , kk&apos;  
name_list = names.split(&apos;,&apos;)  
result = []  
for name in name_list:  
    if name:  
        result.append(name)  
</code></pre><p>现在是这样写的：</p>
<pre><code>names = &apos;jianpx, yy, mm, , kk&apos;  
result = [name for name in names.split(&apos;,&apos;) if name.strip()]  
</code></pre><p>##模拟c语言中的  a?b:c<br>在python里面可以这样做：</p>
<pre><code>return_value = True if a == 1 else False  
</code></pre><p> 从而代替了这样的代码：</p>
<pre><code>if a == 1:  
    return_value = True  
else   
    return_value = False  
</code></pre><p>##用Decorator抽离公用代码或者解耦<br>例如要对一个函数做cache，对一个操作限制权限，如果需求随时可能变化，就是说有可能不需要做cache或者不需要做权限的时候，你如果把实现放到这些函数体里面，那么这时你必须把这些代码删除，而且要很小心。但是如果你用Decorator去做的话， 只要删除函数头顶上的@那一行就可以了。Django经常用这种方法做权限控制。<br>熟悉decorator的应该都很容易理解。</p>
<p>##如何将list的元素倒序并且生成到新的list呢？ </p>
<p>看到一个用list的slice做到的 :</p>
<pre><code>a = [1,2,3,4]  
c = &apos;abcdef&apos;  
aa= a[::-1]  
cc = c[::-1]  
</code></pre><p> 如果不用生成新的list，直接调用a.reverse()就得了。但是字符串类型没有reverse的方法.</p>
<p>关于list的slice特性， 其实也许很多人平时只是用list[start:end] 这样的， 这个意思是从start开始，每个元素都放到新的list里面， 直到end。但是其实还可以每隔N个元素才取一次的， 这种情况要3个参数:<code>·list[start:end:step]</code>，<code>step</code>就是间隔了。</p>
<p>##a = [i for i in xrange(5)]   和  a = (i for i in xrange(5)) </p>
<p>虽然看上去是一样都生成了5个元素，但是<br>前者是一个list对象， 如果遍历的话 <code>for item in a</code> 就会一下子返回全部元素然后再遍历， 而后者是个Generator，<br>用for item in a遍历是每次只是返回一个元素， 这样的好处是省内存（在list很大的情况下）。</p>
<p>##python的all函数可以简化逻辑表达式有很多”与“的时候的写法<br>比如：</p>
<pre><code>a, b, c = True, False, True
if a and b and c:
    return True
else:
    return False
可以简化成:
    return all([a, b, c])
</code></pre><p>由此可以看到all函数的作用是判断当且仅当参数里面都为真的时候返回真， 否则返回假。</p>
<p>但是这里更深入的话涉及all的判断顺序和传入的参数是list还是iterable对象是不同的。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/MTV-开发模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/MTV-开发模式/" itemprop="url">MTV 开发模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T20:15:05+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们来花点时间考虑下 Django 数据驱动 Web 应用的总体设计。</p>
<p>我们在前面章节提到过，Django 的设计鼓励松耦合及对应用程序中不同部分的严格分割。 遵循这个理念的话，要想修改应用的某部分而不影响其它部分就比较容易了。 在视图函数中，我们已经讨论了通过模板系统把业务逻辑和表现逻辑分隔开的重要性。 在数据库层中，我们对数据访问逻辑也应用了同样的理念。</p>
<p>把<code>数据存取逻辑</code>、<code>业务逻辑</code>和<code>表现逻辑</code>组合在一起的概念有时被称为软件架构的<code>Model-View-Controller (MVC)</code>模式。 在这个模式中， <code>Model</code> 代表数据存取层，<code>View</code>代表的是系统中选择显示什么和怎么显示的部分，<code>Controller</code> 指的是系统中根据用户输入并视需要访问模型，以决定使用哪个视图的那部分。</p>
<p>为什么用缩写？</p>
<p>像 MVC 这样的明确定义模式的主要用于改善开发人员之间的沟通。 比起告诉同事，“让我们采用抽象的数据存取方式，然后单独划分一层来显示数据，并且在中间加上一个控制它的层”，一个通用的说法会让你收益，你只需要说：“我们在这里使用MVC模式吧。”。</p>
<p>Django 紧紧地遵循这种 MVC 模式，可以称得上是一种 MVC 框架。 以下是 Django 中 M、V 和 C 各自的含义：</p>
<ul>
<li><p>M ，数据存取部分，由django数据库层处理，本章(第5章)要讲述的内容。</p>
</li>
<li><p>V ，选择显示哪些数据要显示以及怎样显示的部分，由视图和模板处理。</p>
</li>
<li><p>C ，根据用户输入委派视图的部分，由 Django 框架根据 URLconf 设置，对给定 URL 调用适当的 Python 函数。</p>
</li>
</ul>
<p>由于 C 由框架自行处理，而 Django 里更关注的是<strong>模型（Model）、模板(Template)和视图（Views）</strong>，Django 也被称为 <strong>MTV 框架</strong> 。在 MTV 开发模式中：</p>
<ul>
<li><p>M 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。</p>
</li>
<li><p>T 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。</p>
</li>
<li><p>V 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。</p>
</li>
</ul>
<p>如果你熟悉其它的 MVC Web开发框架，比方说 Ruby on Rails，你可能会认为 Django 视图是控制器，而 Django 模板是视图。 很不幸，这是对 MVC 不同诠释所引起的错误认识。 在 Django 对 MVC 的诠释中，视图用来描述要展现给用户的数据；不是数据 如何展现 ,而且展现 哪些 数据。 相比之下，Ruby on Rails 及一些同类框架提倡控制器负责决定向用户展现哪些数据，而视图则仅决定 如何 展现数据，而不是展现 哪些 数据。</p>
<p>两种诠释中没有哪个更加正确一些。 重要的是要理解底层概念。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/django-locals-技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/django-locals-技巧/" itemprop="url">django-locals()技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T19:54:43+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>思考一下我们对 current_datetime 的最后一次赋值:</p>
<pre><code>def current_datetime(request):
    now = datetime.datetime.now()
    return render_to_response(&apos;current_datetime.html&apos;, {&apos;current_date&apos;: now})
</code></pre><p>很多时候，就像在这个范例中那样，你发现自己一直在计算某个变量，保存结果到变量中（比如前面代码中的 now ），然后将这些变量发送给模板。 尤其喜欢偷懒的程序员应该注意到了，不断地为临时变量和临时模板命名有那么一点点多余。 不仅多余，而且需要额外的输入。</p>
<p>如果你是个喜欢偷懒的程序员并想让代码看起来更加简明，可以利用 Python 的内建函数 locals() 。它返回的字典对所有局部变量的名称与值进行映射。 因此，前面的视图可以重写成下面这个样子：</p>
<pre><code>def current_datetime(request):
    current_date = datetime.datetime.now()
    return render_to_response(&apos;current_datetime.html&apos;, locals())
</code></pre><p>在此，我们没有像之前那样手工指定 context 字典，而是传入了 locals() 的值，<strong>它囊括了函数执行到该时间点时所定义的一切变量</strong>。 因此，我们将 now 变量重命名为 current_date ，因为那才是模板所预期的变量名称。 在本例中， locals() 并没有带来多 大 的改进，但是如果有多个模板变量要界定而你又想偷懒，这种技术可以减少一些键盘输入。</p>
<p><strong>使用 locals() 时要注意是它将包括 所有 的局部变量，它们可能比你想让模板访问的要多。 在前例中， locals() 还包含了 request 。对此如何取舍取决你的应用程序。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/django载入模板的顺序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/django载入模板的顺序/" itemprop="url">Django载入模板的顺序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T19:43:01+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Django默认会在配置文件<code>setting.py</code>的<code>TEMPLATE_LOADERS</code>中开启<code>django.template.loaders.filesystem.Loader</code>，开启该选项后可以按照<code>TEMPLATE_DIRS</code>中列出的路径的先后顺序从中查找并载入模板。</p>
<p>比如有如下配置：</p>
<pre><code>TEMPLATE_LOADERS = (
    &apos;django.template.loaders.filesystem.Loader&apos;,
)
TEMPLATE_DIRS = (
    &apos;/var/www/site/mycitsm/mycitsm/templates&apos;,
    &apos;/var/www/site/mycitsm/sqlreview/templates&apos;,
)
</code></pre><p>现在<code>TEMPLATE_DIRS</code>中指定的两个目录中均存在<code>base.html</code>，渲染模板的语句为 <code>return render(request, &#39;base.html&#39;,context)</code>，<strong>那么Django会优先使用第一个目录中的<code>base.html</code>模板。当第一个目录中不存在<code>base.html</code>时，Django才会使用第二个目录中的base.html模板</strong>。当然，当两个目录都不存在<code>base.html</code>时，会提示找不到模板。因此为了避免混淆，在使用<code>&#39;django.template.loaders.filesystem.Loader&#39;</code>时尽量不要在<code>TEMPLATE_DIRS</code>指定的不同的位置放置同名模板。</p>
<p>如果确实想在不同的位置放置同名模板呢？比如，为了达到程序复用的目的，我们往往会创建一些某个Django APP特定的static文件和template文件，保存在该APP特定的目录中。而我们不能保证这些文件与其他位置的文件不发生重名。因此这里引入了另外一种模板载入模式<code>&#39;django.template.loaders.app_directories.Loader&#39;</code>，<strong>开启该选项后可以从INSTALLED_APPS中已安装app对应的templates/目录中查找要渲染的模板文件</strong>（对于静态文件对应的是app的static/目录）。</p>
<p>比如有如下配置：</p>
<pre><code>TEMPLATE_LOADERS = (
   &apos;django.template.loaders.app_directories.Loader&apos;，
)
TEMPLATE_DIRS = ()
</code></pre><p>这里我们没有在<code>TEMPLATE_DIRS</code> 中指定包含模板文件的路径信息，但由于我们使用的是 <code>&#39;django.template.loaders.app_directories.Loader&#39;</code>载入方式，<strong>他会自动从APP对应的templates目录中查找相应的模板文件</strong>。比如渲染语句为<code>return render(request, &#39;base.html&#39;,context)</code>，APP对应的模板目录为<code>/var/www/site/mycitsm/sqlreview/templates/</code>，只要该目录中存在<code>base.html</code>，Django就会渲染该模板，不存在则提示找不到，除此之外不会从其他地方找该模板文件了。</p>
<p>细心的你可能已经想到了：<strong>要是同时使用了两种载入模板的方式呢？比如同时使用了’django.template.loaders.filesystem.Loader’和’django.template.loaders.app_directories.Loader’会如何查找并载入模板？</strong></p>
<p>比如有如下配置：</p>
<pre><code>TEMPLATE_LOADERS = (
    &apos;django.template.loaders.filesystem.Loader&apos;,
    &apos;django.template.loaders.app_directories.Loader&apos;，
)
TEMPLATE_DIRS = (
    &apos;/var/www/site/mycitsm/mycitsm/templates&apos;,
    &apos;/var/www/site/mycitsm/sqlreview/templates&apos;,
)
</code></pre><p><code>TEMPLATE_DIRS</code>中指定的两个目录内均存在<code>base.html</code>模板，渲染模板的语句为 <code>return render(request, &#39;base.html&#39;,context)</code>，<strong>则Django会先依据<code>TEMPLATE_LOADERS</code>中最先列出的模板载入方式来查找并载入模板，方式同上，若找不到模板文件则使用列出的第二种方式查找，依次类推，直至找到或找不到。这样的话，Django要么找不到模板，要么会载入最先找到的模板，若在多个不同路径下存在同名的模板文件，最终载入的模板与列出的载入方式的顺序和列出的包含模板的目录的顺序嘻嘻相关。这往往是不明确的，极易造成混淆。</strong></p>
<p>因此，通常在APP各自的templates目录中保存APP特定的模板，并不直接在APP对应templates目录中直接存放模板文件本身，而是在该目录中在创建一层以APP名称命名的目录，比如APP名称为sqlreview则存放该APP模板的目录为…/sqlreview/templates/sqlreview/，在指定要渲染的模板时可以通过模板文件的上一层目录来限定模板文件，以避免混淆，这实际上是提供了一个命名空间。比如return render(request, ‘sqlreview/base.html’,context),可以在/var/www/site/mycitsm/sqlreview/templates目录中找到该模板。这样便不用担心Django载入的模板究竟是不是对的、需要的那个模板。</p>
<p>#django 1.8中的改变<br>在django 1.8中，setting里取消了<code>TEMPLATE_LOADERS</code>和<code>TEMPLATE_DIRS</code>设置，用一个<code>TEMPLATES</code>设置来代替</p>
<pre><code>TEMPLATES = [
    {
        &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;,
        &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;blog/templates&apos;),],
        &apos;APP_DIRS&apos;: True,
        &apos;OPTIONS&apos;: {
            &apos;context_processors&apos;: [
                &apos;django.template.context_processors.debug&apos;,
                &apos;django.template.context_processors.request&apos;,
                &apos;django.contrib.auth.context_processors.auth&apos;,
                &apos;django.contrib.messages.context_processors.messages&apos;,
            ],
        },
    },
]
</code></pre><p>其中’DIRS’字段的值是一个列表，用来代替<code>TEMPLATE_DIRS</code>，设置模板的路径</p>
<p><code>TEMPLATES</code>自带的loader是<code>&#39;django.template.loaders.filesystem.Loader&#39;</code>，如果我们想设置loader为<code>&#39;django.template.loaders.app_directories.Loader&#39;</code>，就将<code>APP_DIRS</code>的值设置为TRUE</p>
<p>##补充</p>
<p><code>&#39;django.template.loaders.filesystem.Loader&#39;</code>依赖于’DIRS’的设置，如果’DIRS’是一个空列表的话，他将找不到任何模板</p>
<p><code>&#39;django.template.loaders.app_directories.Loader&#39;</code>会自动去app下面的template目录下寻找模板，所以采用这种方法就无需给’DIRS’赋值</p>
<p>第一部分转载自<a href="http://blog.csdn.net/zyz511919766/article/details/18355827" target="_blank" rel="external">这里</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/django的时区/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/django的时区/" itemprop="url">Django的时区</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T17:20:07+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>视乎你的机器，显示的日期与时间可能和实际的相差几个小时。 这是因为Django是有时区意识的，并且默认时区为<code>America/Chicago</code>。 （它必须有个值，它的默认值是Django的诞生地：美国/芝加哥）如果你处在别的时区，你需要在settings.py文件中更改这个值。请参见它里面的注释，以获得最新世界时区列表。在中国我们设置为<code>Asia/Shanghai</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/13/scp不能拷贝符号链接/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/13/scp不能拷贝符号链接/" itemprop="url">scp不能拷贝符号链接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-13T09:42:34+08:00">
                2015-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天把一个web目录直接scp -r到另一台机器上，发现起不来，后来发现是在配置目录下的一些符号连接都没有拷贝过来。</p>
<p>如果要将这些符号连接拷贝过来，不能直接scp -r这个文件夹，<strong>需要先将文件夹打包，然后拷贝</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/08/python导入模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/08/python导入模块/" itemprop="url">python导入模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-08T09:45:36+08:00">
                2015-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#python导入模块</p>
<p>##使用from <strong> import </strong>不能节约内存</p>
<p>python导入模块和他们的属性有两种方法：</p>
<pre><code>import random
print random.choice(range(10))
</code></pre><p>和</p>
<pre><code>from random import choice
print choice(range(10))
</code></pre><p>第一种方法是将模块的名字设置为一个隐含的名字空间里的全局变量，这样你就可以好像访问全局属性那样访问choice函数。而在第二个例子里，我们是直接把choice引入到全局名字空间里来（而非模块的名字）。因此不再需要把这个属性当成是模块的成员了。实际上我们也只拥有了这个属性而已。</p>
<p><strong>Python新手之间经常有一种误解，以为第二种方法只导入了一个函数，而没有导入整个模块。这是不对的。整个模块其实已经被导入了，但是只有那个函数的引用被保存了起来。所以from-import这种语法并不能带来性能上的差异，也没有节省什么内存。</strong></p>
<p>##能不能重复导入一个模块</p>
<p>新手经常会担忧的一个问题是他们有两个模块m.py和n.py都导入了foo.py模块。当m导入n时，foo岂不是会被导入两次？简单的来说，没错，是这样的，但是和你想的有点不一样。</p>
<p>Python有<code>导入模块</code>（importing）和<code>加载模块</code>（loading）之分。一个模块可以被导入任意多次，但是它<strong>只会被加载一次</strong>。就是说，当Python碰到一个已经被加载的模块又被导入时，它会跳过加载的过程，所以你无需担心额外消耗内存的问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/03/28/i-的线程安全性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/28/i-的线程安全性/" itemprop="url">i++的线程安全性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-28T18:25:29+08:00">
                2015-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载自<a href="http://blog.csdn.net/sapair/archive/2009/06/05/4243974.aspx" target="_blank" rel="external">这里</a></p>
<p>i++的线程安全性可以总结如下：</p>
<ol>
<li>如果i是局部变量，那么是可重入的，也就是线程安全的。</li>
<li>如果i是全局变量，则同一进程的不同线程都可能访问到该变量，因而是线程不安全的。</li>
</ol>
<p>上面这两点比较清晰，具体原因我将在下面解释：</p>
<p>本质上来讲，i并不是因为是全局变量才说是线程不安全的。其实其本质原因是i++这个操作并不是原子的，如果这是原子操作的话，具有不可分特性，那么即便是所有线程都能访问到，也都是线程安全的。</p>
<p>i++最终被编译后的反汇编代码大概如下：</p>
<pre><code>mov eax，[xxxxxxxx]
inc   eax
</code></pre><p>一条c语句已经被分为两条操作指令，那么在这两条操作指令执行之间，可能由于中断而被调度到不同线程，于是，不安全性就产生了。当然了，这并不是说单条汇编语句就是线程安全的，这取决于CPU架构，因为单条汇编指令可能在多个CPU时钟周期内进行，有些CPU架构可以在任何一个时钟周期内响应中断，对于这样的CPU，就是单条指令都不是安全的。当然了，现在的CPU大部分都是一条指令执行完后才能响应中断的。想要进行原子操作，方法有很多种，其中一种比较简单的是在原子语句之间先关闭中断，然后进行原子操作后再打开中断就OK了。</p>
<p>##原子操作</p>
<p>所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程），不能被更高等级中断抢夺优先。</p>
<p>由于操作系统大部分时间处于开中断状态，所以，一个程序在执行的时候可能被优先级更高的线程中断。而有些操作是不能被中断的，不然会出现无法还原的后果，这时候，这些操作就需要原子操作。就是不能被中断的操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/03/27/malloc和free的实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/27/malloc和free的实现原理/" itemprop="url">malloc和free的实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-27T19:56:38+08:00">
                2015-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前写过一篇<a href="http://michaelyou.github.io/2015/03/20/%E4%B8%BA%E4%BB%80%E4%B9%88malloc%E6%97%B6%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9Asize%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84free%E6%97%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9Asize/" target="_blank" rel="external">为什么free函数不需要指定需要释放的内存大小</a>，这个问题算是解释清楚了，但是针对malloc的实现又不怎么记得了，抽空又把《深入理解计算机系统》相关段落看了一遍，真的是好书啊！浅显易懂，真是适合我。</p>
<hr>
<p>内存分配是按照<code>堆块</code>实现的，<strong>一个堆块是由头部和有效载荷量组成，其中的有效载荷量就是我们申请的堆的大小</strong>。<br>头部块包括 块大小和是否可用这两个部分组成。</p>
<p><strong>在内存中这些堆块以链表形式组成</strong></p>
<p>malloc函数的实质体现在：它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿<code>连接表</code>寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。</p>
<blockquote>
<p>这里注意，malloc找到的内存块大小一定是会大于等于我们需要的内存大小，下面会提到如果所有的内存块都比要求的小会怎么办？</p>
</blockquote>
<p>调用free函数时，它将用户释放的内存块连接到空闲链上。<strong><em>到最后，空闲链会被切成很多的小内存片段</em></strong>，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，<strong>将相邻的小空闲块合并成较大的内存块</strong>。</p>
<p>glibc维护了<code>不止一个</code>不定长的内存块链表，而是好几个，每一个这种链表负责一个大小范围，这种做法有效<strong>减少了分配大内存时的遍历开销</strong>，类似于<code>哈希</code>的方式，将很大的范围的数据散列到有限的几个小的范围内而不是所有数据都放在一起，虽然最终还是要在小的范围内查找，但是最起码省去了很多的开销，如果只有一个不定长链表那么就要全部遍历，如果分成3个，就省去了2/3的开销，总之这个策略十分类似于散列。</p>
<p>glibc另外的策略就是不止维护一类空闲链表，而是另外再维护一个缓冲链表和一个高速缓冲链表，在分配的时候首先在高速缓存中查找，失败之后再在空闲链表查找，如果找到的内存块比较大，那么将切割之后的剩余内存块插入到缓存链表，如果空闲链表查找失败那么就往缓存链表中查找. 如果还是没有合适的空闲块，就向内存申请比请求数更大的内存块，然后把剩下的内存放入链表中。</p>
<p>在对内存块进行了 free 调用之后，我们需要做的是诸如将它们标记为未被使用的等事情，并且，在调用 malloc 时，我们要能够定位未被使用的内存块。因此， <strong>malloc返回的每块内存的起始处首先要有这个结构</strong>：</p>
<p>这就解释了，为什么在程序中free之后，但是堆的内存还是没有释放。</p>
<pre><code>内存控制块结构定义
struct mem_control_block {
    int is_available;
    int size;
};
</code></pre><p>现在，您可能会认为当程序调用 malloc 时这会引发问题 —— 它们如何知道这个结构？答案是它们不必知道；在返回指针之前，我们会将其移动到这个结构之后，把它隐藏起来。这使得返回的指针指向没有用于任何其他用途的内存。那样，从调用程序的角度来看，它们所得到的全部是空闲的、开放的内存。然后，当通过 free() 将该指针传递回来时，<strong>我们只需要倒退几个内存字节就可以再次找到这个结构</strong>。</p>
<p>在讨论分配内存之前，我们将先讨论释放，因为它更简单。为了释放内存，我们必须要做的惟一一件事情就是，获得我们给出的指针，回退 sizeof(struct mem_control_block) 个字节，并将其标记为可用的。这里是对应的代码：</p>
<pre><code>解除分配函数
void free(void *firstbyte) {
        struct mem_control_block *mcb;
        /* Backup from the given pointer to find the
         * mem_control_block
         */
       mcb = firstbyte - sizeof(struct mem_control_block);
        /* Mark the block as being available */
          mcb-&gt;is_available = 1;
        /* That&apos;&apos;s It!  We&apos;&apos;re done. */
       return;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/03/25/fork和exec/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/25/fork和exec/" itemprop="url">fork和exec</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-25T21:06:20+08:00">
                2015-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##fork（）<br>一个程序调用fork函数。首先，系统让新的进程与旧的进程使用同一个代码段，因为它们的程序还是相同的，对于数据段和堆栈段，系统则复制一份给新的进程，这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。而如果两个进程要共享什么数据的话，就要使用另一套函数（shmget，shmat，shmdt等）来操作。现在，已经是两个进程了，对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零，这样，对于程序，只要判断fork函数的返回值，就知道自己是处于父进程还是子进程中。</p>
<p>事实上，目前大多数的unix系统在实现上并没有作真正的copy。一般的，CPU都是以“页”为单位分配空间的，象INTEL的CPU，其一页在通常情况下是4K字节大小，而无论是数据段还是堆栈段都是由许多“页”构成的，fork函数复制这两个段，只是“逻辑”上的，并非“物理”上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的“页”从物理上也分开。系统在空间上的开销就可以达到最小。 </p>
<p>##exec系列函数<br><strong>一个进程一旦调用exec类函数，它本身就“死亡”了</strong>，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。不过exec类函数中有的还允许继承环境变量之类的信息，这个通过exec系列函数中的一部分函数的参数可以得到。</p>
<p>##对于fork（）： </p>
<ol>
<li>子进程复制父进程的所有进程内存到其内存地址空间中。父、子进程的<br>“数据段”，“堆栈段”和“代码段”完全相同，即子进程中的每一个字节都<br>和父进程一样。 </li>
<li>子进程的当前工作目录、umask掩码值和父进程相同，fork（）之前父进程<br>打开的文件描述符，在子进程中同样打开，并且都指向相同的文件表项。 </li>
<li>子进程拥有自己的进程ID。</li>
</ol>
<p>##对于exec（）： </p>
<ol>
<li>进程调用exec（）后，将在同一块进程内存里用一个新程序来代替调用<br>exec（）的那个进程，新程序代替当前进程映像，当前进程的“数据段”，<br>“堆栈段”和“代码段”被新程序改写。 </li>
<li>新程序会保持调用exec（）进程的ID不变。 </li>
<li>调用exec（）之前打开打开的描述字继续打开（好像有什么参数可以令打开<br>的描述字在新程序中关闭）</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">169</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="michaelseu2011@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
