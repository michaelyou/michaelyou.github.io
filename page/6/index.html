<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/img/lufei.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/06/函数式编程-2-装饰器和偏函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/06/函数式编程-2-装饰器和偏函数/" itemprop="url">函数式编程(2)--装饰器和偏函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-06T14:31:47+08:00">
                2015-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##编写无参数decorator</p>
<p>Python的 <code>decorator</code> 本质上就是一个高阶函数，它接收一个函数作为参数，然后，返回一个新函数。</p>
<p>使用 decorator 用Python提供的 <code>@</code> 语法，这样可以避免手动编写 <code>f = decorate(f)</code> 这样的代码。</p>
<p>考察一个@log的定义：</p>
<pre><code>def log(f):
    def fn(x):
        print &apos;call &apos; + f.__name__ + &apos;()...&apos;
        return f(x)
    return fn
</code></pre><p>对于阶乘函数，@log工作得很好：</p>
<pre><code>@log
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
print factorial(10)
</code></pre><p><strong>结果：</strong></p>
<pre><code>call factorial()...
3628800
</code></pre><p>但是，对于参数不是一个的函数，调用将报错：</p>
<pre><code>@log
def add(x, y):
    return x + y
print add(1, 2)
</code></pre><p><strong>结果：</strong></p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 15, in &lt;module&gt;
    print add(1,2)
TypeError: fn() takes exactly 1 argument (2 given)
</code></pre><p>因为 <code>add()</code> 函数需要传入两个参数，但是 <code>@log</code> 写死了只含一个参数的返回函数。<br>要让 <code>@log</code> 自适应任何参数定义的函数，可以利用Python的 <em>args 和 *</em>kw，保证任意个数的参数总是能正常调用：</p>
<pre><code>def log(f):
    def fn(*args, **kw):
        print &apos;call &apos; + f.__name__ + &apos;()...&apos;
        return f(*args, **kw)
    return fn
</code></pre><p>现在，对于任意函数，<code>@log</code> 都能正常工作。</p>
<p><strong>栗子</strong>：请编写一个@performance，它可以打印出函数调用的时间。</p>
<p>计算函数调用的时间可以记录调用前后的当前时间戳，然后计算两个时间戳的差。</p>
<p><strong>参考代码</strong></p>
<pre><code>import time
def performance(f):
    def fn(*args, **kw):
        t1 = time.time()
        r = f(*args, **kw)
        t2 = time.time()
        print &apos;call %s() in %fs&apos; % (f.__name__, (t2 - t1))
        return r
    return fn

@performance
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
print factorial(10)
</code></pre><p>##编写带参数decorator</p>
<p>考察上一节的 <code>@log</code>装饰器：</p>
<pre><code>def log(f):
    def fn(x):
        print &apos;call &apos; + f.__name__ + &apos;()...&apos;
        return f(x)
    return fn
</code></pre><p>发现对于被装饰的函数，log打印的语句是不能变的（除了函数名）。</p>
<p>如果有的函数非常重要，希望打印出’[INFO] call xxx()…’，有的函数不太重要，希望打印出’[DEBUG] call xxx()…’，这时，log函数本身就需要传入’INFO’或’DEBUG’这样的参数，类似这样：</p>
<pre><code>@log(&apos;DEBUG&apos;)
def my_func():
    pass
</code></pre><p>把上面的定义翻译成高阶函数的调用，就是：</p>
<pre><code>my_func = log(&apos;DEBUG&apos;)(my_func)
</code></pre><p>上面的语句看上去还是比较绕，再展开一下：</p>
<pre><code>log_decorator = log(&apos;DEBUG&apos;)
my_func = log_decorator(my_func)
</code></pre><p>上面的语句又相当于：</p>
<pre><code>log_decorator = log(&apos;DEBUG&apos;)
@log_decorator
def my_func():
    pass
</code></pre><p>所以，带参数的log函数首先返回一个decorator函数，再让这个decorator函数接收my_func并返回新函数：</p>
<pre><code>def log(prefix):
    def log_decorator(f):
        def wrapper(*args, **kw):
            print &apos;[%s] %s()...&apos; % (prefix, f.__name__)
            return f(*args, **kw)
        return wrapper
    return log_decorator

@log(&apos;DEBUG&apos;)
def test():
    pass
print test()
</code></pre><p><strong>执行结果：</strong></p>
<pre><code>[DEBUG] test()...
None
</code></pre><p>对于这种3层嵌套的decorator定义，你可以先把它拆开：</p>
<pre><code># 标准decorator:
def log_decorator(f):
    def wrapper(*args, **kw):
        print &apos;[%s] %s()...&apos; % (prefix, f.__name__)
        return f(*args, **kw)
    return wrapper
return log_decorator

# 返回decorator:
def log(prefix):
    return log_decorator(f)
</code></pre><p>拆开以后会发现，调用会失败，因为在3层嵌套的<code>decorator</code>定义中，最内层的<code>wrapper</code>引用了最外层的参数<code>prefix</code>，所以，把一个闭包拆成普通的函数调用会比较困难。不支持闭包的编程语言要实现同样的功能就需要更多的代码。</p>
<p><strong>栗子</strong>：上一节的<code>@performance</code>只能打印秒，请给 <code>@performace</code> 增加一个参数，允许传入<code>&#39;s&#39;</code>或<code>&#39;ms&#39;</code>：</p>
<pre><code>@performance(&apos;ms&apos;)
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
</code></pre><p>要实现带参数的@performance，就需要实现：</p>
<pre><code>my_func = performance(&apos;ms&apos;)(my_func)
</code></pre><p>需要3层嵌套的decorator来实现。</p>
<p><strong>参考代码</strong></p>
<pre><code>import time
def performance(unit):
    def perf_decorator(f):
        def wrapper(*args, **kw):
            t1 = time.time()
            r = f(*args, **kw)
            t2 = time.time()
            t = (t2 - t1) * 1000 if unit==&apos;ms&apos; else (t2 - t1)
            print &apos;call %s() in %f %s&apos; % (f.__name__, t, unit)
            return r
        return wrapper
    return perf_decorator

@performance(&apos;ms&apos;)
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
print factorial(10)
</code></pre><p>##完善decorator</p>
<p><code>@decorator</code>可以动态实现函数功能的增加，但是，经过<code>@decorator</code>“改造”后的函数，和原函数相比，除了功能多一点外，有没有其它不同的地方？</p>
<p>在没有decorator的情况下，打印函数名：</p>
<pre><code>def f1(x):
    pass
print f1.__name__
</code></pre><p><strong>输出</strong>： f1<br>有decorator的情况下，再打印函数名：</p>
<pre><code>def log(f):
    def wrapper(*args, **kw):
        print &apos;call...&apos;
        return f(*args, **kw)
    return wrapper
@log
def f2(x):
    pass
print f2.__name__
</code></pre><p><strong>输出</strong>： wrapper<br>可见，由于<code>decorator</code>返回的新函数函数名已经不是<code>&#39;f2&#39;</code>，而是<code>@log</code>内部定义的<code>&#39;wrapper&#39;</code>。这对于那些依赖函数名的代码就会失效。<code>decorator</code>还改变了函数的<code>__doc__</code>等其它属性。如果要让调用者看不出一个函数经过了<code>@decorator</code>的“改造”，就需要把原函数的一些属性复制到新函数中：</p>
<pre><code>def log(f):
    def wrapper(*args, **kw):
        print &apos;call...&apos;
        return f(*args, **kw)
    wrapper.__name__ = f.__name__
    wrapper.__doc__ = f.__doc__
    return wrapper
</code></pre><p>这样写<code>decorator</code>很不方便，因为我们也很难把原函数的所有必要属性都一个一个复制到新函数上，所以Python内置的<code>functools</code>可以用来自动化完成这个“复制”的任务：</p>
<pre><code>import functools
def log(f):
    @functools.wraps(f)
    def wrapper(*args, **kw):
        print &apos;call...&apos;
        return f(*args, **kw)
    return wrapper
</code></pre><p>最后需要指出，由于我们把原函数签名改成了<code>(*args, **kw)</code>，因此，无法获得原函数的原始参数信息。即便我们采用固定参数来装饰只有一个参数的函数：</p>
<pre><code>def log(f):
    @functools.wraps(f)
    def wrapper(x):
        print &apos;call...&apos;
        return f(x)
    return wrapper
</code></pre><p>也可能改变原函数的参数名，因为新函数的参数名始终是 <code>&#39;x&#39;</code>，原函数定义的参数名不一定叫 <code>&#39;x&#39;</code>。</p>
<p><strong>栗子</strong>：请思考带参数的@decorator，@functools.wraps应该放置在哪：</p>
<pre><code>def performance(unit):
    def perf_decorator(f):
        def wrapper(*args, **kw):
            ???
        return wrapper
    return perf_decorator
</code></pre><p>注意@functools.wraps应该作用在返回的新函数上。</p>
<p><strong>参考代码</strong></p>
<pre><code>import time, functools
def performance(unit):
    def perf_decorator(f):
        @functools.wraps(f)
        def wrapper(*args, **kw):
            t1 = time.time()
            r = f(*args, **kw)
            t2 = time.time()
            t = (t2 - t1) * 1000 if unit==&apos;ms&apos; else (t2 - t1)
            print &apos;call %s() in %f %s&apos; % (f.__name__, t, unit)
            return r
        return wrapper
    return perf_decorator

@performance(&apos;ms&apos;)
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
print factorial.__name__
</code></pre><p>##偏函数</p>
<p>当一个函数有很多参数时，调用者就需要提供多个参数。如果减少参数个数，就可以简化调用者的负担。</p>
<p>比如，<code>int()</code>函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</p>
<pre><code>&gt;&gt;&gt; int(&apos;12345&apos;)
12345
</code></pre><p>但int()函数还提供额外的<code>base参数</code>，默认值为<code>10</code>。如果传入base参数，就可以做 <code>N</code> 进制的转换：</p>
<pre><code>&gt;&gt;&gt; int(&apos;12345&apos;, base=8)
5349
&gt;&gt;&gt; int(&apos;12345&apos;, 16)
74565
</code></pre><p>假设要转换大量的二进制字符串，每次都传入<code>int(x, base=2)</code>非常麻烦，于是，我们想到，可以定义一个<code>int2()</code>的函数，默认把<code>base=2</code>传进去：</p>
<pre><code>def int2(x, base=2):
    return int(x, base)
</code></pre><p>这样，我们转换二进制就非常方便了：</p>
<pre><code>&gt;&gt;&gt; int2(&apos;1000000&apos;)
64
&gt;&gt;&gt; int2(&apos;1010101&apos;)
85
</code></pre><p><code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数int2：</p>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2(&apos;1000000&apos;)
64
&gt;&gt;&gt; int2(&apos;1010101&apos;)
85
</code></pre><p>所以，<code>functools.partial</code>可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定默认值，这样，新函数调用的难度就降低了。</p>
<p><strong>栗子</strong>：在讲解<code>sorted</code>函数时，我们在<code>sorted</code>这个高阶函数中传入自定义排序函数就可以实现忽略大小写排序。请用<code>functools.partial</code>把这个复杂调用变成一个简单的函数：</p>
<pre><code>sorted_ignore_case(iterable)
</code></pre><p>要固定<code>sorted()的cmp参数</code>，需要传入一个排序函数作为<code>cmp</code>的默认值。</p>
<p><strong>参考代码</strong></p>
<pre><code>import functools
sorted_ignore_case = functools.partial(sorted, cmp=lambda s1, s2: cmp(s1.upper(), s2.upper()))
print sorted_ignore_case([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/06/函数式编程-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/06/函数式编程-1/" itemprop="url">函数式编程(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-06T14:30:40+08:00">
                2015-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##基本概念<br>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
<p>而函数式编程（请注意多了一个“式”字）—— <code>Functional Programming</code>，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p>
<p>我们首先要搞明白计算机（<code>Computer</code>）和计算（<code>Compute</code>）的概念。</p>
<p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>
<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<p>##高阶函数<br>能够接受函数作为参数的函数，被称为高阶函数。函数式编程就是指这种高度抽象的编程范式。</p>
<p>一个简单的高阶函数</p>
<pre><code>def add(x, y, f):
    return f(x) + f(y)
</code></pre><p>如果传入abs作为参数f的值</p>
<pre><code>add(-5, 9, abs)
</code></pre><p>根据函数的定义，函数执行的代码实际上是：</p>
<p>abs(-5) + abs(9)</p>
<p>由于参数 x, y 和 f 都可以任意传入，如果 f 传入其他函数，就可以得到不同的返回值。</p>
<p>比如说传入开平方根的函数</p>
<blockquote>
<p>计算平方根可以用函数：</p>
<blockquote>
<blockquote>
<p>math.sqrt(2)<br>    1.4142…</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>参考代码</strong></p>
<pre><code>import math
def add(x, y, f):
    return f(x) + f(y)
print add(25, 9, math.sqrt)
</code></pre><p>##map()函数</p>
<p><strong>map()</strong>是 Python 内置的高阶函数，它接收<strong>一个函数 f</strong> 和<strong>一个 list</strong>，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。</p>
<p>例如，对于list [1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
<p>如果希望把list的每个元素都作平方，就可以用map()函数：</p>
<p><img src="http://www.liaoxuefeng.com/files/attachments/0013879622109990efbf9d781704b02994ba96765595f56000/0" alt=""></p>
<p>因此，我们只需要传入函数f(x)=x*x，就可以利用map()函数完成这个计算：</p>
<pre><code>def f(x):
    return x*x
print map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
</code></pre><p>输出结果：</p>
<pre><code>[1, 4, 9, 10, 25, 36, 49, 64, 81]
</code></pre><p><strong>注意</strong>：map()函数不改变原有的 list，而是返回一个新的 list。</p>
<p>利用map()函数，可以把一个 list 转换为另一个 list，只需要传入转换函数。</p>
<p>由于list包含的元素可以是任何类型，因此，map() 不仅仅可以处理只包含数值的 list，事实上它可以处理包含任意类型的 list，只要传入的函数f可以处理这种数据类型。</p>
<p><strong>栗子</strong>：假设用户输入的英文名字不规范，没有按照首字母大写，后续字母小写的规则，请利用map()函数，把一个list（包含若干不规范的英文名字）变成一个包含规范英文名字的list：</p>
<p>输入：[‘adam’, ‘LISA’, ‘barT’]</p>
<p>输出：[‘Adam’, ‘Lisa’, ‘Bart’]</p>
<p><strong>参考代码</strong></p>
<pre><code>def format_name(s):
    return s[0].upper() + s[1:].lower()
print map(format_name, [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;])
</code></pre><p>##reduce()函数</p>
<p><strong>reduce()</strong>函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，<strong>一个函数 f</strong>，<strong>一个list</strong>，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。</p>
<p>例如，编写一个f函数，接收x和y，返回x和y的和：</p>
<pre><code>def f(x, y):
    return x + y
</code></pre><p>调用 <code>reduce(f, [1, 3, 5, 7, 9])</code>时，reduce函数将做如下计算：</p>
<pre><code>先计算头两个元素：f(1, 3)，结果为4；
再把结果和第3个元素计算：f(4, 5)，结果为9；
再把结果和第4个元素计算：f(9, 7)，结果为16；
再把结果和第5个元素计算：f(16, 9)，结果为25；
由于没有更多的元素了，计算结束，返回结果25。
</code></pre><p>上述计算实际上是对 list 的所有元素求和。虽然Python内置了求和函数sum()，但是，利用reduce()求和也很简单。</p>
<p><strong>reduce()还可以接收第3个可选参数，作为计算的初始值。</strong>如果把初始值设为100，计算：</p>
<pre><code>reduce(f, [1, 3, 5, 7, 9], 100)
</code></pre><p>结果将变为125，因为第一轮计算是：<br>计算初始值和第一个元素：<strong>f(100, 1)</strong>，结果为101。</p>
<p>##filter()函数</p>
<p><strong>filter()</strong>函数是 Python 内置的另一个有用的高阶函数，filter()函数接收<strong>一个函数 f</strong> 和<strong>一个list</strong>，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。</p>
<p>例如，要从一个<code>list [1, 4, 6, 7, 9, 12, 17]</code>中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：</p>
<pre><code>def is_odd(x):
    return x % 2 == 1
</code></pre><p>然后，利用filter()过滤掉偶数：</p>
<pre><code>filter(is_odd, [1, 4, 6, 7, 9, 12, 17])
</code></pre><p><strong>结果</strong>：[1, 7, 9, 17]</p>
<p>利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串：</p>
<pre><code>def is_not_empty(s):
    return s and len(s.strip()) &gt; 0
filter(is_not_empty, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos;  &apos;, &apos;END&apos;])
</code></pre><p><strong>结果</strong>：[‘test’, ‘str’, ‘END’]</p>
<p><strong>注意</strong>: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。</p>
<p>当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下：</p>
<pre><code>a = &apos;     123&apos;
a.strip()
</code></pre><p><strong>结果</strong>： ‘123’</p>
<pre><code>a=&apos;\t\t123\r\n&apos;
a.strip()
</code></pre><p><strong>结果</strong>：’123’</p>
<p><strong>栗子</strong>：<code>filter()</code> 接收的函数必须判断出一个数的平方根是否是整数，而 <code>math.sqrt()</code>返回结果是浮点数。</p>
<p><strong>参考代码</strong></p>
<pre><code>import math
def is_sqr(x):
    r = int(math.sqrt(x))
    return r*r==x
print filter(is_sqr, range(1, 101))
</code></pre><p>##sorted自定义排序函数</p>
<p>Python内置的 sorted()函数可对list进行排序：</p>
<pre><code>&gt;&gt;&gt;sorted([36, 5, 12, 9, 21])

[5, 9, 12, 21, 36]
</code></pre><p>但 sorted()也是一个高阶函数，它可以接收一个比较函数来实现自定义排序，比较函数的定义是，传入两个待比较的元素 x, y，<strong>如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。</strong></p>
<p>因此，如果我们要实现倒序排序，只需要编写一个reversed_cmp函数：</p>
<pre><code>def reversed_cmp(x, y):
    if x &gt; y:
        return -1
    if x &lt; y:
        return 1
    return 0
</code></pre><p>这样，调用 sorted() 并传入 reversed_cmp 就可以实现倒序排序：</p>
<pre><code>&gt;&gt;&gt; sorted([36, 5, 12, 9, 21], reversed_cmp)
[36, 21, 12, 9, 5]
</code></pre><p>sorted()也可以对字符串进行排序，字符串默认按照ASCII大小来比较：</p>
<pre><code>&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])
[&apos;Credit&apos;, &apos;Zoo&apos;, &apos;about&apos;, &apos;bob&apos;]
</code></pre><p>‘Zoo’排在’about’之前是因为’Z’的ASCII码比’a’小。</p>
<p><strong>栗子</strong>：对字符串排序时，有时候忽略大小写排序更符合习惯。请利用sorted()高阶函数，实现忽略大小写排序的算法。</p>
<p>输入：[‘bob’, ‘about’, ‘Zoo’, ‘Credit’]</p>
<p>输出：[‘about’, ‘bob’, ‘Credit’, ‘Zoo’]</p>
<p>对于比较函数cmp_ignore_case(s1, s2)，要忽略大小写比较，就是先把两个字符串都变成大写（或者都变成小写），再比较。</p>
<p><strong>参考代码</strong></p>
<pre><code>def cmp_ignore_case(s1, s2):
    u1 = s1.upper()
    u2 = s2.upper()
    if u1 &lt; u2:
        return -1
    if u1 &gt; u2:
        return 1
    return 0
print sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], cmp_ignore_case)
</code></pre><p>##返回函数</p>
<p>Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数！<br>例如，定义一个函数 f()，我们让它返回一个函数 g，可以这样写：</p>
<pre><code>def f():
    print &apos;call f()...&apos;
    # 定义函数g:
    def g():
        print &apos;call g()...&apos;
    # 返回函数g:
    return g
</code></pre><p>仔细观察上面的函数定义，我们在函数 f 内部又定义了一个函数 g。由于函数 g 也是一个对象，函数名 g 就是指向函数 g 的变量，所以，最外层函数 f 可以返回变量 g，也就是函数 g 本身。</p>
<p>调用函数 f，我们会得到 f 返回的一个函数：</p>
<pre><code>&gt;&gt;&gt; x = f()   # 调用f()
call f()...
&gt;&gt;&gt; x   # 变量x是f()返回的函数：
&lt;function g at 0x1037bf320&gt;
&gt;&gt;&gt; x()   # x指向函数，因此可以调用
call g()...   # 调用x()就是执行g()函数定义的代码
</code></pre><p>请注意区分返回函数和返回值：</p>
<pre><code>def myabs():
    return abs   # 返回函数
def myabs2(x):
    return abs(x)   # 返回函数调用的结果，返回值是一个数值
</code></pre><p>返回函数可以把一些计算延迟执行。例如，如果定义一个普通的求和函数：</p>
<pre><code>def calc_sum(lst):
    return sum(lst)
</code></pre><p>调用calc_sum()函数时，将立刻计算并得到结果：</p>
<pre><code>&gt;&gt;&gt; calc_sum([1, 2, 3, 4])
10
</code></pre><p>但是，如果返回一个函数，就可以“延迟计算”：</p>
<pre><code>def calc_sum(lst):
    def lazy_sum():
        return sum(lst)
    return lazy_sum
</code></pre><p>调用calc_sum()并没有计算出结果，而是返回函数:</p>
<pre><code>&gt;&gt;&gt; f = calc_sum([1, 2, 3, 4])
&gt;&gt;&gt; f
&lt;function lazy_sum at 0x1037bfaa0&gt;
</code></pre><p>对返回的函数进行调用时，才计算出结果:</p>
<pre><code>&gt;&gt;&gt; f()
10
</code></pre><p>由于可以返回函数，我们在后续代码里就可以决定到底要不要调用该函数。</p>
<p><strong>栗子</strong>：请编写一个函数calc_prod(lst)，它接收一个list，返回一个函数，返回函数可以计算参数的乘积。</p>
<p><strong>参考代码</strong></p>
<pre><code>def calc_prod(lst):
    def lazy_prod():
        def f(x, y):
            return x * y
        return reduce(f, lst, 1)
    return lazy_prod
f = calc_prod([1, 2, 3, 4])
print f()
</code></pre><p>##闭包</p>
<p>在函数内部定义的函数和外部定义的函数是一样的，只是他们无法被外部访问：</p>
<pre><code>def g():
    print &apos;g()...&apos;

def f():
    print &apos;f()...&apos;
    return g
</code></pre><p>将 <code>g</code> 的定义移入函数 <code>f</code> 内部，防止其他代码调用 <code>g</code>：</p>
<pre><code>def f():
    print &apos;f()...&apos;
    def g():
        print &apos;g()...&apos;
    return g
</code></pre><p>但是，考察上一小节定义的 <code>calc_sum</code> 函数：</p>
<pre><code>def calc_sum(lst):
    def lazy_sum():
        return sum(lst)
    return lazy_sum
</code></pre><p><strong>注意</strong>: 发现没法把 <code>lazy_sum</code> 移到 <code>calc_sum</code> 的外部，因为它引用了 <code>calc_sum</code> 的参数 <code>lst</code>。</p>
<p>像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为<strong>闭包（Closure）</strong>。</p>
<p>闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。举例如下：</p>
<pre><code># 希望一次返回3个函数，分别计算1x1,2x2,3x3:
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre><p>你可能认为调用f1()，f2()和f3()结果应该是<code>1，4，9</code>，但实际结果全部都是 <code>9</code>（请自己动手验证）。</p>
<p>原因就是当count()函数返回了3个函数时，这3个函数所引用的变量 i 的值已经变成了3。由于f1、f2、f3并没有被调用，所以，此时他们并未计算 i*i，当 f1 被调用时：</p>
<pre><code>&gt;&gt;&gt; f1()
9     # 因为f1现在才计算i*i，但现在i的值已经变为3
</code></pre><p>因此，返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<p><strong>栗子</strong>：返回闭包不能引用循环变量，请改写count()函数，让它正确返回能计算1x1、2x2、3x3的函数。</p>
<p>考察下面的函数 f:</p>
<pre><code>def f(j):
    def g():
        return j*j
    return g
</code></pre><p>它可以正确地返回一个闭包g，g所引用的变量j不是循环变量，因此将正常执行。<br>在count函数的循环内部，如果借助f函数，就可以避免引用循环变量i。</p>
<p><strong>参考代码</strong></p>
<pre><code>def count():
    fs = []
    for i in range(1, 4):
        def f(j):
            def g():
                return j*j
            return g
        r = f(i)
        fs.append(r)
    return fs
f1, f2, f3 = count()
print f1(), f2(), f3()
</code></pre><p>##匿名函数</p>
<p>高阶函数可以接收函数做参数，有些时候，我们不需要显式地定义函数，直接传入匿名函数更方便。</p>
<p>在Python中，对匿名函数提供了有限支持。还是以<code>map()</code>函数为例，计算 f(x)=x2 时，除了定义一个<code>f(x)</code>的函数外，还可以直接传入匿名函数：</p>
<pre><code>&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre><p>通过对比可以看出，匿名函数 <code>lambda x: x * x</code> 实际上就是：</p>
<pre><code>def f(x):
    return x * x
</code></pre><p><code>关键字lambda</code> 表示匿名函数，冒号前面的 <code>x 表示函数参数</code>。<br>匿名函数有个限制，就是<code>只能有一个表达式，不写return</code>，返回值就是该表达式的结果。</p>
<p>使用匿名函数，可以不必定义函数名，直接创建一个函数对象，很多时候可以简化代码：</p>
<pre><code>&gt;&gt;&gt; sorted([1, 3, 9, 5, 0], lambda x,y: -cmp(x,y))
[9, 5, 3, 1, 0]
</code></pre><p>返回函数的时候，也可以返回匿名函数：</p>
<pre><code>&gt;&gt;&gt; myabs = lambda x: -x if x &lt; 0 else x 
&gt;&gt;&gt; myabs(-1)
1
&gt;&gt;&gt; myabs(1)
1
</code></pre><p><strong>栗子</strong>：利用匿名函数简化以下代码：</p>
<pre><code>def is_not_empty(s):
    return s and len(s.strip()) &gt; 0

filter(is_not_empty, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos;  &apos;, &apos;END&apos;])
</code></pre><p>定义匿名函数时，没有return关键字，且表达式的值就是函数返回值。</p>
<p><strong>参考代码</strong></p>
<pre><code>print filter(lambda s: s and len(s.strip())&gt;0, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos;  &apos;, &apos;END&apos;])
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/05/Python-中的下划线命名规则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/05/Python-中的下划线命名规则/" itemprop="url">Python 中的下划线命名规则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-05T15:35:45+08:00">
                2015-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>python中用下划线命名变量和函数是在是令人困惑，单下划线，双下划线，双下划线还分前后……,今天来总结一下，以备日后参考</p>
<p>##单下划线（_）</p>
<p>通常情况下，单下划线（_）会在以下3种场景中使用：</p>
<p>###在解释器中：</p>
<p>在这种情况下，“_”代表交互式解释器会话中上一条执行的语句的结果。这种用法首先被标准CPython解释器采用，然后其他类型的解释器也先后采用。</p>
<pre><code>&gt;&gt;&gt; _ Traceback (most recent call last): 
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; 
NameError: name &apos;_&apos; is not defined 
&gt;&gt;&gt; 42
&gt;&gt;&gt; _ 
42
&gt;&gt;&gt; &apos;alright!&apos; if _ else &apos;:(&apos;
&apos;alright!&apos;
&gt;&gt;&gt; _ 
&apos;alright!&apos;
</code></pre><p>###作为一个名称：</p>
<p>这与上面一点稍微有些联系，此时<code>“_”</code>作为临时性的名称使用。这样，当其他人阅读你的代码时将会知道，你分配了一个特定的名称，但是并不会在后面再次用到该名称。例如，下面的例子中，你可能对循环计数中的实际值并不感兴趣，此时就可以使用“_”。</p>
<pre><code>n = 42
for _ in range(n): 
    do_something()
</code></pre><p>###国际化：</p>
<p>也许你也曾看到”_“会被作为一个函数来使用。这种情况下，它通常用于实现国际化和本地化字符串之间翻译查找的函数名称，这似乎源自并遵循相应的C约定。例如，在 Django文档“转换”章节 中，你将能看到如下代码：</p>
<pre><code>from django.utils.translation import ugettext as _ 
from django.http import HttpResponse 
def my_view(request): 
    output = _(&quot;Welcome to my site.&quot;) 
    return HttpResponse(output)
</code></pre><p>可以发现，场景二和场景三中的使用方法可能会相互冲突，所以我们需要避免在使用<code>“_”</code>作为国际化查找转换功能的代码块中同时使用“_”作为临时名称。</p>
<p>##名称前的单下划线（如：_shahriar）</p>
<p>程序员使用名称前的单下划线，用于指定该名称属性为“私有”。这有点类似于惯例，为了使其他人（或你自己）使用这些代码时将会知道以“_”开头的名称只供内部使用。正如Python文档中所述：</p>
<p>以下划线<code>“_”</code>为前缀的名称（如_spam）应该被视为API中非公开的部分（不管是函数、方法还是数据成员）。此时，应该将它们看作是一种实现细节，在修改它们时无需对外部通知。</p>
<p>正如上面所说，这确实类似一种惯例，因为它对解释器来说确实有一定的意义，如果你写了代码“from &lt;模块/包名&gt; import <em>”，那么以<code>“_”</code>开头的名称都不会被导入， 除非模块或包中的<code>“__all__”</code>列表显式地包含了它们 。了解更多请查看“ Importing </em> in Python ”。</p>
<p>不过值得注意的是，如果使用 <code>import a_module</code> 这样导入模块，仍然可以用 <code>a_module._some_var</code> 这样的形式访问到这样的对象。</p>
<p>另外单下划线开头还有一种一般不会用到的情况在于，使用一个 C 编写的扩展库有时会用下划线开头命名，然后使用一个去掉下划线的 Python 模块进行包装。如 struct 这个模块实际上是 C 模块 _struct 的一个 Python 包装。</p>
<p>##名称前的双下划线（如：__shahriar）</p>
<p>名称（具体为一个方法名）前双下划线<code>（__）</code>的用法并不是一种惯例，对解释器来说它有特定的意义。Python中的这种用法是为了避免与子类定义的名称冲突。Python文档指出，<code>“__spam”</code>这种形式（ 至少两个前导下划线，最多一个后续下划线 ）的任何标识符将会被<code>“_classname__spam”</code>这种形式原文取代，在这里“classname”是去掉前导下划线的当前类名。例如下面的例子：</p>
<pre><code>&gt;&gt;&gt; class A(object): 
...     def _internal_use(self): 
...         pass
...     def __method_name(self): 
...         pass
... 
&gt;&gt;&gt; dir(A()) 
[&apos;_A__method_name&apos;, ..., &apos;_internal_use&apos;]
</code></pre><p>正如所预料的，<code>“_internal_use”</code>并未改变，而<code>“__method_name”</code>却被变成了<code>“_ClassName__method_name”</code>：<code>__</code>开头 的 私有变量会在代码生成之前被转换为长格式（变为公有）。转换机制是这样的：在变量前端插入类名，再在前端加入一个下划线字符。这就是所谓的私有变量 名字改编 （Private name mangling） 。<br>此时，如果你创建A的一个子类B，那么你将不能轻易地覆写A中的方法<code>“__method_name”</code>，</p>
<pre><code>&gt;&gt;&gt; class B(A): 
...     def __method_name(self): 
...         pass
... 
&gt;&gt;&gt; dir(B()) 
[&apos;_A__method_name&apos;, &apos;_B__method_name&apos;, ..., &apos;_internal_use&apos;]
</code></pre><p>然而如果你知道了这个规律，最终你还是可以访问这个“私有”变量的。</p>
<p>私有变量名字改编意在给出一个在类中定义”私有”实例变量和方法的简单途径，避免派生类的实例变量定义产生问题，或者与外界代码中的变量搞混。</p>
<p>要注意的是混淆规则（私有变量名字改编）主要目的在于避免意外错误，被认作为私有的变量仍然有可能被访问或修改(使用<code>_classname__membername</code>)，在特定的场合它也是有用的，比如调试的时候。</p>
<p>上述的功能几乎和Java中的final方法和C++类中标准方法（非虚方法）一样。</p>
<p><strong>再讲两点题外话</strong>：</p>
<p>一是因为轧压（改编）会使标识符变长，当超过255的时候，Python会切断，要注意因此引起的命名冲突。</p>
<p>二是当类名全部以下划线命名的时候，Python就不再执行轧压（改编）。</p>
<p>无论是单下划线还是双下划线开头的成员，都是希望外部程序开发者不要直接使用这些成员变量和这些成员函数，只是双下划线从语法上能够更直接的避免错误的使用，但是如果按照 <code>_类名__成员名</code> 则依然可以访问到。单下划线的在动态调试时可能会方便一些，只要项目组的人都遵守下划线开头的成员不直接使用，那使用单下划线或许会更好。</p>
<p>##名称前后的双下划线（如：<strong>init</strong>）</p>
<p>这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写<code>“__init__”</code>方法。</p>
<p>双下划线开头双下划线结尾的是一些 Python 的“魔术”对象，如类成员的 <code>__init__</code>、<code>__del__</code>、<code>__add__</code>、<code>__getitem__</code> 等，以及全局的 <code>__file__</code>、<code>__name__</code> 等。 Python 官方推荐永远不要将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。 虽然你也可以编写自己的特殊方法名，但不要这样做。</p>
<pre><code>&gt;&gt;&gt; class C(object): 
...     def __mine__(self): 
...         pass
... 
&gt;&gt;&gt; dir(C) 
... [..., &apos;__mine__&apos;, ...]
</code></pre><p>其实，很容易摆脱这种类型的命名，而只让Python内部定义的特殊名称遵循这种约定 :)</p>
<p>##题外话 if <strong>name</strong> == “<strong>main</strong>“:</p>
<p>所有的 Python 模块都是对象并且有几个有用的属性，你可以使用这些属性方便地测试你所书写的模块。</p>
<p>模块是对象, 并且所有的模块都有一个内置属性<code>__name__</code>。一个模块的<code>__name__</code> 的值要看您如何应用模块。如果 import 模块, 那么 <code>__name__</code>的值通常为模块的文件名, 不带路径或者文件扩展名。但是您也可以像一个标准的程序一样直接运行模块, 在这种情况下<code>__name__</code>的值将是一个特别的缺省值：<code>__main__</code>。</p>
<pre><code>&gt;&gt;&gt; import odbchelper
&gt;&gt;&gt; odbchelper.__name__
&apos;odbchelper&apos;
</code></pre><p>一旦了解到这一点, 您可以在模块内部为您的模块设计一个测试套件, 在其中加入这个 if 语句。当您直接运行模块, <code>__name__</code> 的值是 <code>__main__</code>, 所以测试套件执行。当您导入模块,<code>__name__</code>的值就是别的东西了, 所以测试套件被忽略。这样使得在将新的模块集成到一个大程序之前开发和调试容易多了。</p>
<p>在 MacPython 上, 需要一个额外的步聚来使得<code>if __name__</code>技巧有效。 点击窗口右上角的黑色三角, 弹出模块的属性菜单, 确认<code>Run as __main__</code>被选中。</p>
<p>##总结：</p>
<p>Python 用下划线作为变量前缀和后缀指定特殊变量。</p>
<p><code>_xxx</code>       不能用’from module import *’导入</p>
<p><code>__xxx__</code>  系统定义名字</p>
<p><code>__xxx</code>    类中的私有变量名</p>
<p><strong>核心风格：避免用下划线作为变量名的开头。</strong></p>
<p>因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避免用下划线作为变量名的开头。一般来讲，变量名_xxx被看作是“私有的”，在模块或类外不可以使用。当变量是私有的时候，用_xxx 来表示变量是很好的习惯。 因为变量名<code>__xxx__</code>对Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。</p>
<p>“单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；</p>
<p>“双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。</p>
<p>以单下划线开头（如_foo）的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用<code>“from xxx import *”</code>而导入；以双下划线开头的（如<code>__foo</code>）代表类的私有成员；以双下划线开头和结尾的（<code>__foo__</code>）代表python里特殊方法专用的标识，如<code>__init__()</code> 代表类的构造函数。</p>
<p>附 PEP 规范：</p>
<pre><code>PEP-0008:
In addition, the following special forms using leading or trailing underscores are recognized (these can generally be combined with any case convention):
  - _single_leading_underscore: weak &quot;internal use&quot; indicator. E.g. &quot;from M import *&quot; does not import objects whose name starts with an underscore.
  - single_trailing_underscore_: used by convention to avoid conflicts with Python keyword, e.g.
    Tkinter.Toplevel(master, class_=&apos;ClassName&apos;)
  - __double_leading_underscore: when naming a class attribute, invokes name mangling (inside class FooBar, __boo becomes _FooBar__boo; see below).
  - __double_leading_and_trailing_underscore__: &quot;magic&quot; objects or attributes that live in user-controlled namespaces. E.g. __init__,
    __import__ or __file__. Never invent such names; only use them as documented.
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/05/转载-程序员必须知道的10大基础实用算法及其讲解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/05/转载-程序员必须知道的10大基础实用算法及其讲解/" itemprop="url">转载:程序员必须知道的10大基础实用算法及其讲解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-05T08:52:38+08:00">
                2015-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载自<a href="http://cricode.com/2001.html" target="_blank" rel="external">这里</a></p>
<p>##算法一：快速排序算法</p>
<p><strong>快速排序</strong>是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要<code>Ο(n log n)</code>次比较。在最坏状况下则需要<code>Ο(n2)</code>次比较，但这种状况并不常见。事实上，快速排序通常明显比其他<code>Ο(n log n)</code> 算法更快，因为它的内部循环<code>（inner loop）</code>可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法<code>（Divide and conquer）</code>策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>从数列中挑出一个元素，称为 “基准”（pivot），</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
</ol>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Sorting_quicksort_anim.gif" alt=""></p>
<p><strong>详细介绍</strong>：<a href="http://cricode.com/970.html" target="_blank" rel="external">快速排序</a></p>
<p>##算法二：堆排序算法</p>
<p><strong>堆排序</strong>（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序的平均时间复杂度为<code>Ο(nlogn)</code> 。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li>创建一个堆H[0..n-1]</li>
<li>把堆首（最大值）和堆尾互换</li>
<li><p>把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置</p>
</li>
<li><p>重复步骤2，直到堆的尺寸为1</p>
</li>
</ol>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Sorting_heapsort_anim.gif" alt=""></p>
<p>详细介绍：<a href="http://cricode.com/977.html" target="_blank" rel="external">堆排序</a></p>
<p>##算法三：归并排序</p>
<p><strong>归并排序</strong>（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p>
</li>
<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p>
</li>
<li><p>重复步骤3直到某一指针达到序列尾</p>
</li>
<li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p>
</li>
</ol>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Merge_sort_animation2.gif" alt=""></p>
<p>详细介绍：<a href="http://taop.marchtea.com/04.01.html" target="_blank" rel="external">归并排序</a></p>
<p>##算法四：二分查找算法</p>
<p><strong>二分查找算法</strong>是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为<code>Ο(logn)</code>。</p>
<p>详细介绍：<a href="http://taop.marchtea.com/04.01.html" target="_blank" rel="external">二分查找算法</a></p>
<p>##算法五：BFPRT(线性查找算法)</p>
<p><strong>BFPRT算法</strong>解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂度，五位算法作者做了精妙的处理。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>将n个元素每5个一组，分成n/5(上界)组。</p>
</li>
<li><p>取出每一组的中位数，任意排序方法，比如插入排序。</p>
</li>
<li><p>递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。</p>
</li>
<li><p>用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。</p>
</li>
<li><p>若i==k，返回x；若i<k，在小于x的元素中递归查找第i小的元素；若i>k，在大于x的元素中递归查找第i-k小的元素。</k，在小于x的元素中递归查找第i小的元素；若i></p>
</li>
</ol>
<p><strong>终止条件</strong>：n=1时，返回的即是i小元素。</p>
<p>详细介绍：</p>
<p><a href="http://cricode.com/968.html" target="_blank" rel="external">寻找最小(最大)的k个数</a></p>
<p><a href="http://taop.marchtea.com/02.01.html" target="_blank" rel="external">线性查找相关算法</a></p>
<p>##算法六：DFS（深度优先搜索）</p>
<p><strong>深度优先搜索算法</strong>（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS属于盲目搜索。</p>
<p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。</p>
<p><strong>深度优先遍历图算法步骤</strong>：</p>
<ol>
<li><p>访问顶点v；</p>
</li>
<li><p>依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</p>
</li>
<li><p>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</p>
</li>
</ol>
<p>上述描述可能比较抽象，举个实例：</p>
<p>DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1邻 接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，… 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。</p>
<p>接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</p>
<p>详细介绍：<a href="http://www.cnblogs.com/skywang12345/p/3711483.html" target="_blank" rel="external">深度优先搜索</a></p>
<p>##算法七：BFS(广度优先搜索)</p>
<p><strong>广度优先搜索算法</strong>（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>首先将根节点放入队列中。</p>
</li>
<li><p>从队列中取出第一个节点，并检验它是否为目标。</p>
</li>
<li><p>如果找到目标，则结束搜寻并回传结果。<br>否则将它所有尚未检验过的直接子节点加入队列中。</p>
</li>
<li><p>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</p>
</li>
<li><p>重复步骤2。</p>
</li>
</ol>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Animated_BFS.gif" alt=""></p>
<p>详细介绍：<a href="http://www.cnblogs.com/skywang12345/p/3711483.html" target="_blank" rel="external">广度优先搜索</a></p>
<p>##算法八：Dijkstra算法</p>
<p><strong>戴克斯特拉算法</strong>（Dijkstra’s algorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</p>
<p>该算法的输入包含了一个有权重的有向图 G，以及G中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中所有边的集合，而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t的最低权重路径(例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。对于不含负权的有向图，Dijkstra算法是目前已知的最快的单源最短路径算法。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>初始时令 S={V0},T={其余顶点}，T中顶点对应的距离值</p>
<ul>
<li><p>若存在<v0,vi>，d(V0,Vi)为<v0,vi>弧上的权值</v0,vi></v0,vi></p>
</li>
<li><p>若不存在<v0,vi>，d(V0,Vi)为∞</v0,vi></p>
</li>
</ul>
</li>
<li><p>从T中选取一个其距离值为最小的顶点W且不在S中，加入S</p>
</li>
<li><p>对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值</p>
</li>
</ol>
<p>重复上述步骤2、3，直到S中包含所有顶点，即W=Vi为止</p>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Dijkstra_Animation.gif" alt=""></p>
<p>详细：<a href="http://www.cnblogs.com/skywang12345/p/3711512.html" target="_blank" rel="external">Dijkstra算法</a></p>
<p>##算法九：动态规划算法</p>
<p><strong>动态规划</strong>（Dynamic programming）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<p>关于动态规划最经典的问题当属背包问题。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p>
</li>
<li><p>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>
</li>
</ol>
<p><strong>详细参考</strong>：</p>
<p><a href="http://cricode.com/1096.html" target="_blank" rel="external">从全球导航到输入法：谈谈动态规划</a></p>
<p><a href="http://hawstein.com/posts/dp-novice-to-advanced.html" target="_blank" rel="external">动态规划</a></p>
<p>##算法十：朴素贝叶斯分类算法</p>
<p>朴素贝叶斯分类算法是一种基于贝叶斯定理的简单概率分类算法。贝叶斯分类的基础是概率推理，就是在各种条件的存在不确定，仅知其出现概率的情况下，如何完成推理和决策任务。概率推理是与确定性推理相对应的。而朴素贝叶斯分类器是基于独立假设的，即假设样本每个特征与其他特征都不相关。</p>
<p>朴素贝叶斯分类器依靠精确的自然概率模型，在有监督学习的样本集中能获取得非常好的分类效果。在许多实际应用中，朴素贝叶斯模型参数估计使用最大似然估计方法，换言之朴素贝叶斯模型能工作并没有用到贝叶斯概率或者任何贝叶斯模型。</p>
<p>尽管是带着这些朴素思想和过于简单化的假设，但朴素贝叶斯分类器在很多复杂的现实情形中仍能够取得相当好的效果。</p>
<p><strong>详细参考</strong>：</p>
<p><a href="http://cricode.com/1078.html" target="_blank" rel="external">贝叶斯网络</a></p>
<p><a href="http://cricode.com/1098.html" target="_blank" rel="external">朴素贝叶斯分类算法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/27/django-session的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/27/django-session的使用/" itemprop="url">Django--session的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-27T22:00:40+08:00">
                2015-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>外面下大雨，回不去了，记录一下刚刚使用django的session遇到的一个问题。</p>
<p>想要让用户注册之后能够返回到注册之前的页面，这样就要记住之前的url，我想用session来保存url，思路是对的，但是实施的时候却总是实现不了。</p>
<p>各种assert False，还是没能看出来，没办法只能继续看文档，果然让我找到了这个</p>
<blockquote>
<p>flush()</p>
<p>Delete the current session data from the session and delete the session cookie. This is used if you want to ensure that the previous session data can’t be accessed again from the user’s browser (for example, the django.contrib.auth.logout() function calls it).</p>
</blockquote>
<p>这是session的flush方法，用来清除会话的，注意最后一句，调用auth.logout()就会自动调用flush方法，原来如此</p>
<p>我在log_in这个函数的第一句就写了<code>auth.logout(request)</code>，难怪老是在session发现不了定义的字段。</p>
<p>有困难找官方文档</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/27/python-对象的拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/27/python-对象的拷贝/" itemprop="url">python 对象的拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-27T19:12:42+08:00">
                2015-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##小例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; a.append(&apos;b&apos;)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;, &apos;b&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;, &apos;b&apos;]
</code></pre><p>可以看出，赋值号“=”是引用，即a 和 b 是指向一个对象。</p>
<p>如何实现对象的拷贝呢，python 有 copy模块。</p>
<p>##用法</p>
<pre><code>import copy
对象2 = copy.copy(对象1)
</code></pre><p>##例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = copy.copy(a)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; a.append(&apos;b&apos;)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;, &apos;b&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
</code></pre><p>##问题</p>
<pre><code>&gt;&gt;&gt; a = [[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b = copy.copy(a)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; a[1].append(&apos;c&apos;)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
&gt;&gt;&gt; a.append((3,4,5))
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], (3, 4, 5)]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
</code></pre><p> 可以看出：copy 可以实现浅层拷贝，可以通过copy.deepcoppy(）来实现深层拷贝。</p>
<p>##深拷贝</p>
<pre><code>&gt;&gt;&gt; a = [[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b = copy.deepcopy(a)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; a[1].append(&apos;hello&apos;)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;hello&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
</code></pre><p>##对象三要素</p>
<p>python中的对象包含三要素:id, type, value</p>
<ol>
<li>id 用来标识唯一一个对象</li>
<li>type标识对象的类型</li>
<li>value用来设置对象的值。</li>
</ol>
<p><code>is</code> 判断是否是一个对象，是使用id来判断的。</p>
<p><code>==</code> 是判断a对象的值是否是b对象的值，默认调用它的<code>__eq__</code>方法。</p>
<p>###例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; c = copy.copy(a)
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; a is c
False
</code></pre><p><code>&quot;b  = a&quot;</code> 是引用 指向的一个对象，所以<code>a is b</code> 返回 True</p>
<p><code>&quot;c = copy.copy(a)&quot;</code>  c是a的拷贝，不是指向一个对象，返回False </p>
<pre><code>&gt;&gt;&gt; a == c
True
</code></pre><p>但是他们的值确实是相同的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/27/CGI和WSGI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/27/CGI和WSGI/" itemprop="url">CGI和WSGI</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-27T08:50:26+08:00">
                2015-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我对 CGI 的理解是利用程序的标准输入输出流，完成 HTTP 通信。HTTP 是文本协议，每次请求的文本以标准输入流的形式进入服务器端 CGI 程序，创建进程；然后进程的标准输出流作为响应 。</p>
<p>WSGI 和 CGI 原理极其相似，但是是完全不同的实现。WSGI 是 Python 专用的协议，也是输入&amp;输出的方式传输文本流，但不是创建进程，而是对一个 WSGI 程序（callable 的对象，可以是函数也可以是实现了 <strong>call</strong> 的对象），将 request 作为参数传入（不再是纯文本，而是经过包装），同样将经过包装的 response 作为响应返回。request/response 的包装由 Python 标准库提供。</p>
<p>二者都是标准，都有诸多实现。CGI 最为广泛，无论是二进制程序、perl 脚本、python 脚本还是 PHP 都可以以这样的原理提供 HTTP 服务；WSGI 在 Python 界也是公共标准，主流 Web 框架基本都有实现，例如 Bottle 的 bottle.Bottle （Application 对象）就实现了 WSGI 协议（见 <strong>call</strong> 方法）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/26/django的QuerySets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/26/django的QuerySets/" itemprop="url">Django的QuerySets</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-26T18:53:25+08:00">
                2015-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对象关系映射 (ORM) 使得与SQL数据库交互更为简单，不过也被认为效率不高，比原始的SQL要慢。<br>要有效的使用ORM，意味着需要多少要明白它是如何查询数据库的。本文我将重点介绍如何有效使用 <a href="https://docs.djangoproject.com/en/dev/topics/db/models/" target="_blank" rel="external">Django ORM</a>系统访问中到大型的数据集。</p>
<p>##Django的queryset是惰性的</p>
<p><strong>Django的queryset对应于数据库的若干记录（row）</strong>，通过可选的查询来过滤。例如，下面的代码会得到数据库中名字为‘Dave’的所有的人:<br>?</p>
<pre><code>person_set = Person.objects.filter(first_name=&quot;Dave&quot;)
</code></pre><p>上面的代码并没有运行任何的数据库查询。你可以使用person_set，给它加上一些过滤条件，或者将它传给某个函数，这些操作都不会发送给数据库。这是对的，因为数据库查询是显著影响web应用性能的因素之一。<br>要真正从数据库获得数据，你需要遍历queryset:<br>?</p>
<pre><code>for person in person_set:
    print(person.last_name)
</code></pre><p>##Django的queryset是具有cache的</p>
<p>当你遍历queryset时，所有匹配的记录会从数据库获取，然后转换成Django的model。这被称为<code>执行</code>（evaluation）。这些model会保存在queryset内置的cache中，这样如果你再次遍历这个queryset，你不需要重复运行通用的查询。<br>例如，下面的代码只会执行一次数据库查询：</p>
<pre><code>pet_set = Pet.objects.filter(species=&quot;Dog&quot;)
# The query is executed and cached.
for pet in pet_set:
    print(pet.first_name)
# The cache is used for subsequent iteration.
for pet in pet_set:
    print(pet.last_name)
</code></pre><p>##if语句会触发queryset的执行</p>
<p>queryset的cache最有用的地方是可以有效的测试queryset是否包含数据，只有有数据时才会去遍历：</p>
<pre><code>restaurant_set = Restaurant.objects.filter(cuisine=&quot;Indian&quot;)
# `if`语句会触发queryset的执行。
if restaurant_set:
    # 遍历时用的是cache中的数据
    for restaurant in restaurant_set:
        print(restaurant.name)
</code></pre><p>##QuerySet的常用API</p>
<p>###去重<br>distinct方法的作用和SQL的distinct的作用是一样的，这里就不多说了</p>
<pre><code>Author.objects.distinct()
</code></pre><p>###序列化为JSON<br>和前端进行交互的时候，序列化成XML的情况还是比较少的，但是序列化成JSON格式的字符串的情况就比较多了，Django的ORM框架提供了values的方法来把实体序列化成json</p>
<pre><code>Blog.objects.values()
</code></pre><p>###序列化成数组<br>把对象序列化成数组元素的情况还真的是用的比较少</p>
<pre><code>Entry.objects.values_list(&apos;id&apos;, &apos;headline&apos;)
</code></pre><p>###从主表获取外键表的对象<br>在主表的实体上使用filter，然后再通过主表的实体获取外键的时候，Django会把主表的实体一并查询出来。但是有时候我们只希望从主表开始取数，但是只取外键表实体的信息，这个时候就可以用select_related方法了。第一个参数是主表的外键字段名称，第二个字段嘛。。。照抄就是了</p>
<pre><code>g = Group.objects.select_related(&apos;room&apos;, &apos;subject&apos;)
</code></pre><p>当然，也会有只希望拿主表信息，不想把外键字段取回来的情况，把参数设置为none就好了</p>
<pre><code>without_relations = queryset.select_related(None)
</code></pre><p>###处理从表对象<br>对于外键表来说，我们可以采用select_related的方法来进行处理。但是对于从表属性来说，就要用到另外一种方法了。（toppings是多对多的属性）</p>
<pre><code>Pizza.objects.all().prefetch_related(&apos;toppings&apos;)
</code></pre><p>同样的，不获取外键对象的话把参数设置为none就好了</p>
<pre><code>non_prefetched = qs.prefetch_related(None)
</code></pre><p>###ORM和SQL的混合：Extra方法<br>先看看Extra方法的一些例子</p>
<p>####selec参数<br>    Entry.objects.extra(select={‘is_recent’: “pub_date &gt; ‘2006-01-01’”})</p>
<p>####where参数<br>    Entry.objects.extra(where=[“foo=’a’ OR bar = ‘a’”, “baz = ‘a’”])</p>
<p>####order_by参数<br>    q = q.extra(order_by = [‘-is_recent’])</p>
<p>####paramas参数<br>    Entry.objects.extra(where=[‘headline=%s’], params=[‘Lennon’])<br>其实从官方给的例子看起来，Extra方法主要就是用于在ORM生成SQL的过程中内嵌SQL语句。例如希望在select 背后加入一句sql，例如select …,(select a from …)这种情况下的时候，用Extra方法就很好解决了</p>
<p>###使用Defer和Only来过滤字段<br>select_related和prefetch_related方法分别用来过滤实体的外键属性和多对多属性，对于主表的字段属性过滤可以采用defer方法来少查询一些字段</p>
<pre><code>Entry.objects.defer(&quot;headline&quot;, &quot;body&quot;)
</code></pre><p>defer是排除哪些字段，而only是只查询哪些字段</p>
<pre><code>Person.objects.only(&quot;name&quot;)
</code></pre><p>###使用select_for_update来简化更新的过程<br>一般更新实体的时候，我们需要先把实体先查询出来，然后做出相应的更新，再做一次save操作</p>
<pre><code>entity=Entry.objects.filter(...)[0]
entity.name=xx
entity.save()
</code></pre><p>这个过程显得稍微有点繁琐，所以可以采用一种select_for_update来进行一些简化</p>
<pre><code>entries = Entry.objects.select_for_update().filter(author=request.user)
</code></pre><p>###使用get_or_create来简化创建对象的过程<br>同样的，有时候我们会需要先查询对象在不在数据库里面存储，假如没有的话就创建，有的话就取出</p>
<pre><code>obj, created = Person.objects.get_or_create(first_name=&apos;John&apos;, last_name=&apos;Lennon&apos;,
              defaults={&apos;birthday&apos;: date(1940, 10, 9)})
</code></pre><p>不过个人觉得这个方法用到的情况很少。。。。</p>
<p>###批量插入数据<br>    Entry.objects.bulk_create([<br>        Entry(headline=”Django 1.0 Released”),<br>        Entry(headline=”Django 1.1 Announced”),<br>        Entry(headline=”Breaking: Django is awesome”)<br>      ])<br>这玩意真的挺有用，具体的就不细说了</p>
<p>###使用Count方法来进行统计<br>虽然做统计的话可以先把过滤完的对象查询出来，然后再len(xx)一下，但是这种做法会把数据库里面一堆一堆的暑假都查出来的(￣◇￣;)，所以当需要做count操作的时候还是老老实实的用sql的count语句，在Django里面的话做法如下</p>
<pre><code>Entry.objects.filter(headline__contains=&apos;Lennon&apos;).count()
</code></pre><p>###判断数据是否存在:exists<br>    rs=some_queryset.filter(pk=entry.pk).exists()</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/16/一些pythonic代码的例子/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/16/一些pythonic代码的例子/" itemprop="url">一些pythonic代码的例子</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-16T20:53:22+08:00">
                2015-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##百分号的使用：<br>通常我们都是这样格式化字符串的:</p>
<pre><code>print &apos;hello world programme by %s&apos; % &apos;python&apos;  
</code></pre><p> 但是如果格式化的字符串中有很多%s,那么程序的可读性就会依靠于%后面 的变量名起得是否好了。</p>
<p>这个时候有一种用dict来格式化的%，我觉得很有用，尤其是在记log的 时候，作为log的格式，可读性非常高。<br>代码如下：</p>
<pre><code>#字符串  
value = {&apos;what&apos;: &apos;hello, world&apos;, &apos;language&apos;: &apos;python&apos;}  
print &apos;%(what)s, %(language)s&apos; % value  
#也可以包含int的  
value = {&apos;name&apos;: &apos;jianpx&apos;, &apos;age&apos;: 23}  
print &apos;%(name)s &apos;s age is  %(age)i&apos; % value
</code></pre><h2 id="用两个元素之间有对应关系的list构造一个dict："><a href="#用两个元素之间有对应关系的list构造一个dict：" class="headerlink" title="用两个元素之间有对应关系的list构造一个dict："></a>用两个元素之间有对应关系的list构造一个dict：</h2><p>运用zip可以非常简单的实现：</p>
<pre><code>names = [&apos;jianpx&apos;, &apos;yue&apos;]  
ages = [23, 40]  
m = dict(zip(names,ages))  
</code></pre><p> zip的使用可以help(zip)或者查看官方文档。</p>
<p>##交换两个值：<br>在其他语言可能要一个临时变量和三句话：</p>
<pre><code>temp = a
a = b
b = temp
</code></pre><p>但是在python，一句就ok了，而且不需要临时变量：</p>
<pre><code>a,b = b,a
</code></pre><p>右边的b,a 其实可以理解成一个tuple。</p>
<p>##数量多的字符串相连用join：<br>python字符串效率问题之一就是在连接字符串的时候使用‘+’号，例如 <code>s = &#39;s1&#39; + &#39;s2&#39; + &#39;s3&#39; + ...+&#39;sN&#39;</code>，总共将N个字符串连接起来，但是使用+号的话，python需要申请N-1次内存空间，然后进行字符串拷贝。原因是字符串对象<code>PyStringObject</code>在python当中是<strong>不可变对象</strong>，所以每当需要合并两个字符串的时候，就要重新申请一个新的内存空间（大小为两个字符串长度之和）来给这个合并之后的新字符串，然后进行拷贝。所以用+号效率非常低。建议在连接字符串的时候使用字符串本身的方法<code>join（list）</code>，这个方法能提高效率，原因是它只是申请了一次内存空间，因为它可以遍历list中的元素计算出总共需要申请的内存空间的大小，一次申请完。所以上面的例子可以写成<code>s = &#39;&#39;.join([&#39;s1&#39;,&#39;s2&#39;,....,&#39;sN&#39;])</code></p>
<p>例子是：</p>
<pre><code>#以前是这样写的  
fruits = [&apos;apple&apos;, &apos;banana&apos;]  
result = &apos;&apos;  
for f in fruits:  
    result += f  

#现在可以这样：  
fruits = [&apos;apple&apos;, &apos;banana&apos;]  
result = &apos;&apos;.join(fruits)  
</code></pre><p>##判断一个key是否在一个dict里面：<br>以前很经常犯的一个<strong>mistake</strong>是这样做：</p>
<pre><code>if key in dict_example:  
    do something  
</code></pre><p> 现在要这样写，就不用使用in操作了。</p>
<pre><code>if dict_example.has_key(key):  
    do something  
</code></pre><p>##去掉list中的重复元素：</p>
<pre><code>old_list = [1,1,1,3,4]  
new_list = list(set(old_list))  
</code></pre><p>##判断元素是否在列表中<br>如果对没有重复元素的列表对象，要判断某个元素是否在列表里面的话，当这个列表很大的时候，用set会比list<br>的性能要好，因为对于list，本身允许重复元素存在，所以它不是用hash实现的，但是set不一样，它不允许重复元素，看了python源代码，从set的实现源码setobject.c 中查找key的函数</p>
<pre><code>static setentry *
set_lookkey(PySetObject *so, PyObject *key, register long hash)    
</code></pre><p>的接口可以看出它真的使用hash去实现的。</p>
<p>所以对于in操作，set的实现是计算这个元素的hash值然后判断，理论上可以达到O(1)</p>
<p>##读文件操作：<br>    以前是这样写的：</p>
<pre><code>#默认文件存在，不处理Exception的情况  
f = open(&apos;filename&apos;, &apos;r&apos;)  
while 1:  
    line = f.readline()  
    if not line:  
        break  
    print line  

if f:  
    f.close()  
</code></pre><p>用with关键字可以这样简写了，</p>
<pre><code>from __future__ import with_statement  
with open(&apos;filename&apos;,&apos;r&apos;) as f:  
    for line in f:  
        print line  
</code></pre><p>具体关于with的可以参考<a href="http://jianpx.iteye.com/blog/505469" target="_blank" rel="external">这篇文章</a></p>
<p>##输出数组的index和值：<br>以前是要这样写的：</p>
<pre><code>l = [1,3,4]  
for i in xrange(len(l)):  
    print &apos;%d, %d&apos; % (i , l[i])  
</code></pre><p>现在可以用<strong>enumerate</strong>函数帮助你简写：</p>
<pre><code>l = [1,3, 4]  
for index, value in enumerate(l):  
    print &apos;%d, %d&apos; % (index, value)  
</code></pre><p>##关于使用map、filter、reduce的例子网上很多，这里不细说了，它们的使用也是pythonic的examples</p>
<p>##分隔一个字符串，去里面的元素<code>，</code>,但是空白字符串不要：<br>例如， names = ‘jianpx, yy, mm, , kk’</p>
<pre><code>names = &apos;jianpx, mm, yy, , kk&apos;  
name_list = names.split(&apos;,&apos;)  
result = []  
for name in name_list:  
    if name:  
        result.append(name)  
</code></pre><p>现在是这样写的：</p>
<pre><code>names = &apos;jianpx, yy, mm, , kk&apos;  
result = [name for name in names.split(&apos;,&apos;) if name.strip()]  
</code></pre><p>##模拟c语言中的  a?b:c<br>在python里面可以这样做：</p>
<pre><code>return_value = True if a == 1 else False  
</code></pre><p> 从而代替了这样的代码：</p>
<pre><code>if a == 1:  
    return_value = True  
else   
    return_value = False  
</code></pre><p>##用Decorator抽离公用代码或者解耦<br>例如要对一个函数做cache，对一个操作限制权限，如果需求随时可能变化，就是说有可能不需要做cache或者不需要做权限的时候，你如果把实现放到这些函数体里面，那么这时你必须把这些代码删除，而且要很小心。但是如果你用Decorator去做的话， 只要删除函数头顶上的@那一行就可以了。Django经常用这种方法做权限控制。<br>熟悉decorator的应该都很容易理解。</p>
<p>##如何将list的元素倒序并且生成到新的list呢？ </p>
<p>看到一个用list的slice做到的 :</p>
<pre><code>a = [1,2,3,4]  
c = &apos;abcdef&apos;  
aa= a[::-1]  
cc = c[::-1]  
</code></pre><p> 如果不用生成新的list，直接调用a.reverse()就得了。但是字符串类型没有reverse的方法.</p>
<p>关于list的slice特性， 其实也许很多人平时只是用list[start:end] 这样的， 这个意思是从start开始，每个元素都放到新的list里面， 直到end。但是其实还可以每隔N个元素才取一次的， 这种情况要3个参数:<code>·list[start:end:step]</code>，<code>step</code>就是间隔了。</p>
<p>##a = [i for i in xrange(5)]   和  a = (i for i in xrange(5)) </p>
<p>虽然看上去是一样都生成了5个元素，但是<br>前者是一个list对象， 如果遍历的话 <code>for item in a</code> 就会一下子返回全部元素然后再遍历， 而后者是个Generator，<br>用for item in a遍历是每次只是返回一个元素， 这样的好处是省内存（在list很大的情况下）。</p>
<p>##python的all函数可以简化逻辑表达式有很多”与“的时候的写法<br>比如：</p>
<pre><code>a, b, c = True, False, True
if a and b and c:
    return True
else:
    return False
可以简化成:
    return all([a, b, c])
</code></pre><p>由此可以看到all函数的作用是判断当且仅当参数里面都为真的时候返回真， 否则返回假。</p>
<p>但是这里更深入的话涉及all的判断顺序和传入的参数是list还是iterable对象是不同的。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/MTV-开发模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/MTV-开发模式/" itemprop="url">MTV 开发模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T20:15:05+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们来花点时间考虑下 Django 数据驱动 Web 应用的总体设计。</p>
<p>我们在前面章节提到过，Django 的设计鼓励松耦合及对应用程序中不同部分的严格分割。 遵循这个理念的话，要想修改应用的某部分而不影响其它部分就比较容易了。 在视图函数中，我们已经讨论了通过模板系统把业务逻辑和表现逻辑分隔开的重要性。 在数据库层中，我们对数据访问逻辑也应用了同样的理念。</p>
<p>把<code>数据存取逻辑</code>、<code>业务逻辑</code>和<code>表现逻辑</code>组合在一起的概念有时被称为软件架构的<code>Model-View-Controller (MVC)</code>模式。 在这个模式中， <code>Model</code> 代表数据存取层，<code>View</code>代表的是系统中选择显示什么和怎么显示的部分，<code>Controller</code> 指的是系统中根据用户输入并视需要访问模型，以决定使用哪个视图的那部分。</p>
<p>为什么用缩写？</p>
<p>像 MVC 这样的明确定义模式的主要用于改善开发人员之间的沟通。 比起告诉同事，“让我们采用抽象的数据存取方式，然后单独划分一层来显示数据，并且在中间加上一个控制它的层”，一个通用的说法会让你收益，你只需要说：“我们在这里使用MVC模式吧。”。</p>
<p>Django 紧紧地遵循这种 MVC 模式，可以称得上是一种 MVC 框架。 以下是 Django 中 M、V 和 C 各自的含义：</p>
<ul>
<li><p>M ，数据存取部分，由django数据库层处理，本章(第5章)要讲述的内容。</p>
</li>
<li><p>V ，选择显示哪些数据要显示以及怎样显示的部分，由视图和模板处理。</p>
</li>
<li><p>C ，根据用户输入委派视图的部分，由 Django 框架根据 URLconf 设置，对给定 URL 调用适当的 Python 函数。</p>
</li>
</ul>
<p>由于 C 由框架自行处理，而 Django 里更关注的是<strong>模型（Model）、模板(Template)和视图（Views）</strong>，Django 也被称为 <strong>MTV 框架</strong> 。在 MTV 开发模式中：</p>
<ul>
<li><p>M 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。</p>
</li>
<li><p>T 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。</p>
</li>
<li><p>V 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。</p>
</li>
</ul>
<p>如果你熟悉其它的 MVC Web开发框架，比方说 Ruby on Rails，你可能会认为 Django 视图是控制器，而 Django 模板是视图。 很不幸，这是对 MVC 不同诠释所引起的错误认识。 在 Django 对 MVC 的诠释中，视图用来描述要展现给用户的数据；不是数据 如何展现 ,而且展现 哪些 数据。 相比之下，Ruby on Rails 及一些同类框架提倡控制器负责决定向用户展现哪些数据，而视图则仅决定 如何 展现数据，而不是展现 哪些 数据。</p>
<p>两种诠释中没有哪个更加正确一些。 重要的是要理解底层概念。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">167</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="michaelseu2011@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
