<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/05/转载-程序员必须知道的10大基础实用算法及其讲解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/05/转载-程序员必须知道的10大基础实用算法及其讲解/" itemprop="url">转载:程序员必须知道的10大基础实用算法及其讲解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-05T08:52:38+08:00">
                2015-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载自<a href="http://cricode.com/2001.html" target="_blank" rel="external">这里</a></p>
<p>##算法一：快速排序算法</p>
<p><strong>快速排序</strong>是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要<code>Ο(n log n)</code>次比较。在最坏状况下则需要<code>Ο(n2)</code>次比较，但这种状况并不常见。事实上，快速排序通常明显比其他<code>Ο(n log n)</code> 算法更快，因为它的内部循环<code>（inner loop）</code>可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法<code>（Divide and conquer）</code>策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>从数列中挑出一个元素，称为 “基准”（pivot），</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
</ol>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Sorting_quicksort_anim.gif" alt=""></p>
<p><strong>详细介绍</strong>：<a href="http://cricode.com/970.html" target="_blank" rel="external">快速排序</a></p>
<p>##算法二：堆排序算法</p>
<p><strong>堆排序</strong>（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序的平均时间复杂度为<code>Ο(nlogn)</code> 。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li>创建一个堆H[0..n-1]</li>
<li>把堆首（最大值）和堆尾互换</li>
<li><p>把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置</p>
</li>
<li><p>重复步骤2，直到堆的尺寸为1</p>
</li>
</ol>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Sorting_heapsort_anim.gif" alt=""></p>
<p>详细介绍：<a href="http://cricode.com/977.html" target="_blank" rel="external">堆排序</a></p>
<p>##算法三：归并排序</p>
<p><strong>归并排序</strong>（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p>
</li>
<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p>
</li>
<li><p>重复步骤3直到某一指针达到序列尾</p>
</li>
<li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p>
</li>
</ol>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Merge_sort_animation2.gif" alt=""></p>
<p>详细介绍：<a href="http://taop.marchtea.com/04.01.html" target="_blank" rel="external">归并排序</a></p>
<p>##算法四：二分查找算法</p>
<p><strong>二分查找算法</strong>是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为<code>Ο(logn)</code>。</p>
<p>详细介绍：<a href="http://taop.marchtea.com/04.01.html" target="_blank" rel="external">二分查找算法</a></p>
<p>##算法五：BFPRT(线性查找算法)</p>
<p><strong>BFPRT算法</strong>解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂度，五位算法作者做了精妙的处理。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>将n个元素每5个一组，分成n/5(上界)组。</p>
</li>
<li><p>取出每一组的中位数，任意排序方法，比如插入排序。</p>
</li>
<li><p>递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。</p>
</li>
<li><p>用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。</p>
</li>
<li><p>若i==k，返回x；若i<k，在小于x的元素中递归查找第i小的元素；若i>k，在大于x的元素中递归查找第i-k小的元素。</k，在小于x的元素中递归查找第i小的元素；若i></p>
</li>
</ol>
<p><strong>终止条件</strong>：n=1时，返回的即是i小元素。</p>
<p>详细介绍：</p>
<p><a href="http://cricode.com/968.html" target="_blank" rel="external">寻找最小(最大)的k个数</a></p>
<p><a href="http://taop.marchtea.com/02.01.html" target="_blank" rel="external">线性查找相关算法</a></p>
<p>##算法六：DFS（深度优先搜索）</p>
<p><strong>深度优先搜索算法</strong>（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS属于盲目搜索。</p>
<p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。</p>
<p><strong>深度优先遍历图算法步骤</strong>：</p>
<ol>
<li><p>访问顶点v；</p>
</li>
<li><p>依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</p>
</li>
<li><p>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</p>
</li>
</ol>
<p>上述描述可能比较抽象，举个实例：</p>
<p>DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1邻 接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，… 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。</p>
<p>接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</p>
<p>详细介绍：<a href="http://www.cnblogs.com/skywang12345/p/3711483.html" target="_blank" rel="external">深度优先搜索</a></p>
<p>##算法七：BFS(广度优先搜索)</p>
<p><strong>广度优先搜索算法</strong>（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>首先将根节点放入队列中。</p>
</li>
<li><p>从队列中取出第一个节点，并检验它是否为目标。</p>
</li>
<li><p>如果找到目标，则结束搜寻并回传结果。<br>否则将它所有尚未检验过的直接子节点加入队列中。</p>
</li>
<li><p>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</p>
</li>
<li><p>重复步骤2。</p>
</li>
</ol>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Animated_BFS.gif" alt=""></p>
<p>详细介绍：<a href="http://www.cnblogs.com/skywang12345/p/3711483.html" target="_blank" rel="external">广度优先搜索</a></p>
<p>##算法八：Dijkstra算法</p>
<p><strong>戴克斯特拉算法</strong>（Dijkstra’s algorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</p>
<p>该算法的输入包含了一个有权重的有向图 G，以及G中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中所有边的集合，而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t的最低权重路径(例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。对于不含负权的有向图，Dijkstra算法是目前已知的最快的单源最短路径算法。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>初始时令 S={V0},T={其余顶点}，T中顶点对应的距离值</p>
<ul>
<li><p>若存在<v0,vi>，d(V0,Vi)为<v0,vi>弧上的权值</v0,vi></v0,vi></p>
</li>
<li><p>若不存在<v0,vi>，d(V0,Vi)为∞</v0,vi></p>
</li>
</ul>
</li>
<li><p>从T中选取一个其距离值为最小的顶点W且不在S中，加入S</p>
</li>
<li><p>对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值</p>
</li>
</ol>
<p>重复上述步骤2、3，直到S中包含所有顶点，即W=Vi为止</p>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Dijkstra_Animation.gif" alt=""></p>
<p>详细：<a href="http://www.cnblogs.com/skywang12345/p/3711512.html" target="_blank" rel="external">Dijkstra算法</a></p>
<p>##算法九：动态规划算法</p>
<p><strong>动态规划</strong>（Dynamic programming）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<p>关于动态规划最经典的问题当属背包问题。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p>
</li>
<li><p>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>
</li>
</ol>
<p><strong>详细参考</strong>：</p>
<p><a href="http://cricode.com/1096.html" target="_blank" rel="external">从全球导航到输入法：谈谈动态规划</a></p>
<p><a href="http://hawstein.com/posts/dp-novice-to-advanced.html" target="_blank" rel="external">动态规划</a></p>
<p>##算法十：朴素贝叶斯分类算法</p>
<p>朴素贝叶斯分类算法是一种基于贝叶斯定理的简单概率分类算法。贝叶斯分类的基础是概率推理，就是在各种条件的存在不确定，仅知其出现概率的情况下，如何完成推理和决策任务。概率推理是与确定性推理相对应的。而朴素贝叶斯分类器是基于独立假设的，即假设样本每个特征与其他特征都不相关。</p>
<p>朴素贝叶斯分类器依靠精确的自然概率模型，在有监督学习的样本集中能获取得非常好的分类效果。在许多实际应用中，朴素贝叶斯模型参数估计使用最大似然估计方法，换言之朴素贝叶斯模型能工作并没有用到贝叶斯概率或者任何贝叶斯模型。</p>
<p>尽管是带着这些朴素思想和过于简单化的假设，但朴素贝叶斯分类器在很多复杂的现实情形中仍能够取得相当好的效果。</p>
<p><strong>详细参考</strong>：</p>
<p><a href="http://cricode.com/1078.html" target="_blank" rel="external">贝叶斯网络</a></p>
<p><a href="http://cricode.com/1098.html" target="_blank" rel="external">朴素贝叶斯分类算法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/27/django-session的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/27/django-session的使用/" itemprop="url">Django--session的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-27T22:00:40+08:00">
                2015-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>外面下大雨，回不去了，记录一下刚刚使用django的session遇到的一个问题。</p>
<p>想要让用户注册之后能够返回到注册之前的页面，这样就要记住之前的url，我想用session来保存url，思路是对的，但是实施的时候却总是实现不了。</p>
<p>各种assert False，还是没能看出来，没办法只能继续看文档，果然让我找到了这个</p>
<blockquote>
<p>flush()</p>
<p>Delete the current session data from the session and delete the session cookie. This is used if you want to ensure that the previous session data can’t be accessed again from the user’s browser (for example, the django.contrib.auth.logout() function calls it).</p>
</blockquote>
<p>这是session的flush方法，用来清除会话的，注意最后一句，调用auth.logout()就会自动调用flush方法，原来如此</p>
<p>我在log_in这个函数的第一句就写了<code>auth.logout(request)</code>，难怪老是在session发现不了定义的字段。</p>
<p>有困难找官方文档</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/27/python-对象的拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/27/python-对象的拷贝/" itemprop="url">python 对象的拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-27T19:12:42+08:00">
                2015-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##小例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; a.append(&apos;b&apos;)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;, &apos;b&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;, &apos;b&apos;]
</code></pre><p>可以看出，赋值号“=”是引用，即a 和 b 是指向一个对象。</p>
<p>如何实现对象的拷贝呢，python 有 copy模块。</p>
<p>##用法</p>
<pre><code>import copy
对象2 = copy.copy(对象1)
</code></pre><p>##例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = copy.copy(a)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; a.append(&apos;b&apos;)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;, &apos;b&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
</code></pre><p>##问题</p>
<pre><code>&gt;&gt;&gt; a = [[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b = copy.copy(a)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; a[1].append(&apos;c&apos;)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
&gt;&gt;&gt; a.append((3,4,5))
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], (3, 4, 5)]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
</code></pre><p> 可以看出：copy 可以实现浅层拷贝，可以通过copy.deepcoppy(）来实现深层拷贝。</p>
<p>##深拷贝</p>
<pre><code>&gt;&gt;&gt; a = [[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b = copy.deepcopy(a)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; a[1].append(&apos;hello&apos;)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;hello&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
</code></pre><p>##对象三要素</p>
<p>python中的对象包含三要素:id, type, value</p>
<ol>
<li>id 用来标识唯一一个对象</li>
<li>type标识对象的类型</li>
<li>value用来设置对象的值。</li>
</ol>
<p><code>is</code> 判断是否是一个对象，是使用id来判断的。</p>
<p><code>==</code> 是判断a对象的值是否是b对象的值，默认调用它的<code>__eq__</code>方法。</p>
<p>###例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; c = copy.copy(a)
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; a is c
False
</code></pre><p><code>&quot;b  = a&quot;</code> 是引用 指向的一个对象，所以<code>a is b</code> 返回 True</p>
<p><code>&quot;c = copy.copy(a)&quot;</code>  c是a的拷贝，不是指向一个对象，返回False </p>
<pre><code>&gt;&gt;&gt; a == c
True
</code></pre><p>但是他们的值确实是相同的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/27/CGI和WSGI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/27/CGI和WSGI/" itemprop="url">CGI和WSGI</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-27T08:50:26+08:00">
                2015-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我对 CGI 的理解是利用程序的标准输入输出流，完成 HTTP 通信。HTTP 是文本协议，每次请求的文本以标准输入流的形式进入服务器端 CGI 程序，创建进程；然后进程的标准输出流作为响应 。</p>
<p>WSGI 和 CGI 原理极其相似，但是是完全不同的实现。WSGI 是 Python 专用的协议，也是输入&amp;输出的方式传输文本流，但不是创建进程，而是对一个 WSGI 程序（callable 的对象，可以是函数也可以是实现了 <strong>call</strong> 的对象），将 request 作为参数传入（不再是纯文本，而是经过包装），同样将经过包装的 response 作为响应返回。request/response 的包装由 Python 标准库提供。</p>
<p>二者都是标准，都有诸多实现。CGI 最为广泛，无论是二进制程序、perl 脚本、python 脚本还是 PHP 都可以以这样的原理提供 HTTP 服务；WSGI 在 Python 界也是公共标准，主流 Web 框架基本都有实现，例如 Bottle 的 bottle.Bottle （Application 对象）就实现了 WSGI 协议（见 <strong>call</strong> 方法）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/26/django的QuerySets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/26/django的QuerySets/" itemprop="url">Django的QuerySets</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-26T18:53:25+08:00">
                2015-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对象关系映射 (ORM) 使得与SQL数据库交互更为简单，不过也被认为效率不高，比原始的SQL要慢。<br>要有效的使用ORM，意味着需要多少要明白它是如何查询数据库的。本文我将重点介绍如何有效使用 <a href="https://docs.djangoproject.com/en/dev/topics/db/models/" target="_blank" rel="external">Django ORM</a>系统访问中到大型的数据集。</p>
<p>##Django的queryset是惰性的</p>
<p><strong>Django的queryset对应于数据库的若干记录（row）</strong>，通过可选的查询来过滤。例如，下面的代码会得到数据库中名字为‘Dave’的所有的人:<br>?</p>
<pre><code>person_set = Person.objects.filter(first_name=&quot;Dave&quot;)
</code></pre><p>上面的代码并没有运行任何的数据库查询。你可以使用person_set，给它加上一些过滤条件，或者将它传给某个函数，这些操作都不会发送给数据库。这是对的，因为数据库查询是显著影响web应用性能的因素之一。<br>要真正从数据库获得数据，你需要遍历queryset:<br>?</p>
<pre><code>for person in person_set:
    print(person.last_name)
</code></pre><p>##Django的queryset是具有cache的</p>
<p>当你遍历queryset时，所有匹配的记录会从数据库获取，然后转换成Django的model。这被称为<code>执行</code>（evaluation）。这些model会保存在queryset内置的cache中，这样如果你再次遍历这个queryset，你不需要重复运行通用的查询。<br>例如，下面的代码只会执行一次数据库查询：</p>
<pre><code>pet_set = Pet.objects.filter(species=&quot;Dog&quot;)
# The query is executed and cached.
for pet in pet_set:
    print(pet.first_name)
# The cache is used for subsequent iteration.
for pet in pet_set:
    print(pet.last_name)
</code></pre><p>##if语句会触发queryset的执行</p>
<p>queryset的cache最有用的地方是可以有效的测试queryset是否包含数据，只有有数据时才会去遍历：</p>
<pre><code>restaurant_set = Restaurant.objects.filter(cuisine=&quot;Indian&quot;)
# `if`语句会触发queryset的执行。
if restaurant_set:
    # 遍历时用的是cache中的数据
    for restaurant in restaurant_set:
        print(restaurant.name)
</code></pre><p>##QuerySet的常用API</p>
<p>###去重<br>distinct方法的作用和SQL的distinct的作用是一样的，这里就不多说了</p>
<pre><code>Author.objects.distinct()
</code></pre><p>###序列化为JSON<br>和前端进行交互的时候，序列化成XML的情况还是比较少的，但是序列化成JSON格式的字符串的情况就比较多了，Django的ORM框架提供了values的方法来把实体序列化成json</p>
<pre><code>Blog.objects.values()
</code></pre><p>###序列化成数组<br>把对象序列化成数组元素的情况还真的是用的比较少</p>
<pre><code>Entry.objects.values_list(&apos;id&apos;, &apos;headline&apos;)
</code></pre><p>###从主表获取外键表的对象<br>在主表的实体上使用filter，然后再通过主表的实体获取外键的时候，Django会把主表的实体一并查询出来。但是有时候我们只希望从主表开始取数，但是只取外键表实体的信息，这个时候就可以用select_related方法了。第一个参数是主表的外键字段名称，第二个字段嘛。。。照抄就是了</p>
<pre><code>g = Group.objects.select_related(&apos;room&apos;, &apos;subject&apos;)
</code></pre><p>当然，也会有只希望拿主表信息，不想把外键字段取回来的情况，把参数设置为none就好了</p>
<pre><code>without_relations = queryset.select_related(None)
</code></pre><p>###处理从表对象<br>对于外键表来说，我们可以采用select_related的方法来进行处理。但是对于从表属性来说，就要用到另外一种方法了。（toppings是多对多的属性）</p>
<pre><code>Pizza.objects.all().prefetch_related(&apos;toppings&apos;)
</code></pre><p>同样的，不获取外键对象的话把参数设置为none就好了</p>
<pre><code>non_prefetched = qs.prefetch_related(None)
</code></pre><p>###ORM和SQL的混合：Extra方法<br>先看看Extra方法的一些例子</p>
<p>####selec参数<br>    Entry.objects.extra(select={‘is_recent’: “pub_date &gt; ‘2006-01-01’”})</p>
<p>####where参数<br>    Entry.objects.extra(where=[“foo=’a’ OR bar = ‘a’”, “baz = ‘a’”])</p>
<p>####order_by参数<br>    q = q.extra(order_by = [‘-is_recent’])</p>
<p>####paramas参数<br>    Entry.objects.extra(where=[‘headline=%s’], params=[‘Lennon’])<br>其实从官方给的例子看起来，Extra方法主要就是用于在ORM生成SQL的过程中内嵌SQL语句。例如希望在select 背后加入一句sql，例如select …,(select a from …)这种情况下的时候，用Extra方法就很好解决了</p>
<p>###使用Defer和Only来过滤字段<br>select_related和prefetch_related方法分别用来过滤实体的外键属性和多对多属性，对于主表的字段属性过滤可以采用defer方法来少查询一些字段</p>
<pre><code>Entry.objects.defer(&quot;headline&quot;, &quot;body&quot;)
</code></pre><p>defer是排除哪些字段，而only是只查询哪些字段</p>
<pre><code>Person.objects.only(&quot;name&quot;)
</code></pre><p>###使用select_for_update来简化更新的过程<br>一般更新实体的时候，我们需要先把实体先查询出来，然后做出相应的更新，再做一次save操作</p>
<pre><code>entity=Entry.objects.filter(...)[0]
entity.name=xx
entity.save()
</code></pre><p>这个过程显得稍微有点繁琐，所以可以采用一种select_for_update来进行一些简化</p>
<pre><code>entries = Entry.objects.select_for_update().filter(author=request.user)
</code></pre><p>###使用get_or_create来简化创建对象的过程<br>同样的，有时候我们会需要先查询对象在不在数据库里面存储，假如没有的话就创建，有的话就取出</p>
<pre><code>obj, created = Person.objects.get_or_create(first_name=&apos;John&apos;, last_name=&apos;Lennon&apos;,
              defaults={&apos;birthday&apos;: date(1940, 10, 9)})
</code></pre><p>不过个人觉得这个方法用到的情况很少。。。。</p>
<p>###批量插入数据<br>    Entry.objects.bulk_create([<br>        Entry(headline=”Django 1.0 Released”),<br>        Entry(headline=”Django 1.1 Announced”),<br>        Entry(headline=”Breaking: Django is awesome”)<br>      ])<br>这玩意真的挺有用，具体的就不细说了</p>
<p>###使用Count方法来进行统计<br>虽然做统计的话可以先把过滤完的对象查询出来，然后再len(xx)一下，但是这种做法会把数据库里面一堆一堆的暑假都查出来的(￣◇￣;)，所以当需要做count操作的时候还是老老实实的用sql的count语句，在Django里面的话做法如下</p>
<pre><code>Entry.objects.filter(headline__contains=&apos;Lennon&apos;).count()
</code></pre><p>###判断数据是否存在:exists<br>    rs=some_queryset.filter(pk=entry.pk).exists()</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/22/No-handlers-could-be-found-for-logger-keystoneclient-httpclient/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/22/No-handlers-could-be-found-for-logger-keystoneclient-httpclient/" itemprop="url">No handlers could be found for logger keystoneclient.httpclient</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-22T15:59:05+08:00">
                2015-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/openstack/" itemprop="url" rel="index">
                    <span itemprop="name">openstack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天研究keystone的admin-url和public-url的问题，就把keystone的endpoint删掉了，再创建endpoint的时候就出现了这个错误，试着敲别的命令，发现也不能正常工作。</p>
<p>如果你按照官方文档完整装过机的话，应该马上能定位到问题，但是苦逼的我并没有啊，在网上找到都是什么driver和添加环境变量的解决方法，根本没用。实在没办法，我就重装了一遍keystone，最后让我发现了问题所在。</p>
<p>我们装keystone的时候，在创建service和endpoint之前，是需要导出<code>OS_SERVICE_TOKEN</code>和<code>OS_SERVICE_ENDPOINT</code>这两个环境变量的,这两个环境变量的值其实就临时充当了我们将要创建的service和endpoint，为什么是临时呢，因为export的环境变量在你关闭当前窗口之后就消失了，所以在导出了这两个环境变量之后我们需要立即创建service和endpoint。大家明白了吧，如果你遇到了这个错误，将这辆个环境变量导出就行了</p>
<pre><code>export OS_SERVICE_TOKEN=ADMIN_TOKEN(和keystone.cfg中的admin_token值相同)
export OS_SERVICE_ENDPOINT=http://controller:35357/v2.0
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/17/python去字典值的正确方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/17/python去字典值的正确方法/" itemprop="url">python取字典值的正确方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-17T13:29:57+08:00">
                2015-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>直接贴代码，代码用的是django的HttpRequest类的META属性，META是一个字典，key是http请求头的一些内容</p>
<pre><code># BAD!    
def ua_display_bad(request):
    ua = request.META[&apos;HTTP_USER_AGENT&apos;]  # Might raise KeyError!
    return HttpResponse(&quot;Your browser is %s&quot; % ua)

# GOOD (VERSION 1)
def ua_display_good1(request):
    try:
        ua = request.META[&apos;HTTP_USER_AGENT&apos;]
    except KeyError:
        ua = &apos;unknown&apos;
    return HttpResponse(&quot;Your browser is %s&quot; % ua)

# GOOD (VERSION 2)
def ua_display_good2(request):
    #key不存在，则用第二个参数赋值
    ua = request.META.get(&apos;HTTP_USER_AGENT&apos;, &apos;unknown&apos;)
    return HttpResponse(&quot;Your browser is %s&quot; % ua)
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/16/django-admin自定义字段标签/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/16/django-admin自定义字段标签/" itemprop="url">Django--admin自定义字段标签</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-16T21:40:45+08:00">
                2015-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在编辑页面中，每个字段的标签都是从模块的字段名称生成的。 规则很简单： 用空格替换下划线；首字母大写。例如：Book模块中publication_date的标签是Publication date。</p>
<p>然而，字段名称并不总是贴切的。有些情况下，你可能想自定义一个标签。 你只需在模块中指定verbose_name。</p>
<p>举个例子，说明如何将Author.email的标签改为e-mail，中间有个横线。</p>
<pre><code>class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField(blank=True, verbose_name=&apos;e-mail&apos; )
</code></pre><p>修改后重启服务器，你会在author编辑页面中看到这个新标签。</p>
<p><strong>请注意，你不必把<code>verbose_name</code>的首字母大写，除非是连续大写（如：”USA state”）。Django会自动适时将首字母大写，并且在其它不需要大写的地方使用<code>verbose_name</code>的精确值。</strong></p>
<p>最后还需注意的是，为了使语法简洁，你可以把它当作固定位置的参数传递。 这个例子与上面那个的效果相同。</p>
<pre><code>class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField(&apos;e-mail&apos;,  blank=True)
</code></pre><p>但这不适用于ManyToManyField 和ForeignKey字段，因为它们第一个参数必须是模块类。 那种情形，必须显式使用<code>verbose_name</code>这个参数名称。</p>
<p>–《the Django book 第六章 admin》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/16/django-admin设置字段可选/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/16/django-admin设置字段可选/" itemprop="url">Django--admin设置字段可选</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-16T21:39:50+08:00">
                2015-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>你或许会发现管理工具有个限制：编辑表单需要你填写每一个字段，然而在有些情况下，你想要某些字段是可选的。 举个例子，我们想要Author模块中的email字段成为可选，即<strong>允许不填</strong>。 在现实世界中，你可能没有为每个作者登记邮箱地址。</p>
<p>为了指定email字段为可选，你只要编辑Book模块（回想第五章，它在mysite/books/models.py文件里），在email字段上加上blank=True。代码如下：</p>
<pre><code>class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField(**blank=True** )
</code></pre><p>这些代码告诉Django，作者的邮箱地址允许输入一个空值。 所有字段都默认blank=False，这使得它们不允许输入空值。</p>
<p>这里会发生一些有趣的事情。 直到现在，除了<strong>unicode</strong>()方法，我们的模块充当数据库中表定义的角色，即本质上是用Python的语法来写CREATE TABLE语句。 在添加blank=True过程中，我们已经开始在简单的定义数据表上扩展我们的模块了。 现在，我们的模块类开始成为一个富含Author对象属性和行为的集合了。 email不但展现为一个数据库中的VARCHAR类型的字段，它还是页面中可选的字段，就像在管理工具中看到的那样。</p>
<p>当你添加blank=True以后，刷新页面<code>Add author edit form (http://127.0.0.1:8000/admin/books/author/add/ )</code>，将会发现Email的标签不再是粗体了。 这意味它不是一个必填字段。 现在你可以添加一个作者而不必输入邮箱地址，即使你为这个字段提交了一个空值，也再不会得到那刺眼的红色信息<code>“This field is required”</code>。</p>
<p>##设置日期型和数字型字段可选</p>
<p>虽然<code>blank=True</code>同样适用于日期型和数字型字段，但是这里需要详细讲解一些背景知识。</p>
<blockquote>
<p>SQL有指定空值的独特方式，它把空值叫做NULL。NULL可以表示为未知的、非法的、或其它程序指定的含义。</p>
<p>在SQL中， NULL的值不同于空字符串，就像Python中None不同于空字符串（””）一样。这意味着某个字符型字段（如VARCHAR）的值不可能同时包含NULL和空字符串。</p>
<p>这会引起不必要的歧义或疑惑。 为什么这条记录有个NULL，而那条记录却有个空字符串？ 它们之间有区别，还是数据输入不一致？ 还有： 我怎样才能得到全部拥有空值的记录，应该按NULL和空字符串查找么？还是仅按字符串查找？</p>
</blockquote>
<p>为了消除歧义，Django生成CREATE TABLE语句自动为每个字段显式加上NOT NULL。 这里有个第五章中生成Author模块的例子：</p>
<pre><code>CREATE TABLE &quot;books_author&quot; (
    &quot;id&quot; serial NOT NULL PRIMARY KEY,
    &quot;first_name&quot; varchar(30) NOT NULL,
    &quot;last_name&quot; varchar(40) NOT NULL,
    &quot;email&quot; varchar(75) NOT NULL
)
</code></pre><p>在大多数情况下，这种默认的行为对你的应用程序来说是最佳的，因为它可以使你不再因数据一致性而头痛。 而且它可以和Django的其它部分工作得很好。如在管理工具中，如果你留空一个字符型字段，它会为此插入一个空字符串（而<code>&#39;&#39;</code>不是<code>NULL</code>）。</p>
<p><strong>但是</strong>，其它数据类型有例外：日期型、时间型和数字型字段不接受空字符串。 如果你尝试将一个空字符串插入日期型或整数型字段，你可能会得到数据库返回的错误，这取决于那个数据库的类型。 （PostgreSQL比较严禁，会抛出一个异常；MySQL可能会也可能不会接受，这取决于你使用的版本和运气了。）在这种情况下，NULL是唯一指定空值的方法。 在Django模块中，<strong>你可以通过添加null=True来指定一个字段允许为NULL</strong>。</p>
<p>因此，这说起来有点复杂： <strong>如果你想允许一个日期型（DateField、TimeField、DateTimeField）或数字型（IntegerField、DecimalField、FloatField）字段为空，你需要使用null=True 和 blank=True。</strong></p>
<p>为了举例说明，让我们把Book模块修改成允许 publication_date为空。修改后的代码如下：</p>
<pre><code>class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField(blank=True, null=True )
</code></pre><p>添加<code>null=True</code>比添加<code>blank=True</code>复杂。因为<code>null=True</code>改变了数据的语义，即改变了<code>CREATE TABLE</code>语句，把<code>publication_date</code>字段上的<code>NOT NULL</code>删除了。 要完成这些改动，我们还需要更新数据库。</p>
<p>出于某种原因，Django不会尝试自动更新数据库结构。所以你必须执行ALTER TABLE语句将模块的改动更新至数据库。 像先前那样，你可以使用manage.py dbshell进入数据库服务环境。 以下是在这个特殊情况下如何删除NOT NULL:</p>
<pre><code>ALTER TABLE books_book ALTER COLUMN publication_date DROP NOT NULL;
</code></pre><p>– 《the Django book 第六章 admin》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/16/一些pythonic代码的例子/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/16/一些pythonic代码的例子/" itemprop="url">一些pythonic代码的例子</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-16T20:53:22+08:00">
                2015-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##百分号的使用：<br>通常我们都是这样格式化字符串的:</p>
<pre><code>print &apos;hello world programme by %s&apos; % &apos;python&apos;  
</code></pre><p> 但是如果格式化的字符串中有很多%s,那么程序的可读性就会依靠于%后面 的变量名起得是否好了。</p>
<p>这个时候有一种用dict来格式化的%，我觉得很有用，尤其是在记log的 时候，作为log的格式，可读性非常高。<br>代码如下：</p>
<pre><code>#字符串  
value = {&apos;what&apos;: &apos;hello, world&apos;, &apos;language&apos;: &apos;python&apos;}  
print &apos;%(what)s, %(language)s&apos; % value  
#也可以包含int的  
value = {&apos;name&apos;: &apos;jianpx&apos;, &apos;age&apos;: 23}  
print &apos;%(name)s &apos;s age is  %(age)i&apos; % value
</code></pre><h2 id="用两个元素之间有对应关系的list构造一个dict："><a href="#用两个元素之间有对应关系的list构造一个dict：" class="headerlink" title="用两个元素之间有对应关系的list构造一个dict："></a>用两个元素之间有对应关系的list构造一个dict：</h2><p>运用zip可以非常简单的实现：</p>
<pre><code>names = [&apos;jianpx&apos;, &apos;yue&apos;]  
ages = [23, 40]  
m = dict(zip(names,ages))  
</code></pre><p> zip的使用可以help(zip)或者查看官方文档。</p>
<p>##交换两个值：<br>在其他语言可能要一个临时变量和三句话：</p>
<pre><code>temp = a
a = b
b = temp
</code></pre><p>但是在python，一句就ok了，而且不需要临时变量：</p>
<pre><code>a,b = b,a
</code></pre><p>右边的b,a 其实可以理解成一个tuple。</p>
<p>##数量多的字符串相连用join：<br>python字符串效率问题之一就是在连接字符串的时候使用‘+’号，例如 <code>s = &#39;s1&#39; + &#39;s2&#39; + &#39;s3&#39; + ...+&#39;sN&#39;</code>，总共将N个字符串连接起来，但是使用+号的话，python需要申请N-1次内存空间，然后进行字符串拷贝。原因是字符串对象<code>PyStringObject</code>在python当中是<strong>不可变对象</strong>，所以每当需要合并两个字符串的时候，就要重新申请一个新的内存空间（大小为两个字符串长度之和）来给这个合并之后的新字符串，然后进行拷贝。所以用+号效率非常低。建议在连接字符串的时候使用字符串本身的方法<code>join（list）</code>，这个方法能提高效率，原因是它只是申请了一次内存空间，因为它可以遍历list中的元素计算出总共需要申请的内存空间的大小，一次申请完。所以上面的例子可以写成<code>s = &#39;&#39;.join([&#39;s1&#39;,&#39;s2&#39;,....,&#39;sN&#39;])</code></p>
<p>例子是：</p>
<pre><code>#以前是这样写的  
fruits = [&apos;apple&apos;, &apos;banana&apos;]  
result = &apos;&apos;  
for f in fruits:  
    result += f  

#现在可以这样：  
fruits = [&apos;apple&apos;, &apos;banana&apos;]  
result = &apos;&apos;.join(fruits)  
</code></pre><p>##判断一个key是否在一个dict里面：<br>以前很经常犯的一个<strong>mistake</strong>是这样做：</p>
<pre><code>if key in dict_example:  
    do something  
</code></pre><p> 现在要这样写，就不用使用in操作了。</p>
<pre><code>if dict_example.has_key(key):  
    do something  
</code></pre><p>##去掉list中的重复元素：</p>
<pre><code>old_list = [1,1,1,3,4]  
new_list = list(set(old_list))  
</code></pre><p>##判断元素是否在列表中<br>如果对没有重复元素的列表对象，要判断某个元素是否在列表里面的话，当这个列表很大的时候，用set会比list<br>的性能要好，因为对于list，本身允许重复元素存在，所以它不是用hash实现的，但是set不一样，它不允许重复元素，看了python源代码，从set的实现源码setobject.c 中查找key的函数</p>
<pre><code>static setentry *
set_lookkey(PySetObject *so, PyObject *key, register long hash)    
</code></pre><p>的接口可以看出它真的使用hash去实现的。</p>
<p>所以对于in操作，set的实现是计算这个元素的hash值然后判断，理论上可以达到O(1)</p>
<p>##读文件操作：<br>    以前是这样写的：</p>
<pre><code>#默认文件存在，不处理Exception的情况  
f = open(&apos;filename&apos;, &apos;r&apos;)  
while 1:  
    line = f.readline()  
    if not line:  
        break  
    print line  

if f:  
    f.close()  
</code></pre><p>用with关键字可以这样简写了，</p>
<pre><code>from __future__ import with_statement  
with open(&apos;filename&apos;,&apos;r&apos;) as f:  
    for line in f:  
        print line  
</code></pre><p>具体关于with的可以参考<a href="http://jianpx.iteye.com/blog/505469" target="_blank" rel="external">这篇文章</a></p>
<p>##输出数组的index和值：<br>以前是要这样写的：</p>
<pre><code>l = [1,3,4]  
for i in xrange(len(l)):  
    print &apos;%d, %d&apos; % (i , l[i])  
</code></pre><p>现在可以用<strong>enumerate</strong>函数帮助你简写：</p>
<pre><code>l = [1,3, 4]  
for index, value in enumerate(l):  
    print &apos;%d, %d&apos; % (index, value)  
</code></pre><p>##关于使用map、filter、reduce的例子网上很多，这里不细说了，它们的使用也是pythonic的examples</p>
<p>##分隔一个字符串，去里面的元素<code>，</code>,但是空白字符串不要：<br>例如， names = ‘jianpx, yy, mm, , kk’</p>
<pre><code>names = &apos;jianpx, mm, yy, , kk&apos;  
name_list = names.split(&apos;,&apos;)  
result = []  
for name in name_list:  
    if name:  
        result.append(name)  
</code></pre><p>现在是这样写的：</p>
<pre><code>names = &apos;jianpx, yy, mm, , kk&apos;  
result = [name for name in names.split(&apos;,&apos;) if name.strip()]  
</code></pre><p>##模拟c语言中的  a?b:c<br>在python里面可以这样做：</p>
<pre><code>return_value = True if a == 1 else False  
</code></pre><p> 从而代替了这样的代码：</p>
<pre><code>if a == 1:  
    return_value = True  
else   
    return_value = False  
</code></pre><p>##用Decorator抽离公用代码或者解耦<br>例如要对一个函数做cache，对一个操作限制权限，如果需求随时可能变化，就是说有可能不需要做cache或者不需要做权限的时候，你如果把实现放到这些函数体里面，那么这时你必须把这些代码删除，而且要很小心。但是如果你用Decorator去做的话， 只要删除函数头顶上的@那一行就可以了。Django经常用这种方法做权限控制。<br>熟悉decorator的应该都很容易理解。</p>
<p>##如何将list的元素倒序并且生成到新的list呢？ </p>
<p>看到一个用list的slice做到的 :</p>
<pre><code>a = [1,2,3,4]  
c = &apos;abcdef&apos;  
aa= a[::-1]  
cc = c[::-1]  
</code></pre><p> 如果不用生成新的list，直接调用a.reverse()就得了。但是字符串类型没有reverse的方法.</p>
<p>关于list的slice特性， 其实也许很多人平时只是用list[start:end] 这样的， 这个意思是从start开始，每个元素都放到新的list里面， 直到end。但是其实还可以每隔N个元素才取一次的， 这种情况要3个参数:<code>·list[start:end:step]</code>，<code>step</code>就是间隔了。</p>
<p>##a = [i for i in xrange(5)]   和  a = (i for i in xrange(5)) </p>
<p>虽然看上去是一样都生成了5个元素，但是<br>前者是一个list对象， 如果遍历的话 <code>for item in a</code> 就会一下子返回全部元素然后再遍历， 而后者是个Generator，<br>用for item in a遍历是每次只是返回一个元素， 这样的好处是省内存（在list很大的情况下）。</p>
<p>##python的all函数可以简化逻辑表达式有很多”与“的时候的写法<br>比如：</p>
<pre><code>a, b, c = True, False, True
if a and b and c:
    return True
else:
    return False
可以简化成:
    return all([a, b, c])
</code></pre><p>由此可以看到all函数的作用是判断当且仅当参数里面都为真的时候返回真， 否则返回假。</p>
<p>但是这里更深入的话涉及all的判断顺序和传入的参数是list还是iterable对象是不同的。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">209</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
