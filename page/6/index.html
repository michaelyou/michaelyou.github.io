<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/img/lufei.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/08/python线程初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/08/python线程初探/" itemprop="url">python线程初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-08T11:22:20+08:00">
                2015-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们将会看到一些在Python中使用线程的实例和如何避免线程之间的竞争。你应当将下边的例子运行多次，以便可以注意到线程是不可预测的和线程每次运行出的不同结果。声明：从这里开始忘掉你听到过的关于GIL的东西，因为GIL不会影响到我想要展示的东西。</p>
<p>##示例1</p>
<p>我们将要请求五个不同的url：</p>
<p>单线程</p>
<pre><code>import time
import urllib2

def get_responses():
    urls = [
        &apos;http://www.google.com&apos;,
        &apos;http://www.amazon.com&apos;,
        &apos;http://www.ebay.com&apos;,
        &apos;http://www.alibaba.com&apos;,
        &apos;http://www.reddit.com&apos;
    ]
    start = time.time()
    for url in urls:
        print url
        resp = urllib2.urlopen(url)
        print resp.getcode()
    print &quot;Elapsed time: %s&quot; % (time.time()-start)

get_responses()
</code></pre><p>输出是：</p>
<pre><code>http://www.google.com 200
http://www.amazon.com 200
http://www.ebay.com 200
http://www.alibaba.com 200
http://www.reddit.com 200
Elapsed time: 3.0814409256
</code></pre><p>解释：</p>
<ul>
<li>url顺序的被请求</li>
<li>除非cpu从一个url获得了回应，否则不会去请求下一个url</li>
<li>网络请求会花费较长的时间，所以cpu在等待网络请求的返回时间内一直处于闲置状态。<br>##多线程</li>
</ul>
<pre><code>import urllib2
import time
from threading import Thread

class GetUrlThread(Thread):
    def __init__(self, url):
        self.url = url 
        super(GetUrlThread, self).__init__()

    def run(self):
        resp = urllib2.urlopen(self.url)
        print self.url, resp.getcode()

def get_responses():
    urls = [
        &apos;http://www.google.com&apos;, 
        &apos;http://www.amazon.com&apos;, 
        &apos;http://www.ebay.com&apos;, 
        &apos;http://www.alibaba.com&apos;, 
        &apos;http://www.reddit.com&apos;
    ]
    start = time.time()
    threads = []
    for url in urls:
        t = GetUrlThread(url)
        threads.append(t)
        t.start()
    for t in threads:
        t.join()
    print &quot;Elapsed time: %s&quot; % (time.time()-start)

get_responses()
</code></pre><p>输出：</p>
<pre><code>http://www.reddit.com 200
http://www.google.com 200
http://www.amazon.com 200
http://www.alibaba.com 200
http://www.ebay.com 200
Elapsed time: 0.689890861511
</code></pre><p>解释：</p>
<ul>
<li>意识到了程序在执行时间上的提升</li>
<li>我们写了一个多线程程序来减少cpu的等待时间，当我们在等待一个线程内的网络请求返回时，这时cpu可以切换到其他线程去进行其他线程内的网络请求。</li>
<li>我们期望一个线程处理一个url，所以实例化线程类的时候我们传了一个url。</li>
<li>线程运行意味着执行类里的run()方法。</li>
<li>无论如何我们想每个线程必须执行run()。</li>
<li>为每个url创建一个线程并且调用start()方法，这告诉了cpu可以执行线程中的run()方法了。</li>
<li>我们希望所有的线程执行完毕的时候再计算花费的时间，所以调用了join()方法。</li>
<li>join()可以通知主线程等待这个线程结束后，才可以执行下一条指令。</li>
<li>每个线程我们都调用了join()方法，所以我们是在所有线程执行完毕后计算的运行时间。</li>
</ul>
<p>关于线程：</p>
<ul>
<li>cpu可能不会在调用start()后马上执行run()方法。</li>
<li>你不能确定run()在不同线程建间的执行顺序。</li>
<li>对于单独的一个线程，可以保证run()方法里的语句是按照顺序执行的。</li>
<li>这就是因为线程内的url会首先被请求，然后打印出返回的结果。<br>##示例2<br>我们将会用一个程序演示一下多线程间的资源竞争，并修复这个问题。</li>
</ul>
<pre><code>from threading import Thread

#define a global variable
some_var = 0

class IncrementThread(Thread):
    def run(self):
        #we want to read a global variable
        #and then increment it
        global some_var
        read_value = some_var
        print &quot;some_var in %s is %d&quot; % (self.name, read_value)
        some_var = read_value + 1
        print &quot;some_var in %s after increment is %d&quot; % (self.name, some_var)

def use_increment_thread():
    threads = []
    for i in range(50):
        t = IncrementThread()
        threads.append(t)
        t.start()
    for t in threads:
        t.join()
    print &quot;After 50 modifications, some_var should have become 50&quot;
    print &quot;After 50 modifications, some_var is %d&quot; % (some_var,)

use_increment_thread()
</code></pre><p>多次运行这个程序，你会看到多种不同的结果。</p>
<p>解释：</p>
<ul>
<li>有一个全局变量，所有的线程都想修改它。</li>
<li>所有的线程应该在这个全局变量上加 1 。</li>
<li><p>有50个线程，最后这个数值应该变成50，但是它却没有。<br>为什么没有达到50？</p>
</li>
<li><p>在some_var是15的时候，线程t1读取了some_var，这个时刻cpu将控制权给了另一个线程t2。</p>
</li>
<li>t2线程读到的some_var也是15</li>
<li>t1和t2都把some_var加到16</li>
<li>当时我们期望的是t1 t2两个线程使some_var + 2变成17</li>
<li>在这里就有了资源竞争。</li>
<li>相同的情况也可能发生在其它的线程间，所以出现了最后的结果小于50的情况。</li>
</ul>
<p>解决资源竞争</p>
<pre><code>from threading import Lock, Thread
lock = Lock()
some_var = 0

class IncrementThread(Thread):
    def run(self):
        #we want to read a global variable
        #and then increment it
        global some_var
        lock.acquire()
        read_value = some_var
        print &quot;some_var in %s is %d&quot; % (self.name, read_value)
        some_var = read_value + 1
        print &quot;some_var in %s after increment is %d&quot; % (self.name, some_var)
        lock.release()

def use_increment_thread():
    threads = []
    for i in range(50):
        t = IncrementThread()
        threads.append(t)
        t.start()
    for t in threads:
        t.join()
    print &quot;After 50 modifications, some_var should have become 50&quot;
    print &quot;After 50 modifications, some_var is %d&quot; % (some_var,)

use_increment_thread()
</code></pre><p>再次运行这个程序，达到了我们预期的结果。</p>
<p>解释：</p>
<ul>
<li>Lock 用来防止竞争条件</li>
<li>如果在执行一些操作之前，线程t1获得了锁。其他的线程在t1释放Lock之前，不会执行相同的操作</li>
<li>我们想要确定的是一旦线程t1已经读取了some_var，直到t1完成了修改some_var，其他的线程才可以读取some_var</li>
<li>这样读取和修改some_var成了逻辑上的原子操作。<br>##示例3<br>让我们用一个例子来证明一个线程不能影响其他线程内的变量（非全局变量）。</li>
</ul>
<p>time.sleep()可以使一个线程挂起，强制线程切换发生。</p>
<pre><code>from threading import Thread
import time

class CreateListThread(Thread):
    def run(self):
        self.entries = []
        for i in range(10):
            time.sleep(1)
            self.entries.append(i)
        print self.entries

def use_create_list_thread():
    for i in range(3):
        t = CreateListThread()
        t.start()

use_create_list_thread()
</code></pre><p>运行几次后发现并没有打印出正确的结果。当一个线程正在打印的时候，cpu切换到了另一个线程，所以产生了不正确的结果。我们需要确保print self.entries是个逻辑上的原子操作，以防打印时被其他线程打断。</p>
<p>我们使用了Lock()，来看下边的例子。</p>
<pre><code>from threading import Thread, Lock
import time

lock = Lock()

class CreateListThread(Thread):
    def run(self):
        self.entries = []
        for i in range(10):
            time.sleep(1)
            self.entries.append(i)
        lock.acquire()
        print self.entries
        lock.release()

def use_create_list_thread():
    for i in range(3):
        t = CreateListThread()
        t.start()

use_create_list_thread()
</code></pre><p>这次我们看到了正确的结果。证明了一个线程不可以修改其他线程内部的变量（非全局变量）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/08/python程序员长常犯的错误-高级篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/08/python程序员长常犯的错误-高级篇/" itemprop="url">python程序员长常犯的错误-高级篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-08T10:50:11+08:00">
                2015-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文转载自<a href="http://blog.jobbole.com/68256/" target="_blank" rel="external">这里</a></p>
<p>Python简单、易学的语法可能会误导一些Python程序员（特别是那些刚接触这门语言的人们），可能会忽略某些细微之处和这门语言的强大之处。</p>
<p>考虑到这点，本文列出了“十大”甚至是高级的Python程序员都可能犯的，却又不容易发现的细微错误。</p>
<p>##在函数参数中乱用表达式作为默认值</p>
<p>Python允许给一个函数的某个参数设置<strong>默认值</strong>以使该参数成为一个<strong>可选参数</strong>。尽管这是这门语言很棒的一个功能，但是这当这个默认值是<strong>可变对象</strong>（<a href="https://docs.python.org/2/reference/datamodel.html" target="_blank" rel="external">mutable</a>）时，那就有些麻烦了。例如，看下面这个Python函数定义：</p>
<pre><code>&gt;&gt;&gt; def foo(bar=[]):        # bar是可选参数，如果没有指明的话，默认值是[]
...    bar.append(&quot;baz&quot;)    # 但是这行可是有问题的，走着瞧…
...    return bar
</code></pre><p>人们常犯的一个错误是认为<strong>每次</strong>调用这个函数时不给这个可选参数赋值的话，它总是会被赋予这个默认表达式的值。例如，在上面的代码中，程序员可能会认为重复调用函数foo() （不传参数bar给这个函数），这个函数会总是返回‘baz’，因为我们假定认为每次调用foo()的时候（不传bar），参数bar会被置为[]（即，一个空的列表）。</p>
<p>那么我们来看看这么做的时候究竟会发生什么：</p>
<pre><code>&gt;&gt;&gt; foo()
[&quot;baz&quot;]
&gt;&gt;&gt; foo()
[&quot;baz&quot;, &quot;baz&quot;]
&gt;&gt;&gt; foo()
[&quot;baz&quot;, &quot;baz&quot;, &quot;baz&quot;]
</code></pre><p>嗯？为什么每次调用foo()的时候，这个函数总是在一个已经存在的列表后面添加我们的默认值“baz”，而不是每次都创建一个<strong>新</strong>的列表？</p>
<p>答案是<strong>一个函数参数的默认值，仅仅在该函数定义的时候，被赋值一次</strong>。如此，只有当函数foo()第一次被定义的时候，才讲参数bar的默认值初始化到它的默认值（即一个空的列表）。当调用foo()的时候（不给参数bar），会继续使用bar最早初始化时的那个列表。</p>
<p>由此，可以有如下的解决办法：</p>
<pre><code>&gt;&gt;&gt; def foo(bar=None):
...    if bar is None:      # 或者用 if not bar:
...        bar = []
...    bar.append(&quot;baz&quot;)
...    return bar
...
&gt;&gt;&gt; foo()
[&quot;baz&quot;]
&gt;&gt;&gt; foo()
[&quot;baz&quot;]
&gt;&gt;&gt; foo()
[&quot;baz&quot;]
</code></pre><p>##不正确的使用类变量</p>
<p>看下面一个例子：</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     x = 1
...
&gt;&gt;&gt; class B(A):
...     pass
...
&gt;&gt;&gt; class C(A):
...     pass
...
&gt;&gt;&gt; print A.x, B.x, C.x
1 1 1
</code></pre><p>看起来没有问题。</p>
<pre><code>&gt;&gt;&gt; B.x = 2
&gt;&gt;&gt; print A.x, B.x, C.x
1 2 1
</code></pre><p>嗯哈，还是和预想的一样。</p>
<pre><code>&gt;&gt;&gt; A.x = 3
&gt;&gt;&gt; print A.x, B.x, C.x
3 2 3
</code></pre><p>我了个去。只是改变了A.x，为啥C.x也变了？</p>
<p>在Python里，类变量通常在内部被当做字典来处理并遵循通常所说的方法解析顺序（<a href="http://python-history.blogspot.com.ar/2010/06/method-resolution-order.html" target="_blank" rel="external">Method Resolution Order (MRO)</a>）。因此在上面的代码中，因为属性x在类C中找不到，因此它会往上去它的基类中查找（在上面的例子中只有A这个类，当然Python是支持多重继承（multiple inheritance）的）。换句话说，C没有它自己独立于A的属性x。因此对C.x的引用实际上是对A.x的引用。（B.x不是对A.x的引用是因为在第二步里B.x=2将B.x引用到了2这个对象上，倘若没有如此，B.x仍然是引用到A.x上的。）</p>
<p>##在异常处理时错误的使用参数</p>
<p>假设你有如下的代码：</p>
<pre><code>&gt;&gt;&gt; try:
...     l = [&quot;a&quot;, &quot;b&quot;]
...     int(l[2])
... except ValueError, IndexError:  # 想捕捉两个异常
...     pass
...
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 3, in &lt;module&gt;
IndexError: list index out of range
</code></pre><p>这里的问题在于except语句<strong>不会</strong>像这样去接受一系列的异常。并且，在Python 2.x里面，语法<code>except Exception, e</code>是用来将异常和这个可选的参数绑定起来（即这里的e），以用来在后面查看的。因此，在上面的代码中，IndexError异常<strong>不会</strong>被except语句捕捉到；而最终ValueError这个异常被绑定在了一个叫做IndexError的参数上。</p>
<p>在except语句中捕捉多个异常的正确做法是将所有想要捕捉的异常放在一个元组（<a href="https://docs.python.org/2/tutorial/datastructures.html#tut-tuples" target="_blank" rel="external">tuple</a>）里并作为第一个参数给except语句。并且，为移植性考虑，使用as关键字，因为Python 2和Python 3都支持这样的语法，例如：</p>
<pre><code>&gt;&gt;&gt; try:
...     l = [&quot;a&quot;, &quot;b&quot;]
...     int(l[2])
... except (ValueError, IndexError) as e:  
...     pass
...
&gt;&gt;&gt;
</code></pre><p>##误解Python作用域的规则</p>
<p>Python的作用域解析是基于叫做<a href="https://blog.mozilla.org/webdev/2011/01/31/python-scoping-understanding-legb/" target="_blank" rel="external">LEGB</a>（Local（本地），Enclosing（封闭），Global（全局），Built-in（内置））的规则进行操作的。这看起来很直观，对吧？事实上，在Python中这有一些细微的地方很容易出错。看这个例子：</p>
<pre><code>&gt;&gt;&gt; x = 10
&gt;&gt;&gt; def foo():
...     x += 1
...     print x
...
&gt;&gt;&gt; foo()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 2, in foo
UnboundLocalError: local variable &apos;x&apos; referenced before assignment
</code></pre><p>这是怎么回事？</p>
<p>这是因为，在一个作用域里面给一个变量赋值的时候，<strong>Python自动认为这个变量是这个作用域的本地变量，并屏蔽作用域外的同名的变量</strong>。</p>
<p>很多时候可能在一个函数里添加一个赋值的语句会让你从前本来工作的代码得到一个UnboundLocalError。（感兴趣的话可以读一读<a href="https://docs.python.org/2/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" target="_blank" rel="external">这篇</a>文章。）</p>
<p>在使用列表（<a href="https://docs.python.org/2/tutorial/datastructures.html" target="_blank" rel="external">lists</a>）的时候，这种情况尤为突出。看下面这个例子：</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3]
&gt;&gt;&gt; def foo1():
...     lst.append(5)   # 这没有问题...
...
&gt;&gt;&gt; foo1()
&gt;&gt;&gt; lst
[1, 2, 3, 5]

&gt;&gt;&gt; lst = [1, 2, 3]
&gt;&gt;&gt; def foo2():
...     lst += [5]      # ... 这就有问题了！
...
&gt;&gt;&gt; foo2()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 2, in foo
UnboundLocalError: local variable &apos;lst&apos; referenced before assignment
</code></pre><p>嗯？为什么foo2有问题，而foo1没有问题？</p>
<p>答案和上一个例子一样，但是更加不易察觉。foo1并没有给lst<strong>赋值</strong>，但是foo2尝试给lst<strong>赋值</strong>。注意lst+=[5]只是lst=lst+[5]的简写，由此可以看到我们尝试给lst赋值（因此Python假设作用域为本地）。但是，这个要赋给lst的值是基于lst本身的（这里的作用域仍然是本地），而lst却没有被定义，这就出错了。</p>
<p>##在遍历列表的同时又在修改这个列表</p>
<p>下面这个例子中的代码应该比较明显了：</p>
<pre><code>&gt;&gt;&gt; odd = lambda x : bool(x % 2)
&gt;&gt;&gt; numbers = [n for n in range(10)]
&gt;&gt;&gt; for i in range(len(numbers)):
...     if odd(numbers[i]):
...         del numbers[i]  # 这不对的：在遍历列表时删掉列表的元素。
...
Traceback (most recent call last):
      File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
IndexError: list index out of range
</code></pre><p>遍历一个列表或者数组的同时又删除里面的元素，对任何有经验的软件开发人员来说这是个很明显的错误。但是像上面的例子那样明显的错误，即使有经验的程序员也可能不经意间在更加复杂的程序中不小心犯错。</p>
<p>所幸，Python集成了一些优雅的编程范式，如果使用得当，可以写出相当简化和精简的代码。一个附加的好处是更简单的代码更不容易遇到这种“不小心在遍历列表时删掉列表元素”的bug。例如<strong>列表推导式</strong>（<a href="https://docs.python.org/2/tutorial/datastructures.html#tut-listcomps" target="_blank" rel="external">list comprehensions</a>）就提供了这样的范式。再者，列表推导式在避免这样的问题上特别有用，接下来这个对上面的代码的重新实现就相当完美：</p>
<pre><code>&gt;&gt;&gt; odd = lambda x : bool(x % 2)
&gt;&gt;&gt; numbers = [n for n in range(10)]
&gt;&gt;&gt; numbers[:] = [n for n in numbers if not odd(n)]  # 啊，这多优美
&gt;&gt;&gt; numbers
[0, 2, 4, 6, 8]
</code></pre><p>##搞不清楚在闭包（closures）中Python是怎样绑定变量的    </p>
<p>看这个例子：</p>
<pre><code>&gt;&gt;&gt; def create_multipliers():
...     return [lambda x : i * x for i in range(5)]
&gt;&gt;&gt; for multiplier in create_multipliers():
...     print multiplier(2)
...
</code></pre><p>期望得到下面的输出：</p>
<pre><code>0
2
4
6
8
</code></pre><p>但是实际上得到的是：</p>
<pre><code>8
8
8
8
8
</code></pre><p>意外吧！</p>
<p>这是由于Python的<strong>后期绑定</strong>（late binding）机制导致的，这是指在闭包中使用的变量的值，是在内层函数被调用的时候查找的。因此在上面的代码中，当任一返回函数被调用的时候，i的值是在<strong>它被调用时的周围作用域</strong>中查找（到那时，循环已经结束了，所以i已经被赋予了它最终的值4）。</p>
<p>解决的办法比较巧妙：</p>
<pre><code>&gt;&gt;&gt; def create_multipliers():
...     return [lambda x, i=i : i * x for i in range(5)]
...
&gt;&gt;&gt; for multiplier in create_multipliers():
...     print multiplier(2)
...
0
2
4
6
8
</code></pre><p>这下对了！这里利用了默认参数去产生匿名函数以达到期望的效果。有人会说这很优美，有人会说这很微妙，也有人会觉得反感。但是如果你是一名Python程序员，重要的是能理解任何的情况。</p>
<p>##循环加载模块</p>
<p>假设你有两个文件，a.py和b.py，在这两个文件中互相加载对方，例如：</p>
<p>在a.py中：</p>
<pre><code>import b
def f():
    return b.x
print f()
</code></pre><p>在b.py中：</p>
<pre><code>import a
x = 1
def g():
    print a.f()
</code></pre><p>首先，我们试着加载a.py：</p>
<pre><code>&gt;&gt;&gt; import a
1
</code></pre><p>没有问题。也许让人吃惊，毕竟有个感觉应该是问题的循环加载在这儿。</p>
<p>事实上在Python中仅仅是表面上的出现循环加载并不是什么问题。如果一个模块以及被加载了，Python不会傻到再去重新加载一遍。但是，当每个模块都想要互相访问定义在对方里的函数或者变量时，问题就来了。</p>
<p>让我们再回到之前的例子，当我们加载a.py时，它<strong>再加载b.py</strong>不会有问题，因为在加载b.py时，它并不需要访问a.py的任何东西，而在b.py中唯一的引用就是调用a.f()。但是这个调用是在函数g()中完成的，并且a.py或者b.py中没有人调用g()，所以这会儿心情还是美丽的。</p>
<p>但是当我们试图加载b.py时（之前没有加载a.py），会发生什么呢：</p>
<pre><code>&gt;&gt;&gt; import b
Traceback (most recent call last):
      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
      File &quot;b.py&quot;, line 1, in &lt;module&gt;
    import a
      File &quot;a.py&quot;, line 6, in &lt;module&gt;
    print f()
      File &quot;a.py&quot;, line 4, in f
    return b.x
AttributeError: &apos;module&apos; object has no attribute &apos;x&apos;
</code></pre><p>恭喜你，出错了。这里问题出在加载b.py的过程中，Python试图加载a.py，并且在a.py中需要调用到f()，而函数f()又要访问到b.x，但是这个时候b.x却还没有被定义。这就产生了AttributeError异常。</p>
<p>解决的方案可以做一点细微的改动。改一下b.py，使得它在g()里面加载a.py：</p>
<pre><code>x = 1
def g():
    import a    # 只有当g()被调用的时候才加载
    print a.f()
</code></pre><p>这会儿当我们加载b.py的时候，一切安好：</p>
<pre><code>&gt;&gt;&gt; import b
&gt;&gt;&gt; b.g()
1   # 第一次输出，因为模块a在最后调用了‘print f()’
1   # 第二次输出，这是我们调用g()
</code></pre><p>##与Python标准库模块命名冲突</p>
<p>Python的一个优秀的地方在于它提供了丰富的库模块。但是这样的结果是，如果你不下意识的避免，很容易你会遇到你自己的模块的名字与某个随Python附带的标准库的名字冲突的情况（比如，你的代码中可能有一个叫做email.py的模块，它就会与标准库中同名的模块冲突）。</p>
<p>这会导致一些很粗糙的问题，例如当你想加载某个库，这个库需要加载Python标准库里的某个模块，结果呢，因为你有一个与标准库里的模块同名的模块，这个包错误的将你的模块加载了进去，而不是加载Python标准库里的那个模块。这样一来就会有麻烦了。</p>
<p>所以在给模块起名字的时候要小心了，得避免与Python标准库中的模块重名。相比起你提交一个“<a href="http://legacy.python.org/dev/peps/" target="_blank" rel="external">Python改进建议（Python Enhancement Proposal (PEP)）</a>”去向上要求改一个标准库里包的名字，并得到批准来说，你把自己的那个模块重新改个名字要简单得多。</p>
<p>##不能区分Python 2和Python 3</p>
<p>看下面这个文件foo.py：</p>
<pre><code>import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)

def bad():
    e = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        print(&apos;key error&apos;)
    except ValueError as e:
        print(&apos;value error&apos;)
    print(e)

bad()
</code></pre><p>在Python 2里，运行起来没有问题：</p>
<pre><code>$ python foo.py 1
key error
1
$ python foo.py 2
value error
2
</code></pre><p>但是如果拿到Python 3上面玩玩：</p>
<pre><code>$ python3 foo.py 1
key error
Traceback (most recent call last):
  File &quot;foo.py&quot;, line 19, in &lt;module&gt;
    bad()
  File &quot;foo.py&quot;, line 17, in bad
    print(e)
UnboundLocalError: local variable &apos;e&apos; referenced before assignment
</code></pre><p>这是怎么回事？“问题”在于，<strong>在Python 3里，在except块的作用域以外，异常对象（exception object）是不能被访问的</strong>。（原因在于，如果不这样的话，Python会在内存的堆栈里保持一个引用链直到Python的垃圾处理将这些引用从内存中清除掉。更多的技术细节可以参考<a href="https://docs.python.org/3/reference/compound_stmts.html#except" target="_blank" rel="external">这里</a>。）</p>
<p>避免这样的问题可以这样做：保持在execpt块作用域以外对异常对象的引用，这样是可以访问的。下面是用这个办法对之前的例子做的改动，这样在Python 2和Python 3里面都运行都没有问题。</p>
<pre><code>import sys

def bar(i):
    if i == 1:
        raise KeyError(1)
    if i == 2:
        raise ValueError(2)

def good():
    exception = None
    try:
        bar(int(sys.argv[1]))
    except KeyError as e:
        exception = e
        print(&apos;key error&apos;)
    except ValueError as e:
        exception = e
        print(&apos;value error&apos;)
    print(exception)

good()
</code></pre><p>在Py3k里面运行：</p>
<pre><code>$ python3 foo.py 1
key error
1
$ python3 foo.py 2
value error
2
</code></pre><p>耶！</p>
<p>##错误的使用<strong>del</strong>方法</p>
<p>假设有一个文件mod.py中这样使用：</p>
<pre><code>import foo

class Bar(object):
        ...
    def __del__(self):
        foo.cleanup(self.myhandle)
</code></pre><p>然后试图在another_mod.py里这样：</p>
<pre><code>import mod
mybar = mod.Bar()
</code></pre><p>那么你会得到一个恶心的AttributeError异常。</p>
<p>为啥呢？这是因为（参考<a href="https://mail.python.org/pipermail/python-bugs-list/2009-January/069209.html" target="_blank" rel="external">这里</a>），当解释器关闭时，模块所有的全局变量会被置为空（None）。结果便如上例所示，当<strong>del</strong>被调用时，名字foo已经被置为空了。</p>
<p>使用<code>atexit.register()</code>可以解决这个问题。如此，当你的程序结束的时候（退出的时候），你的注册的处理程序会在解释器关闭之前处理。</p>
<p>这样理解的话，对上面的mod.py可以做如下的修改：</p>
<pre><code>import foo
import atexit

def cleanup(handle):
    foo.cleanup(handle)

class Bar(object):
    def __init__(self):
        ...
        atexit.register(cleanup, self.myhandle)
</code></pre><p>这样的实现方式为在程序正常终止时调用清除功能提供了一种干净可靠的办法。显然，需要<code>foo.cleanup</code>决定怎么处理绑定在<code>self.myhandle</code>上的对象，但你知道怎么做的。</p>
<p>##总结</p>
<p>Python 是一门非常强大且灵活的语言，它众多的机制和范式能显著的提高生产效率。不过，和任何一款软件或者语言一样，对它的理解或认识不足的话，常常是弊大于利的，并会处于一种“一知半解”的状态。</p>
<p>多熟悉Python的一些关键的细微的地方，比如（但不局限于）本文中提到的这些问题，可以帮你更好的使用这门语言的同时帮你避免一些常见的陷阱。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/06/Django-csrf机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/06/Django-csrf机制/" itemprop="url">Django csrf机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-06T20:44:17+08:00">
                2015-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>官方文档参考<a href="https://docs.Djangoproject.com/en/1.7/ref/contrib/csrf/" target="_blank" rel="external">这里</a></p>
<p>##什么是CSRF</p>
<p>CSRF（Cross-site request forgery）跨站请求伪造，也被称成为“one click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。</p>
<p>比如可以这样进行攻击:</p>
<p>一个网站用户Bob可能正在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后者刚刚发布了一个具有Bob银行链接的图片消息。设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片tag。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。</p>
<p>##防范措施<br>对于web站点，将持久化的授权方法（例如cookie或者HTTP授权）切换为瞬时的授权方法（在每个form中提供隐藏field），这将帮助网站防止这些攻击。一种类似的方式是在form中包含秘密信息、用户指定的代号作为cookie之外的验证。</p>
<p>另一个可选的方法是“双提交”cookie。此方法只工作于Ajax请求，但它能够作为无需改变大量form的全局修正方法。如果某个授权的cookie在form post之前正被JavaScript代码读取，那么限制跨域规则将被应用。如果服务器需要在Post请求体或者URL中包含授权cookie的请求，那么这个请求必须来自于受信任的域，因为其它域是不能从信任域读取cookie的。</p>
<p>与通常的信任想法相反，使用Post代替Get方法并不能提供卓有成效的保护。因为JavaScript能使用伪造的POST请求。尽管如此，那些导致对安全产生“副作用”的请求应该总使用Post方式发送。Post方式不会在web服务器和代理服务器日志中留下数据尾巴，然而Get方式却会留下数据尾巴。</p>
<p>尽管CSRF是web应用的基本问题，而不是用户的问题，但用户能够在缺乏安全设计的网站上保护他们的帐户：通过在浏览其它站点前登出站点或者在浏览器会话结束后清理浏览器的cookie。</p>
<p>##如何用 Django 进行防范 </p>
<p>Django的csrf机制,它实际就是后台生成一个随机字符串,在你显示表单的时候在表单中加入一个hidden input,比如:</p>
<pre><code>&lt;input type=&apos;hidden&apos; name=&apos;csrfmiddlewaretoken&apos; value=&apos;QtF7jsxQddj5Dj9uKuIs3J7jgm0Bf6sg&apos; /&gt;
</code></pre><p>这个hidden input就是csrftoken在模板中根据后台传过来的随机字符串生成的。</p>
<ol>
<li>form提交时，会通过隐藏表单的方式提交cookie中的csrftoken记录</li>
<li>服务器端接到POST请求时，会验证提交的Token和用户cookie的Token值是否一致，如不一致就返回403错误</li>
</ol>
<p><strong>注意</strong>：如果使用的是Django.middleware.csrf.CsrfViewMiddle这个中间件，Django会默认验证每一个post请求，因此所有的表单内都需要加上csrf_token的tag，否则站内提交也会被阻止，除非通过@csrf_exempt装饰器来显式申明不验证token值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/06/python的logging模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/06/python的logging模块/" itemprop="url">python的logging模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-06T17:17:09+08:00">
                2015-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>官方文档在<a href="https://docs.python.org/2/library/logging.html#logging.Handler.createLock" target="_blank" rel="external">这里</a></p>
<p>举一个栗子：代码既要把日志输出到控制台，还要写入日志文件</p>
<pre><code>import logging

# 创建一个logger
logger = logging.getLogger(&apos;mylogger&apos;)
logger.setLevel(logging.DEBUG)

# 创建一个handler，用于写入日志文件
fh = logging.FileHandler(&apos;test.log&apos;)
fh.setLevel(logging.DEBUG)

# 再创建一个handler，用于输出到控制台
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

# 定义handler的输出格式
formatter = logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;)
fh.setFormatter(formatter)
ch.setFormatter(formatter)

# 给logger添加handler
logger.addHandler(fh)
logger.addHandler(ch)

# 记录一条日志
logger.info(&apos;foorbar&apos;)  
</code></pre><p>在控制台和当前目录下的test.log文件中都有下面这行输出：</p>
<pre><code>2015-05-6 17:10:29,816 - mylogger - INFO - foorbar 
</code></pre><p>##logging模块的API</p>
<p>###logging.getLogger([name])<br>返回一个logger实例，如果没有指定name，返回<code>root logger</code>。</p>
<p>只要name相同，返回的logger实例都是同一个而且只有一个，即name和logger实例是一一对应的。这意味着，无需把logger实例在各个模块中传递。只要知道name，就能得到 同一个logger实例</p>
<p>###Logger.setLevel(lvl)</p>
<p>设置logger的level， level有以下几个级别：</p>
<p>NOTSET &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</p>
<p>如果把looger的级别设置为INFO， 那么小于INFO级别的日志都不输出， 大于等于INFO级别的日志都输出</p>
<pre><code>logger.debug(&quot;foobar&quot;)     # 不输出 
logger.info(&quot;foobar&quot;)      # 输出
logger.warning(&quot;foobar&quot;)   # 输出
logger.error(&quot;foobar&quot;)     # 输出
logger.critical(&quot;foobar&quot;)  # 输出 
</code></pre><p>###Logger.addHandler(hdlr)<br>logger可以雇佣handler来帮它处理日志， handler主要有以下几种：</p>
<ol>
<li>StreamHandler: 输出到控制台</li>
<li>FileHandler:   输出到文件</li>
</ol>
<p><strong>handler还可以设置自己的level以及输出格式。</strong></p>
<p>##logging.basicConfig([**kwargs])</p>
<ul>
<li>这个函数用来配置root logger， 为root logger创建一个StreamHandler，<br> 设置默认的格式。</li>
<li>这些函数： logging.debug()、logging.info()、logging.warning()、<br> logging.error()、logging.critical() 如果调用的时候发现root logger没有任何<br> handler， 会自动调用basicConfig添加一个handler</li>
<li>如果root logger已有handler， 这个函数不做任何事情</li>
</ul>
<p>使用basicConfig来配置root logger的输出格式和level：</p>
<pre><code>import logging
logging.basicConfig(format=&apos;%(levelname)s:%(message)s&apos;, level=logging.DEBUG)
logging.debug(&apos;This message should appear on the console&apos;)
</code></pre><p>##关于root logger以及logger的父子关系<br>前面多次提到root logger， 实际上logger实例之间还有父子关系， root logger就是处于<br>最顶层的logger， 它是所有logger的祖先。如下图:<br><img src="http://cupic.img168.net/bbsfile/forum/month_1109/11090116387b8f480c8f5ec3b2.png" alt=""> </p>
<p>####root logger是默认的logger</p>
<p>如果不创建logger实例， 直接调用logging.debug()、logging.info()logging.warning()、logging.error()、logging.critical()这些函数，<br>那么使用的logger就是 root logger， 它可以自动创建，也是单实例的。</p>
<p>####如何得到root logger</p>
<p>通过logging.getLogger()或者logging.getLogger(“”)得到root logger实例。</p>
<p>####默认的level</p>
<p>root logger默认的level是logging.WARNING</p>
<p>####如何表示父子关系</p>
<p>logger的name的命名方式可以表示logger之间的父子关系. 比如：<br>parent_logger = logging.getLogger(‘foo’)<br>child_logger = logging.getLogger(‘foo.bar’)</p>
<p>####什么是effective level</p>
<p>logger有一个概念，叫effective level。 如果一个logger没有显示地设置level，那么它就<br>用父亲的level。如果父亲也没有显示地设置level， 就用父亲的父亲的level，以此推….</p>
<p>最后到达root logger，一定设置过level。默认为logging.WARNING</p>
<p>child loggers得到消息后，既把消息分发给它的handler处理，也会传递给所有祖先logger处理。</p>
<p>又一个<strong>栗子</strong>：</p>
<pre><code>import logging

# 设置root logger
r = logging.getLogger()
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter(&apos;%(asctime)s - %(levelname)s - %(message)s&apos;)
ch.setFormatter(formatter)
r.addHandler(ch)

# 创建一个logger作为父亲
p = logging.getLogger(&apos;foo&apos;)
p.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter(&apos;%(asctime)s - %(message)s&apos;)
ch.setFormatter(formatter)
p.addHandler(ch)

# 创建一个孩子logger
c = logging.getLogger(&apos;foo.bar&apos;)
c.debug(&apos;foo_test&apos;)  
</code></pre><p>输出如下：</p>
<pre><code>2015-05-06 17:14:22,677 - foo_test
2015-05-06 17:14:22,677 - DEBUG - foo_test
</code></pre><p>可见， 孩子logger没有任何handler，所以对消息不做处理。但是它把消息转发给了它的父亲以及root logger。最后输出两条日志。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/06/函数式编程-2-装饰器和偏函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/06/函数式编程-2-装饰器和偏函数/" itemprop="url">函数式编程(2)--装饰器和偏函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-06T14:31:47+08:00">
                2015-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##编写无参数decorator</p>
<p>Python的 <code>decorator</code> 本质上就是一个高阶函数，它接收一个函数作为参数，然后，返回一个新函数。</p>
<p>使用 decorator 用Python提供的 <code>@</code> 语法，这样可以避免手动编写 <code>f = decorate(f)</code> 这样的代码。</p>
<p>考察一个@log的定义：</p>
<pre><code>def log(f):
    def fn(x):
        print &apos;call &apos; + f.__name__ + &apos;()...&apos;
        return f(x)
    return fn
</code></pre><p>对于阶乘函数，@log工作得很好：</p>
<pre><code>@log
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
print factorial(10)
</code></pre><p><strong>结果：</strong></p>
<pre><code>call factorial()...
3628800
</code></pre><p>但是，对于参数不是一个的函数，调用将报错：</p>
<pre><code>@log
def add(x, y):
    return x + y
print add(1, 2)
</code></pre><p><strong>结果：</strong></p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 15, in &lt;module&gt;
    print add(1,2)
TypeError: fn() takes exactly 1 argument (2 given)
</code></pre><p>因为 <code>add()</code> 函数需要传入两个参数，但是 <code>@log</code> 写死了只含一个参数的返回函数。<br>要让 <code>@log</code> 自适应任何参数定义的函数，可以利用Python的 <em>args 和 *</em>kw，保证任意个数的参数总是能正常调用：</p>
<pre><code>def log(f):
    def fn(*args, **kw):
        print &apos;call &apos; + f.__name__ + &apos;()...&apos;
        return f(*args, **kw)
    return fn
</code></pre><p>现在，对于任意函数，<code>@log</code> 都能正常工作。</p>
<p><strong>栗子</strong>：请编写一个@performance，它可以打印出函数调用的时间。</p>
<p>计算函数调用的时间可以记录调用前后的当前时间戳，然后计算两个时间戳的差。</p>
<p><strong>参考代码</strong></p>
<pre><code>import time
def performance(f):
    def fn(*args, **kw):
        t1 = time.time()
        r = f(*args, **kw)
        t2 = time.time()
        print &apos;call %s() in %fs&apos; % (f.__name__, (t2 - t1))
        return r
    return fn

@performance
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
print factorial(10)
</code></pre><p>##编写带参数decorator</p>
<p>考察上一节的 <code>@log</code>装饰器：</p>
<pre><code>def log(f):
    def fn(x):
        print &apos;call &apos; + f.__name__ + &apos;()...&apos;
        return f(x)
    return fn
</code></pre><p>发现对于被装饰的函数，log打印的语句是不能变的（除了函数名）。</p>
<p>如果有的函数非常重要，希望打印出’[INFO] call xxx()…’，有的函数不太重要，希望打印出’[DEBUG] call xxx()…’，这时，log函数本身就需要传入’INFO’或’DEBUG’这样的参数，类似这样：</p>
<pre><code>@log(&apos;DEBUG&apos;)
def my_func():
    pass
</code></pre><p>把上面的定义翻译成高阶函数的调用，就是：</p>
<pre><code>my_func = log(&apos;DEBUG&apos;)(my_func)
</code></pre><p>上面的语句看上去还是比较绕，再展开一下：</p>
<pre><code>log_decorator = log(&apos;DEBUG&apos;)
my_func = log_decorator(my_func)
</code></pre><p>上面的语句又相当于：</p>
<pre><code>log_decorator = log(&apos;DEBUG&apos;)
@log_decorator
def my_func():
    pass
</code></pre><p>所以，带参数的log函数首先返回一个decorator函数，再让这个decorator函数接收my_func并返回新函数：</p>
<pre><code>def log(prefix):
    def log_decorator(f):
        def wrapper(*args, **kw):
            print &apos;[%s] %s()...&apos; % (prefix, f.__name__)
            return f(*args, **kw)
        return wrapper
    return log_decorator

@log(&apos;DEBUG&apos;)
def test():
    pass
print test()
</code></pre><p><strong>执行结果：</strong></p>
<pre><code>[DEBUG] test()...
None
</code></pre><p>对于这种3层嵌套的decorator定义，你可以先把它拆开：</p>
<pre><code># 标准decorator:
def log_decorator(f):
    def wrapper(*args, **kw):
        print &apos;[%s] %s()...&apos; % (prefix, f.__name__)
        return f(*args, **kw)
    return wrapper
return log_decorator

# 返回decorator:
def log(prefix):
    return log_decorator(f)
</code></pre><p>拆开以后会发现，调用会失败，因为在3层嵌套的<code>decorator</code>定义中，最内层的<code>wrapper</code>引用了最外层的参数<code>prefix</code>，所以，把一个闭包拆成普通的函数调用会比较困难。不支持闭包的编程语言要实现同样的功能就需要更多的代码。</p>
<p><strong>栗子</strong>：上一节的<code>@performance</code>只能打印秒，请给 <code>@performace</code> 增加一个参数，允许传入<code>&#39;s&#39;</code>或<code>&#39;ms&#39;</code>：</p>
<pre><code>@performance(&apos;ms&apos;)
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
</code></pre><p>要实现带参数的@performance，就需要实现：</p>
<pre><code>my_func = performance(&apos;ms&apos;)(my_func)
</code></pre><p>需要3层嵌套的decorator来实现。</p>
<p><strong>参考代码</strong></p>
<pre><code>import time
def performance(unit):
    def perf_decorator(f):
        def wrapper(*args, **kw):
            t1 = time.time()
            r = f(*args, **kw)
            t2 = time.time()
            t = (t2 - t1) * 1000 if unit==&apos;ms&apos; else (t2 - t1)
            print &apos;call %s() in %f %s&apos; % (f.__name__, t, unit)
            return r
        return wrapper
    return perf_decorator

@performance(&apos;ms&apos;)
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
print factorial(10)
</code></pre><p>##完善decorator</p>
<p><code>@decorator</code>可以动态实现函数功能的增加，但是，经过<code>@decorator</code>“改造”后的函数，和原函数相比，除了功能多一点外，有没有其它不同的地方？</p>
<p>在没有decorator的情况下，打印函数名：</p>
<pre><code>def f1(x):
    pass
print f1.__name__
</code></pre><p><strong>输出</strong>： f1<br>有decorator的情况下，再打印函数名：</p>
<pre><code>def log(f):
    def wrapper(*args, **kw):
        print &apos;call...&apos;
        return f(*args, **kw)
    return wrapper
@log
def f2(x):
    pass
print f2.__name__
</code></pre><p><strong>输出</strong>： wrapper<br>可见，由于<code>decorator</code>返回的新函数函数名已经不是<code>&#39;f2&#39;</code>，而是<code>@log</code>内部定义的<code>&#39;wrapper&#39;</code>。这对于那些依赖函数名的代码就会失效。<code>decorator</code>还改变了函数的<code>__doc__</code>等其它属性。如果要让调用者看不出一个函数经过了<code>@decorator</code>的“改造”，就需要把原函数的一些属性复制到新函数中：</p>
<pre><code>def log(f):
    def wrapper(*args, **kw):
        print &apos;call...&apos;
        return f(*args, **kw)
    wrapper.__name__ = f.__name__
    wrapper.__doc__ = f.__doc__
    return wrapper
</code></pre><p>这样写<code>decorator</code>很不方便，因为我们也很难把原函数的所有必要属性都一个一个复制到新函数上，所以Python内置的<code>functools</code>可以用来自动化完成这个“复制”的任务：</p>
<pre><code>import functools
def log(f):
    @functools.wraps(f)
    def wrapper(*args, **kw):
        print &apos;call...&apos;
        return f(*args, **kw)
    return wrapper
</code></pre><p>最后需要指出，由于我们把原函数签名改成了<code>(*args, **kw)</code>，因此，无法获得原函数的原始参数信息。即便我们采用固定参数来装饰只有一个参数的函数：</p>
<pre><code>def log(f):
    @functools.wraps(f)
    def wrapper(x):
        print &apos;call...&apos;
        return f(x)
    return wrapper
</code></pre><p>也可能改变原函数的参数名，因为新函数的参数名始终是 <code>&#39;x&#39;</code>，原函数定义的参数名不一定叫 <code>&#39;x&#39;</code>。</p>
<p><strong>栗子</strong>：请思考带参数的@decorator，@functools.wraps应该放置在哪：</p>
<pre><code>def performance(unit):
    def perf_decorator(f):
        def wrapper(*args, **kw):
            ???
        return wrapper
    return perf_decorator
</code></pre><p>注意@functools.wraps应该作用在返回的新函数上。</p>
<p><strong>参考代码</strong></p>
<pre><code>import time, functools
def performance(unit):
    def perf_decorator(f):
        @functools.wraps(f)
        def wrapper(*args, **kw):
            t1 = time.time()
            r = f(*args, **kw)
            t2 = time.time()
            t = (t2 - t1) * 1000 if unit==&apos;ms&apos; else (t2 - t1)
            print &apos;call %s() in %f %s&apos; % (f.__name__, t, unit)
            return r
        return wrapper
    return perf_decorator

@performance(&apos;ms&apos;)
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))
print factorial.__name__
</code></pre><p>##偏函数</p>
<p>当一个函数有很多参数时，调用者就需要提供多个参数。如果减少参数个数，就可以简化调用者的负担。</p>
<p>比如，<code>int()</code>函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</p>
<pre><code>&gt;&gt;&gt; int(&apos;12345&apos;)
12345
</code></pre><p>但int()函数还提供额外的<code>base参数</code>，默认值为<code>10</code>。如果传入base参数，就可以做 <code>N</code> 进制的转换：</p>
<pre><code>&gt;&gt;&gt; int(&apos;12345&apos;, base=8)
5349
&gt;&gt;&gt; int(&apos;12345&apos;, 16)
74565
</code></pre><p>假设要转换大量的二进制字符串，每次都传入<code>int(x, base=2)</code>非常麻烦，于是，我们想到，可以定义一个<code>int2()</code>的函数，默认把<code>base=2</code>传进去：</p>
<pre><code>def int2(x, base=2):
    return int(x, base)
</code></pre><p>这样，我们转换二进制就非常方便了：</p>
<pre><code>&gt;&gt;&gt; int2(&apos;1000000&apos;)
64
&gt;&gt;&gt; int2(&apos;1010101&apos;)
85
</code></pre><p><code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数int2：</p>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2(&apos;1000000&apos;)
64
&gt;&gt;&gt; int2(&apos;1010101&apos;)
85
</code></pre><p>所以，<code>functools.partial</code>可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定默认值，这样，新函数调用的难度就降低了。</p>
<p><strong>栗子</strong>：在讲解<code>sorted</code>函数时，我们在<code>sorted</code>这个高阶函数中传入自定义排序函数就可以实现忽略大小写排序。请用<code>functools.partial</code>把这个复杂调用变成一个简单的函数：</p>
<pre><code>sorted_ignore_case(iterable)
</code></pre><p>要固定<code>sorted()的cmp参数</code>，需要传入一个排序函数作为<code>cmp</code>的默认值。</p>
<p><strong>参考代码</strong></p>
<pre><code>import functools
sorted_ignore_case = functools.partial(sorted, cmp=lambda s1, s2: cmp(s1.upper(), s2.upper()))
print sorted_ignore_case([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/06/函数式编程-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/06/函数式编程-1/" itemprop="url">函数式编程(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-06T14:30:40+08:00">
                2015-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##基本概念<br>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
<p>而函数式编程（请注意多了一个“式”字）—— <code>Functional Programming</code>，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p>
<p>我们首先要搞明白计算机（<code>Computer</code>）和计算（<code>Compute</code>）的概念。</p>
<p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>
<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<p>##高阶函数<br>能够接受函数作为参数的函数，被称为高阶函数。函数式编程就是指这种高度抽象的编程范式。</p>
<p>一个简单的高阶函数</p>
<pre><code>def add(x, y, f):
    return f(x) + f(y)
</code></pre><p>如果传入abs作为参数f的值</p>
<pre><code>add(-5, 9, abs)
</code></pre><p>根据函数的定义，函数执行的代码实际上是：</p>
<p>abs(-5) + abs(9)</p>
<p>由于参数 x, y 和 f 都可以任意传入，如果 f 传入其他函数，就可以得到不同的返回值。</p>
<p>比如说传入开平方根的函数</p>
<blockquote>
<p>计算平方根可以用函数：</p>
<blockquote>
<blockquote>
<p>math.sqrt(2)<br>    1.4142…</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>参考代码</strong></p>
<pre><code>import math
def add(x, y, f):
    return f(x) + f(y)
print add(25, 9, math.sqrt)
</code></pre><p>##map()函数</p>
<p><strong>map()</strong>是 Python 内置的高阶函数，它接收<strong>一个函数 f</strong> 和<strong>一个 list</strong>，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。</p>
<p>例如，对于list [1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
<p>如果希望把list的每个元素都作平方，就可以用map()函数：</p>
<p><img src="http://www.liaoxuefeng.com/files/attachments/0013879622109990efbf9d781704b02994ba96765595f56000/0" alt=""></p>
<p>因此，我们只需要传入函数f(x)=x*x，就可以利用map()函数完成这个计算：</p>
<pre><code>def f(x):
    return x*x
print map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
</code></pre><p>输出结果：</p>
<pre><code>[1, 4, 9, 10, 25, 36, 49, 64, 81]
</code></pre><p><strong>注意</strong>：map()函数不改变原有的 list，而是返回一个新的 list。</p>
<p>利用map()函数，可以把一个 list 转换为另一个 list，只需要传入转换函数。</p>
<p>由于list包含的元素可以是任何类型，因此，map() 不仅仅可以处理只包含数值的 list，事实上它可以处理包含任意类型的 list，只要传入的函数f可以处理这种数据类型。</p>
<p><strong>栗子</strong>：假设用户输入的英文名字不规范，没有按照首字母大写，后续字母小写的规则，请利用map()函数，把一个list（包含若干不规范的英文名字）变成一个包含规范英文名字的list：</p>
<p>输入：[‘adam’, ‘LISA’, ‘barT’]</p>
<p>输出：[‘Adam’, ‘Lisa’, ‘Bart’]</p>
<p><strong>参考代码</strong></p>
<pre><code>def format_name(s):
    return s[0].upper() + s[1:].lower()
print map(format_name, [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;])
</code></pre><p>##reduce()函数</p>
<p><strong>reduce()</strong>函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，<strong>一个函数 f</strong>，<strong>一个list</strong>，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。</p>
<p>例如，编写一个f函数，接收x和y，返回x和y的和：</p>
<pre><code>def f(x, y):
    return x + y
</code></pre><p>调用 <code>reduce(f, [1, 3, 5, 7, 9])</code>时，reduce函数将做如下计算：</p>
<pre><code>先计算头两个元素：f(1, 3)，结果为4；
再把结果和第3个元素计算：f(4, 5)，结果为9；
再把结果和第4个元素计算：f(9, 7)，结果为16；
再把结果和第5个元素计算：f(16, 9)，结果为25；
由于没有更多的元素了，计算结束，返回结果25。
</code></pre><p>上述计算实际上是对 list 的所有元素求和。虽然Python内置了求和函数sum()，但是，利用reduce()求和也很简单。</p>
<p><strong>reduce()还可以接收第3个可选参数，作为计算的初始值。</strong>如果把初始值设为100，计算：</p>
<pre><code>reduce(f, [1, 3, 5, 7, 9], 100)
</code></pre><p>结果将变为125，因为第一轮计算是：<br>计算初始值和第一个元素：<strong>f(100, 1)</strong>，结果为101。</p>
<p>##filter()函数</p>
<p><strong>filter()</strong>函数是 Python 内置的另一个有用的高阶函数，filter()函数接收<strong>一个函数 f</strong> 和<strong>一个list</strong>，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。</p>
<p>例如，要从一个<code>list [1, 4, 6, 7, 9, 12, 17]</code>中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：</p>
<pre><code>def is_odd(x):
    return x % 2 == 1
</code></pre><p>然后，利用filter()过滤掉偶数：</p>
<pre><code>filter(is_odd, [1, 4, 6, 7, 9, 12, 17])
</code></pre><p><strong>结果</strong>：[1, 7, 9, 17]</p>
<p>利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串：</p>
<pre><code>def is_not_empty(s):
    return s and len(s.strip()) &gt; 0
filter(is_not_empty, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos;  &apos;, &apos;END&apos;])
</code></pre><p><strong>结果</strong>：[‘test’, ‘str’, ‘END’]</p>
<p><strong>注意</strong>: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。</p>
<p>当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下：</p>
<pre><code>a = &apos;     123&apos;
a.strip()
</code></pre><p><strong>结果</strong>： ‘123’</p>
<pre><code>a=&apos;\t\t123\r\n&apos;
a.strip()
</code></pre><p><strong>结果</strong>：’123’</p>
<p><strong>栗子</strong>：<code>filter()</code> 接收的函数必须判断出一个数的平方根是否是整数，而 <code>math.sqrt()</code>返回结果是浮点数。</p>
<p><strong>参考代码</strong></p>
<pre><code>import math
def is_sqr(x):
    r = int(math.sqrt(x))
    return r*r==x
print filter(is_sqr, range(1, 101))
</code></pre><p>##sorted自定义排序函数</p>
<p>Python内置的 sorted()函数可对list进行排序：</p>
<pre><code>&gt;&gt;&gt;sorted([36, 5, 12, 9, 21])

[5, 9, 12, 21, 36]
</code></pre><p>但 sorted()也是一个高阶函数，它可以接收一个比较函数来实现自定义排序，比较函数的定义是，传入两个待比较的元素 x, y，<strong>如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。</strong></p>
<p>因此，如果我们要实现倒序排序，只需要编写一个reversed_cmp函数：</p>
<pre><code>def reversed_cmp(x, y):
    if x &gt; y:
        return -1
    if x &lt; y:
        return 1
    return 0
</code></pre><p>这样，调用 sorted() 并传入 reversed_cmp 就可以实现倒序排序：</p>
<pre><code>&gt;&gt;&gt; sorted([36, 5, 12, 9, 21], reversed_cmp)
[36, 21, 12, 9, 5]
</code></pre><p>sorted()也可以对字符串进行排序，字符串默认按照ASCII大小来比较：</p>
<pre><code>&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])
[&apos;Credit&apos;, &apos;Zoo&apos;, &apos;about&apos;, &apos;bob&apos;]
</code></pre><p>‘Zoo’排在’about’之前是因为’Z’的ASCII码比’a’小。</p>
<p><strong>栗子</strong>：对字符串排序时，有时候忽略大小写排序更符合习惯。请利用sorted()高阶函数，实现忽略大小写排序的算法。</p>
<p>输入：[‘bob’, ‘about’, ‘Zoo’, ‘Credit’]</p>
<p>输出：[‘about’, ‘bob’, ‘Credit’, ‘Zoo’]</p>
<p>对于比较函数cmp_ignore_case(s1, s2)，要忽略大小写比较，就是先把两个字符串都变成大写（或者都变成小写），再比较。</p>
<p><strong>参考代码</strong></p>
<pre><code>def cmp_ignore_case(s1, s2):
    u1 = s1.upper()
    u2 = s2.upper()
    if u1 &lt; u2:
        return -1
    if u1 &gt; u2:
        return 1
    return 0
print sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], cmp_ignore_case)
</code></pre><p>##返回函数</p>
<p>Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数！<br>例如，定义一个函数 f()，我们让它返回一个函数 g，可以这样写：</p>
<pre><code>def f():
    print &apos;call f()...&apos;
    # 定义函数g:
    def g():
        print &apos;call g()...&apos;
    # 返回函数g:
    return g
</code></pre><p>仔细观察上面的函数定义，我们在函数 f 内部又定义了一个函数 g。由于函数 g 也是一个对象，函数名 g 就是指向函数 g 的变量，所以，最外层函数 f 可以返回变量 g，也就是函数 g 本身。</p>
<p>调用函数 f，我们会得到 f 返回的一个函数：</p>
<pre><code>&gt;&gt;&gt; x = f()   # 调用f()
call f()...
&gt;&gt;&gt; x   # 变量x是f()返回的函数：
&lt;function g at 0x1037bf320&gt;
&gt;&gt;&gt; x()   # x指向函数，因此可以调用
call g()...   # 调用x()就是执行g()函数定义的代码
</code></pre><p>请注意区分返回函数和返回值：</p>
<pre><code>def myabs():
    return abs   # 返回函数
def myabs2(x):
    return abs(x)   # 返回函数调用的结果，返回值是一个数值
</code></pre><p>返回函数可以把一些计算延迟执行。例如，如果定义一个普通的求和函数：</p>
<pre><code>def calc_sum(lst):
    return sum(lst)
</code></pre><p>调用calc_sum()函数时，将立刻计算并得到结果：</p>
<pre><code>&gt;&gt;&gt; calc_sum([1, 2, 3, 4])
10
</code></pre><p>但是，如果返回一个函数，就可以“延迟计算”：</p>
<pre><code>def calc_sum(lst):
    def lazy_sum():
        return sum(lst)
    return lazy_sum
</code></pre><p>调用calc_sum()并没有计算出结果，而是返回函数:</p>
<pre><code>&gt;&gt;&gt; f = calc_sum([1, 2, 3, 4])
&gt;&gt;&gt; f
&lt;function lazy_sum at 0x1037bfaa0&gt;
</code></pre><p>对返回的函数进行调用时，才计算出结果:</p>
<pre><code>&gt;&gt;&gt; f()
10
</code></pre><p>由于可以返回函数，我们在后续代码里就可以决定到底要不要调用该函数。</p>
<p><strong>栗子</strong>：请编写一个函数calc_prod(lst)，它接收一个list，返回一个函数，返回函数可以计算参数的乘积。</p>
<p><strong>参考代码</strong></p>
<pre><code>def calc_prod(lst):
    def lazy_prod():
        def f(x, y):
            return x * y
        return reduce(f, lst, 1)
    return lazy_prod
f = calc_prod([1, 2, 3, 4])
print f()
</code></pre><p>##闭包</p>
<p>在函数内部定义的函数和外部定义的函数是一样的，只是他们无法被外部访问：</p>
<pre><code>def g():
    print &apos;g()...&apos;

def f():
    print &apos;f()...&apos;
    return g
</code></pre><p>将 <code>g</code> 的定义移入函数 <code>f</code> 内部，防止其他代码调用 <code>g</code>：</p>
<pre><code>def f():
    print &apos;f()...&apos;
    def g():
        print &apos;g()...&apos;
    return g
</code></pre><p>但是，考察上一小节定义的 <code>calc_sum</code> 函数：</p>
<pre><code>def calc_sum(lst):
    def lazy_sum():
        return sum(lst)
    return lazy_sum
</code></pre><p><strong>注意</strong>: 发现没法把 <code>lazy_sum</code> 移到 <code>calc_sum</code> 的外部，因为它引用了 <code>calc_sum</code> 的参数 <code>lst</code>。</p>
<p>像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为<strong>闭包（Closure）</strong>。</p>
<p>闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。举例如下：</p>
<pre><code># 希望一次返回3个函数，分别计算1x1,2x2,3x3:
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre><p>你可能认为调用f1()，f2()和f3()结果应该是<code>1，4，9</code>，但实际结果全部都是 <code>9</code>（请自己动手验证）。</p>
<p>原因就是当count()函数返回了3个函数时，这3个函数所引用的变量 i 的值已经变成了3。由于f1、f2、f3并没有被调用，所以，此时他们并未计算 i*i，当 f1 被调用时：</p>
<pre><code>&gt;&gt;&gt; f1()
9     # 因为f1现在才计算i*i，但现在i的值已经变为3
</code></pre><p>因此，返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<p><strong>栗子</strong>：返回闭包不能引用循环变量，请改写count()函数，让它正确返回能计算1x1、2x2、3x3的函数。</p>
<p>考察下面的函数 f:</p>
<pre><code>def f(j):
    def g():
        return j*j
    return g
</code></pre><p>它可以正确地返回一个闭包g，g所引用的变量j不是循环变量，因此将正常执行。<br>在count函数的循环内部，如果借助f函数，就可以避免引用循环变量i。</p>
<p><strong>参考代码</strong></p>
<pre><code>def count():
    fs = []
    for i in range(1, 4):
        def f(j):
            def g():
                return j*j
            return g
        r = f(i)
        fs.append(r)
    return fs
f1, f2, f3 = count()
print f1(), f2(), f3()
</code></pre><p>##匿名函数</p>
<p>高阶函数可以接收函数做参数，有些时候，我们不需要显式地定义函数，直接传入匿名函数更方便。</p>
<p>在Python中，对匿名函数提供了有限支持。还是以<code>map()</code>函数为例，计算 f(x)=x2 时，除了定义一个<code>f(x)</code>的函数外，还可以直接传入匿名函数：</p>
<pre><code>&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre><p>通过对比可以看出，匿名函数 <code>lambda x: x * x</code> 实际上就是：</p>
<pre><code>def f(x):
    return x * x
</code></pre><p><code>关键字lambda</code> 表示匿名函数，冒号前面的 <code>x 表示函数参数</code>。<br>匿名函数有个限制，就是<code>只能有一个表达式，不写return</code>，返回值就是该表达式的结果。</p>
<p>使用匿名函数，可以不必定义函数名，直接创建一个函数对象，很多时候可以简化代码：</p>
<pre><code>&gt;&gt;&gt; sorted([1, 3, 9, 5, 0], lambda x,y: -cmp(x,y))
[9, 5, 3, 1, 0]
</code></pre><p>返回函数的时候，也可以返回匿名函数：</p>
<pre><code>&gt;&gt;&gt; myabs = lambda x: -x if x &lt; 0 else x 
&gt;&gt;&gt; myabs(-1)
1
&gt;&gt;&gt; myabs(1)
1
</code></pre><p><strong>栗子</strong>：利用匿名函数简化以下代码：</p>
<pre><code>def is_not_empty(s):
    return s and len(s.strip()) &gt; 0

filter(is_not_empty, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos;  &apos;, &apos;END&apos;])
</code></pre><p>定义匿名函数时，没有return关键字，且表达式的值就是函数返回值。</p>
<p><strong>参考代码</strong></p>
<pre><code>print filter(lambda s: s and len(s.strip())&gt;0, [&apos;test&apos;, None, &apos;&apos;, &apos;str&apos;, &apos;  &apos;, &apos;END&apos;])
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/05/Python-中的下划线命名规则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/05/Python-中的下划线命名规则/" itemprop="url">Python 中的下划线命名规则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-05T15:35:45+08:00">
                2015-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>python中用下划线命名变量和函数是在是令人困惑，单下划线，双下划线，双下划线还分前后……,今天来总结一下，以备日后参考</p>
<p>##单下划线（_）</p>
<p>通常情况下，单下划线（_）会在以下3种场景中使用：</p>
<p>###在解释器中：</p>
<p>在这种情况下，“_”代表交互式解释器会话中上一条执行的语句的结果。这种用法首先被标准CPython解释器采用，然后其他类型的解释器也先后采用。</p>
<pre><code>&gt;&gt;&gt; _ Traceback (most recent call last): 
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; 
NameError: name &apos;_&apos; is not defined 
&gt;&gt;&gt; 42
&gt;&gt;&gt; _ 
42
&gt;&gt;&gt; &apos;alright!&apos; if _ else &apos;:(&apos;
&apos;alright!&apos;
&gt;&gt;&gt; _ 
&apos;alright!&apos;
</code></pre><p>###作为一个名称：</p>
<p>这与上面一点稍微有些联系，此时<code>“_”</code>作为临时性的名称使用。这样，当其他人阅读你的代码时将会知道，你分配了一个特定的名称，但是并不会在后面再次用到该名称。例如，下面的例子中，你可能对循环计数中的实际值并不感兴趣，此时就可以使用“_”。</p>
<pre><code>n = 42
for _ in range(n): 
    do_something()
</code></pre><p>###国际化：</p>
<p>也许你也曾看到”_“会被作为一个函数来使用。这种情况下，它通常用于实现国际化和本地化字符串之间翻译查找的函数名称，这似乎源自并遵循相应的C约定。例如，在 Django文档“转换”章节 中，你将能看到如下代码：</p>
<pre><code>from django.utils.translation import ugettext as _ 
from django.http import HttpResponse 
def my_view(request): 
    output = _(&quot;Welcome to my site.&quot;) 
    return HttpResponse(output)
</code></pre><p>可以发现，场景二和场景三中的使用方法可能会相互冲突，所以我们需要避免在使用<code>“_”</code>作为国际化查找转换功能的代码块中同时使用“_”作为临时名称。</p>
<p>##名称前的单下划线（如：_shahriar）</p>
<p>程序员使用名称前的单下划线，用于指定该名称属性为“私有”。这有点类似于惯例，为了使其他人（或你自己）使用这些代码时将会知道以“_”开头的名称只供内部使用。正如Python文档中所述：</p>
<p>以下划线<code>“_”</code>为前缀的名称（如_spam）应该被视为API中非公开的部分（不管是函数、方法还是数据成员）。此时，应该将它们看作是一种实现细节，在修改它们时无需对外部通知。</p>
<p>正如上面所说，这确实类似一种惯例，因为它对解释器来说确实有一定的意义，如果你写了代码“from &lt;模块/包名&gt; import <em>”，那么以<code>“_”</code>开头的名称都不会被导入， 除非模块或包中的<code>“__all__”</code>列表显式地包含了它们 。了解更多请查看“ Importing </em> in Python ”。</p>
<p>不过值得注意的是，如果使用 <code>import a_module</code> 这样导入模块，仍然可以用 <code>a_module._some_var</code> 这样的形式访问到这样的对象。</p>
<p>另外单下划线开头还有一种一般不会用到的情况在于，使用一个 C 编写的扩展库有时会用下划线开头命名，然后使用一个去掉下划线的 Python 模块进行包装。如 struct 这个模块实际上是 C 模块 _struct 的一个 Python 包装。</p>
<p>##名称前的双下划线（如：__shahriar）</p>
<p>名称（具体为一个方法名）前双下划线<code>（__）</code>的用法并不是一种惯例，对解释器来说它有特定的意义。Python中的这种用法是为了避免与子类定义的名称冲突。Python文档指出，<code>“__spam”</code>这种形式（ 至少两个前导下划线，最多一个后续下划线 ）的任何标识符将会被<code>“_classname__spam”</code>这种形式原文取代，在这里“classname”是去掉前导下划线的当前类名。例如下面的例子：</p>
<pre><code>&gt;&gt;&gt; class A(object): 
...     def _internal_use(self): 
...         pass
...     def __method_name(self): 
...         pass
... 
&gt;&gt;&gt; dir(A()) 
[&apos;_A__method_name&apos;, ..., &apos;_internal_use&apos;]
</code></pre><p>正如所预料的，<code>“_internal_use”</code>并未改变，而<code>“__method_name”</code>却被变成了<code>“_ClassName__method_name”</code>：<code>__</code>开头 的 私有变量会在代码生成之前被转换为长格式（变为公有）。转换机制是这样的：在变量前端插入类名，再在前端加入一个下划线字符。这就是所谓的私有变量 名字改编 （Private name mangling） 。<br>此时，如果你创建A的一个子类B，那么你将不能轻易地覆写A中的方法<code>“__method_name”</code>，</p>
<pre><code>&gt;&gt;&gt; class B(A): 
...     def __method_name(self): 
...         pass
... 
&gt;&gt;&gt; dir(B()) 
[&apos;_A__method_name&apos;, &apos;_B__method_name&apos;, ..., &apos;_internal_use&apos;]
</code></pre><p>然而如果你知道了这个规律，最终你还是可以访问这个“私有”变量的。</p>
<p>私有变量名字改编意在给出一个在类中定义”私有”实例变量和方法的简单途径，避免派生类的实例变量定义产生问题，或者与外界代码中的变量搞混。</p>
<p>要注意的是混淆规则（私有变量名字改编）主要目的在于避免意外错误，被认作为私有的变量仍然有可能被访问或修改(使用<code>_classname__membername</code>)，在特定的场合它也是有用的，比如调试的时候。</p>
<p>上述的功能几乎和Java中的final方法和C++类中标准方法（非虚方法）一样。</p>
<p><strong>再讲两点题外话</strong>：</p>
<p>一是因为轧压（改编）会使标识符变长，当超过255的时候，Python会切断，要注意因此引起的命名冲突。</p>
<p>二是当类名全部以下划线命名的时候，Python就不再执行轧压（改编）。</p>
<p>无论是单下划线还是双下划线开头的成员，都是希望外部程序开发者不要直接使用这些成员变量和这些成员函数，只是双下划线从语法上能够更直接的避免错误的使用，但是如果按照 <code>_类名__成员名</code> 则依然可以访问到。单下划线的在动态调试时可能会方便一些，只要项目组的人都遵守下划线开头的成员不直接使用，那使用单下划线或许会更好。</p>
<p>##名称前后的双下划线（如：<strong>init</strong>）</p>
<p>这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写<code>“__init__”</code>方法。</p>
<p>双下划线开头双下划线结尾的是一些 Python 的“魔术”对象，如类成员的 <code>__init__</code>、<code>__del__</code>、<code>__add__</code>、<code>__getitem__</code> 等，以及全局的 <code>__file__</code>、<code>__name__</code> 等。 Python 官方推荐永远不要将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。 虽然你也可以编写自己的特殊方法名，但不要这样做。</p>
<pre><code>&gt;&gt;&gt; class C(object): 
...     def __mine__(self): 
...         pass
... 
&gt;&gt;&gt; dir(C) 
... [..., &apos;__mine__&apos;, ...]
</code></pre><p>其实，很容易摆脱这种类型的命名，而只让Python内部定义的特殊名称遵循这种约定 :)</p>
<p>##题外话 if <strong>name</strong> == “<strong>main</strong>“:</p>
<p>所有的 Python 模块都是对象并且有几个有用的属性，你可以使用这些属性方便地测试你所书写的模块。</p>
<p>模块是对象, 并且所有的模块都有一个内置属性<code>__name__</code>。一个模块的<code>__name__</code> 的值要看您如何应用模块。如果 import 模块, 那么 <code>__name__</code>的值通常为模块的文件名, 不带路径或者文件扩展名。但是您也可以像一个标准的程序一样直接运行模块, 在这种情况下<code>__name__</code>的值将是一个特别的缺省值：<code>__main__</code>。</p>
<pre><code>&gt;&gt;&gt; import odbchelper
&gt;&gt;&gt; odbchelper.__name__
&apos;odbchelper&apos;
</code></pre><p>一旦了解到这一点, 您可以在模块内部为您的模块设计一个测试套件, 在其中加入这个 if 语句。当您直接运行模块, <code>__name__</code> 的值是 <code>__main__</code>, 所以测试套件执行。当您导入模块,<code>__name__</code>的值就是别的东西了, 所以测试套件被忽略。这样使得在将新的模块集成到一个大程序之前开发和调试容易多了。</p>
<p>在 MacPython 上, 需要一个额外的步聚来使得<code>if __name__</code>技巧有效。 点击窗口右上角的黑色三角, 弹出模块的属性菜单, 确认<code>Run as __main__</code>被选中。</p>
<p>##总结：</p>
<p>Python 用下划线作为变量前缀和后缀指定特殊变量。</p>
<p><code>_xxx</code>       不能用’from module import *’导入</p>
<p><code>__xxx__</code>  系统定义名字</p>
<p><code>__xxx</code>    类中的私有变量名</p>
<p><strong>核心风格：避免用下划线作为变量名的开头。</strong></p>
<p>因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避免用下划线作为变量名的开头。一般来讲，变量名_xxx被看作是“私有的”，在模块或类外不可以使用。当变量是私有的时候，用_xxx 来表示变量是很好的习惯。 因为变量名<code>__xxx__</code>对Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。</p>
<p>“单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；</p>
<p>“双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。</p>
<p>以单下划线开头（如_foo）的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用<code>“from xxx import *”</code>而导入；以双下划线开头的（如<code>__foo</code>）代表类的私有成员；以双下划线开头和结尾的（<code>__foo__</code>）代表python里特殊方法专用的标识，如<code>__init__()</code> 代表类的构造函数。</p>
<p>附 PEP 规范：</p>
<pre><code>PEP-0008:
In addition, the following special forms using leading or trailing underscores are recognized (these can generally be combined with any case convention):
  - _single_leading_underscore: weak &quot;internal use&quot; indicator. E.g. &quot;from M import *&quot; does not import objects whose name starts with an underscore.
  - single_trailing_underscore_: used by convention to avoid conflicts with Python keyword, e.g.
    Tkinter.Toplevel(master, class_=&apos;ClassName&apos;)
  - __double_leading_underscore: when naming a class attribute, invokes name mangling (inside class FooBar, __boo becomes _FooBar__boo; see below).
  - __double_leading_and_trailing_underscore__: &quot;magic&quot; objects or attributes that live in user-controlled namespaces. E.g. __init__,
    __import__ or __file__. Never invent such names; only use them as documented.
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/05/转载-程序员必须知道的10大基础实用算法及其讲解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/05/转载-程序员必须知道的10大基础实用算法及其讲解/" itemprop="url">转载:程序员必须知道的10大基础实用算法及其讲解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-05T08:52:38+08:00">
                2015-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载自<a href="http://cricode.com/2001.html" target="_blank" rel="external">这里</a></p>
<p>##算法一：快速排序算法</p>
<p><strong>快速排序</strong>是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要<code>Ο(n log n)</code>次比较。在最坏状况下则需要<code>Ο(n2)</code>次比较，但这种状况并不常见。事实上，快速排序通常明显比其他<code>Ο(n log n)</code> 算法更快，因为它的内部循环<code>（inner loop）</code>可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法<code>（Divide and conquer）</code>策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>从数列中挑出一个元素，称为 “基准”（pivot），</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
</ol>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Sorting_quicksort_anim.gif" alt=""></p>
<p><strong>详细介绍</strong>：<a href="http://cricode.com/970.html" target="_blank" rel="external">快速排序</a></p>
<p>##算法二：堆排序算法</p>
<p><strong>堆排序</strong>（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序的平均时间复杂度为<code>Ο(nlogn)</code> 。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li>创建一个堆H[0..n-1]</li>
<li>把堆首（最大值）和堆尾互换</li>
<li><p>把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置</p>
</li>
<li><p>重复步骤2，直到堆的尺寸为1</p>
</li>
</ol>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Sorting_heapsort_anim.gif" alt=""></p>
<p>详细介绍：<a href="http://cricode.com/977.html" target="_blank" rel="external">堆排序</a></p>
<p>##算法三：归并排序</p>
<p><strong>归并排序</strong>（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p>
</li>
<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p>
</li>
<li><p>重复步骤3直到某一指针达到序列尾</p>
</li>
<li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p>
</li>
</ol>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Merge_sort_animation2.gif" alt=""></p>
<p>详细介绍：<a href="http://taop.marchtea.com/04.01.html" target="_blank" rel="external">归并排序</a></p>
<p>##算法四：二分查找算法</p>
<p><strong>二分查找算法</strong>是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为<code>Ο(logn)</code>。</p>
<p>详细介绍：<a href="http://taop.marchtea.com/04.01.html" target="_blank" rel="external">二分查找算法</a></p>
<p>##算法五：BFPRT(线性查找算法)</p>
<p><strong>BFPRT算法</strong>解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂度，五位算法作者做了精妙的处理。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>将n个元素每5个一组，分成n/5(上界)组。</p>
</li>
<li><p>取出每一组的中位数，任意排序方法，比如插入排序。</p>
</li>
<li><p>递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。</p>
</li>
<li><p>用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。</p>
</li>
<li><p>若i==k，返回x；若i<k，在小于x的元素中递归查找第i小的元素；若i>k，在大于x的元素中递归查找第i-k小的元素。</k，在小于x的元素中递归查找第i小的元素；若i></p>
</li>
</ol>
<p><strong>终止条件</strong>：n=1时，返回的即是i小元素。</p>
<p>详细介绍：</p>
<p><a href="http://cricode.com/968.html" target="_blank" rel="external">寻找最小(最大)的k个数</a></p>
<p><a href="http://taop.marchtea.com/02.01.html" target="_blank" rel="external">线性查找相关算法</a></p>
<p>##算法六：DFS（深度优先搜索）</p>
<p><strong>深度优先搜索算法</strong>（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS属于盲目搜索。</p>
<p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。</p>
<p><strong>深度优先遍历图算法步骤</strong>：</p>
<ol>
<li><p>访问顶点v；</p>
</li>
<li><p>依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</p>
</li>
<li><p>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</p>
</li>
</ol>
<p>上述描述可能比较抽象，举个实例：</p>
<p>DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1邻 接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，… 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。</p>
<p>接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</p>
<p>详细介绍：<a href="http://www.cnblogs.com/skywang12345/p/3711483.html" target="_blank" rel="external">深度优先搜索</a></p>
<p>##算法七：BFS(广度优先搜索)</p>
<p><strong>广度优先搜索算法</strong>（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>首先将根节点放入队列中。</p>
</li>
<li><p>从队列中取出第一个节点，并检验它是否为目标。</p>
</li>
<li><p>如果找到目标，则结束搜寻并回传结果。<br>否则将它所有尚未检验过的直接子节点加入队列中。</p>
</li>
<li><p>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</p>
</li>
<li><p>重复步骤2。</p>
</li>
</ol>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Animated_BFS.gif" alt=""></p>
<p>详细介绍：<a href="http://www.cnblogs.com/skywang12345/p/3711483.html" target="_blank" rel="external">广度优先搜索</a></p>
<p>##算法八：Dijkstra算法</p>
<p><strong>戴克斯特拉算法</strong>（Dijkstra’s algorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</p>
<p>该算法的输入包含了一个有权重的有向图 G，以及G中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中所有边的集合，而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t的最低权重路径(例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。对于不含负权的有向图，Dijkstra算法是目前已知的最快的单源最短路径算法。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>初始时令 S={V0},T={其余顶点}，T中顶点对应的距离值</p>
<ul>
<li><p>若存在<v0,vi>，d(V0,Vi)为<v0,vi>弧上的权值</v0,vi></v0,vi></p>
</li>
<li><p>若不存在<v0,vi>，d(V0,Vi)为∞</v0,vi></p>
</li>
</ul>
</li>
<li><p>从T中选取一个其距离值为最小的顶点W且不在S中，加入S</p>
</li>
<li><p>对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值</p>
</li>
</ol>
<p>重复上述步骤2、3，直到S中包含所有顶点，即W=Vi为止</p>
<p><img src="http://zezhi.qiniudn.com/wp-content/uploads/2014/06/Dijkstra_Animation.gif" alt=""></p>
<p>详细：<a href="http://www.cnblogs.com/skywang12345/p/3711512.html" target="_blank" rel="external">Dijkstra算法</a></p>
<p>##算法九：动态规划算法</p>
<p><strong>动态规划</strong>（Dynamic programming）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<p>关于动态规划最经典的问题当属背包问题。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li><p>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p>
</li>
<li><p>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>
</li>
</ol>
<p><strong>详细参考</strong>：</p>
<p><a href="http://cricode.com/1096.html" target="_blank" rel="external">从全球导航到输入法：谈谈动态规划</a></p>
<p><a href="http://hawstein.com/posts/dp-novice-to-advanced.html" target="_blank" rel="external">动态规划</a></p>
<p>##算法十：朴素贝叶斯分类算法</p>
<p>朴素贝叶斯分类算法是一种基于贝叶斯定理的简单概率分类算法。贝叶斯分类的基础是概率推理，就是在各种条件的存在不确定，仅知其出现概率的情况下，如何完成推理和决策任务。概率推理是与确定性推理相对应的。而朴素贝叶斯分类器是基于独立假设的，即假设样本每个特征与其他特征都不相关。</p>
<p>朴素贝叶斯分类器依靠精确的自然概率模型，在有监督学习的样本集中能获取得非常好的分类效果。在许多实际应用中，朴素贝叶斯模型参数估计使用最大似然估计方法，换言之朴素贝叶斯模型能工作并没有用到贝叶斯概率或者任何贝叶斯模型。</p>
<p>尽管是带着这些朴素思想和过于简单化的假设，但朴素贝叶斯分类器在很多复杂的现实情形中仍能够取得相当好的效果。</p>
<p><strong>详细参考</strong>：</p>
<p><a href="http://cricode.com/1078.html" target="_blank" rel="external">贝叶斯网络</a></p>
<p><a href="http://cricode.com/1098.html" target="_blank" rel="external">朴素贝叶斯分类算法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/27/django-session的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/27/django-session的使用/" itemprop="url">Django--session的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-27T22:00:40+08:00">
                2015-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>外面下大雨，回不去了，记录一下刚刚使用django的session遇到的一个问题。</p>
<p>想要让用户注册之后能够返回到注册之前的页面，这样就要记住之前的url，我想用session来保存url，思路是对的，但是实施的时候却总是实现不了。</p>
<p>各种assert False，还是没能看出来，没办法只能继续看文档，果然让我找到了这个</p>
<blockquote>
<p>flush()</p>
<p>Delete the current session data from the session and delete the session cookie. This is used if you want to ensure that the previous session data can’t be accessed again from the user’s browser (for example, the django.contrib.auth.logout() function calls it).</p>
</blockquote>
<p>这是session的flush方法，用来清除会话的，注意最后一句，调用auth.logout()就会自动调用flush方法，原来如此</p>
<p>我在log_in这个函数的第一句就写了<code>auth.logout(request)</code>，难怪老是在session发现不了定义的字段。</p>
<p>有困难找官方文档</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/27/python-对象的拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/27/python-对象的拷贝/" itemprop="url">python 对象的拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-27T19:12:42+08:00">
                2015-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##小例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; a.append(&apos;b&apos;)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;, &apos;b&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;, &apos;b&apos;]
</code></pre><p>可以看出，赋值号“=”是引用，即a 和 b 是指向一个对象。</p>
<p>如何实现对象的拷贝呢，python 有 copy模块。</p>
<p>##用法</p>
<pre><code>import copy
对象2 = copy.copy(对象1)
</code></pre><p>##例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = copy.copy(a)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; a.append(&apos;b&apos;)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;, &apos;b&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
</code></pre><p>##问题</p>
<pre><code>&gt;&gt;&gt; a = [[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b = copy.copy(a)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; a[1].append(&apos;c&apos;)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
&gt;&gt;&gt; a.append((3,4,5))
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], (3, 4, 5)]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
</code></pre><p> 可以看出：copy 可以实现浅层拷贝，可以通过copy.deepcoppy(）来实现深层拷贝。</p>
<p>##深拷贝</p>
<pre><code>&gt;&gt;&gt; a = [[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b = copy.deepcopy(a)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; a[1].append(&apos;hello&apos;)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;hello&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
</code></pre><p>##对象三要素</p>
<p>python中的对象包含三要素:id, type, value</p>
<ol>
<li>id 用来标识唯一一个对象</li>
<li>type标识对象的类型</li>
<li>value用来设置对象的值。</li>
</ol>
<p><code>is</code> 判断是否是一个对象，是使用id来判断的。</p>
<p><code>==</code> 是判断a对象的值是否是b对象的值，默认调用它的<code>__eq__</code>方法。</p>
<p>###例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; c = copy.copy(a)
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; a is c
False
</code></pre><p><code>&quot;b  = a&quot;</code> 是引用 指向的一个对象，所以<code>a is b</code> 返回 True</p>
<p><code>&quot;c = copy.copy(a)&quot;</code>  c是a的拷贝，不是指向一个对象，返回False </p>
<pre><code>&gt;&gt;&gt; a == c
True
</code></pre><p>但是他们的值确实是相同的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">216</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
