<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/img/lufei.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/27/django-session的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/27/django-session的使用/" itemprop="url">Django--session的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-27T22:00:40+08:00">
                2015-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>外面下大雨，回不去了，记录一下刚刚使用django的session遇到的一个问题。</p>
<p>想要让用户注册之后能够返回到注册之前的页面，这样就要记住之前的url，我想用session来保存url，思路是对的，但是实施的时候却总是实现不了。</p>
<p>各种assert False，还是没能看出来，没办法只能继续看文档，果然让我找到了这个</p>
<blockquote>
<p>flush()</p>
<p>Delete the current session data from the session and delete the session cookie. This is used if you want to ensure that the previous session data can’t be accessed again from the user’s browser (for example, the django.contrib.auth.logout() function calls it).</p>
</blockquote>
<p>这是session的flush方法，用来清除会话的，注意最后一句，调用auth.logout()就会自动调用flush方法，原来如此</p>
<p>我在log_in这个函数的第一句就写了<code>auth.logout(request)</code>，难怪老是在session发现不了定义的字段。</p>
<p>有困难找官方文档</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/27/python-对象的拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/27/python-对象的拷贝/" itemprop="url">python 对象的拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-27T19:12:42+08:00">
                2015-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##小例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; a.append(&apos;b&apos;)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;, &apos;b&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;, &apos;b&apos;]
</code></pre><p>可以看出，赋值号“=”是引用，即a 和 b 是指向一个对象。</p>
<p>如何实现对象的拷贝呢，python 有 copy模块。</p>
<p>##用法</p>
<pre><code>import copy
对象2 = copy.copy(对象1)
</code></pre><p>##例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = copy.copy(a)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
&gt;&gt;&gt; a.append(&apos;b&apos;)
&gt;&gt;&gt; a
[1, 2, &apos;a&apos;, &apos;b&apos;]
&gt;&gt;&gt; b
[1, 2, &apos;a&apos;]
</code></pre><p>##问题</p>
<pre><code>&gt;&gt;&gt; a = [[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b = copy.copy(a)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; a[1].append(&apos;c&apos;)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
&gt;&gt;&gt; a.append((3,4,5))
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], (3, 4, 5)]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
</code></pre><p> 可以看出：copy 可以实现浅层拷贝，可以通过copy.deepcoppy(）来实现深层拷贝。</p>
<p>##深拷贝</p>
<pre><code>&gt;&gt;&gt; a = [[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b = copy.deepcopy(a)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
&gt;&gt;&gt; a[1].append(&apos;hello&apos;)
&gt;&gt;&gt; a
[[1, 2], [&apos;a&apos;, &apos;b&apos;, &apos;hello&apos;]]
&gt;&gt;&gt; b
[[1, 2], [&apos;a&apos;, &apos;b&apos;]]
</code></pre><p>##对象三要素</p>
<p>python中的对象包含三要素:id, type, value</p>
<ol>
<li>id 用来标识唯一一个对象</li>
<li>type标识对象的类型</li>
<li>value用来设置对象的值。</li>
</ol>
<p><code>is</code> 判断是否是一个对象，是使用id来判断的。</p>
<p><code>==</code> 是判断a对象的值是否是b对象的值，默认调用它的<code>__eq__</code>方法。</p>
<p>###例子</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, &apos;a&apos;]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; c = copy.copy(a)
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; a is c
False
</code></pre><p><code>&quot;b  = a&quot;</code> 是引用 指向的一个对象，所以<code>a is b</code> 返回 True</p>
<p><code>&quot;c = copy.copy(a)&quot;</code>  c是a的拷贝，不是指向一个对象，返回False </p>
<pre><code>&gt;&gt;&gt; a == c
True
</code></pre><p>但是他们的值确实是相同的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/27/CGI和WSGI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/27/CGI和WSGI/" itemprop="url">CGI和WSGI</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-27T08:50:26+08:00">
                2015-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我对 CGI 的理解是利用程序的标准输入输出流，完成 HTTP 通信。HTTP 是文本协议，每次请求的文本以标准输入流的形式进入服务器端 CGI 程序，创建进程；然后进程的标准输出流作为响应 。</p>
<p>WSGI 和 CGI 原理极其相似，但是是完全不同的实现。WSGI 是 Python 专用的协议，也是输入&amp;输出的方式传输文本流，但不是创建进程，而是对一个 WSGI 程序（callable 的对象，可以是函数也可以是实现了 <strong>call</strong> 的对象），将 request 作为参数传入（不再是纯文本，而是经过包装），同样将经过包装的 response 作为响应返回。request/response 的包装由 Python 标准库提供。</p>
<p>二者都是标准，都有诸多实现。CGI 最为广泛，无论是二进制程序、perl 脚本、python 脚本还是 PHP 都可以以这样的原理提供 HTTP 服务；WSGI 在 Python 界也是公共标准，主流 Web 框架基本都有实现，例如 Bottle 的 bottle.Bottle （Application 对象）就实现了 WSGI 协议（见 <strong>call</strong> 方法）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/26/django的QuerySets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/26/django的QuerySets/" itemprop="url">Django的QuerySets</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-26T18:53:25+08:00">
                2015-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对象关系映射 (ORM) 使得与SQL数据库交互更为简单，不过也被认为效率不高，比原始的SQL要慢。<br>要有效的使用ORM，意味着需要多少要明白它是如何查询数据库的。本文我将重点介绍如何有效使用 <a href="https://docs.djangoproject.com/en/dev/topics/db/models/" target="_blank" rel="external">Django ORM</a>系统访问中到大型的数据集。</p>
<p>##Django的queryset是惰性的</p>
<p><strong>Django的queryset对应于数据库的若干记录（row）</strong>，通过可选的查询来过滤。例如，下面的代码会得到数据库中名字为‘Dave’的所有的人:<br>?</p>
<pre><code>person_set = Person.objects.filter(first_name=&quot;Dave&quot;)
</code></pre><p>上面的代码并没有运行任何的数据库查询。你可以使用person_set，给它加上一些过滤条件，或者将它传给某个函数，这些操作都不会发送给数据库。这是对的，因为数据库查询是显著影响web应用性能的因素之一。<br>要真正从数据库获得数据，你需要遍历queryset:<br>?</p>
<pre><code>for person in person_set:
    print(person.last_name)
</code></pre><p>##Django的queryset是具有cache的</p>
<p>当你遍历queryset时，所有匹配的记录会从数据库获取，然后转换成Django的model。这被称为<code>执行</code>（evaluation）。这些model会保存在queryset内置的cache中，这样如果你再次遍历这个queryset，你不需要重复运行通用的查询。<br>例如，下面的代码只会执行一次数据库查询：</p>
<pre><code>pet_set = Pet.objects.filter(species=&quot;Dog&quot;)
# The query is executed and cached.
for pet in pet_set:
    print(pet.first_name)
# The cache is used for subsequent iteration.
for pet in pet_set:
    print(pet.last_name)
</code></pre><p>##if语句会触发queryset的执行</p>
<p>queryset的cache最有用的地方是可以有效的测试queryset是否包含数据，只有有数据时才会去遍历：</p>
<pre><code>restaurant_set = Restaurant.objects.filter(cuisine=&quot;Indian&quot;)
# `if`语句会触发queryset的执行。
if restaurant_set:
    # 遍历时用的是cache中的数据
    for restaurant in restaurant_set:
        print(restaurant.name)
</code></pre><p>##QuerySet的常用API</p>
<p>###去重<br>distinct方法的作用和SQL的distinct的作用是一样的，这里就不多说了</p>
<pre><code>Author.objects.distinct()
</code></pre><p>###序列化为JSON<br>和前端进行交互的时候，序列化成XML的情况还是比较少的，但是序列化成JSON格式的字符串的情况就比较多了，Django的ORM框架提供了values的方法来把实体序列化成json</p>
<pre><code>Blog.objects.values()
</code></pre><p>###序列化成数组<br>把对象序列化成数组元素的情况还真的是用的比较少</p>
<pre><code>Entry.objects.values_list(&apos;id&apos;, &apos;headline&apos;)
</code></pre><p>###从主表获取外键表的对象<br>在主表的实体上使用filter，然后再通过主表的实体获取外键的时候，Django会把主表的实体一并查询出来。但是有时候我们只希望从主表开始取数，但是只取外键表实体的信息，这个时候就可以用select_related方法了。第一个参数是主表的外键字段名称，第二个字段嘛。。。照抄就是了</p>
<pre><code>g = Group.objects.select_related(&apos;room&apos;, &apos;subject&apos;)
</code></pre><p>当然，也会有只希望拿主表信息，不想把外键字段取回来的情况，把参数设置为none就好了</p>
<pre><code>without_relations = queryset.select_related(None)
</code></pre><p>###处理从表对象<br>对于外键表来说，我们可以采用select_related的方法来进行处理。但是对于从表属性来说，就要用到另外一种方法了。（toppings是多对多的属性）</p>
<pre><code>Pizza.objects.all().prefetch_related(&apos;toppings&apos;)
</code></pre><p>同样的，不获取外键对象的话把参数设置为none就好了</p>
<pre><code>non_prefetched = qs.prefetch_related(None)
</code></pre><p>###ORM和SQL的混合：Extra方法<br>先看看Extra方法的一些例子</p>
<p>####selec参数<br>    Entry.objects.extra(select={‘is_recent’: “pub_date &gt; ‘2006-01-01’”})</p>
<p>####where参数<br>    Entry.objects.extra(where=[“foo=’a’ OR bar = ‘a’”, “baz = ‘a’”])</p>
<p>####order_by参数<br>    q = q.extra(order_by = [‘-is_recent’])</p>
<p>####paramas参数<br>    Entry.objects.extra(where=[‘headline=%s’], params=[‘Lennon’])<br>其实从官方给的例子看起来，Extra方法主要就是用于在ORM生成SQL的过程中内嵌SQL语句。例如希望在select 背后加入一句sql，例如select …,(select a from …)这种情况下的时候，用Extra方法就很好解决了</p>
<p>###使用Defer和Only来过滤字段<br>select_related和prefetch_related方法分别用来过滤实体的外键属性和多对多属性，对于主表的字段属性过滤可以采用defer方法来少查询一些字段</p>
<pre><code>Entry.objects.defer(&quot;headline&quot;, &quot;body&quot;)
</code></pre><p>defer是排除哪些字段，而only是只查询哪些字段</p>
<pre><code>Person.objects.only(&quot;name&quot;)
</code></pre><p>###使用select_for_update来简化更新的过程<br>一般更新实体的时候，我们需要先把实体先查询出来，然后做出相应的更新，再做一次save操作</p>
<pre><code>entity=Entry.objects.filter(...)[0]
entity.name=xx
entity.save()
</code></pre><p>这个过程显得稍微有点繁琐，所以可以采用一种select_for_update来进行一些简化</p>
<pre><code>entries = Entry.objects.select_for_update().filter(author=request.user)
</code></pre><p>###使用get_or_create来简化创建对象的过程<br>同样的，有时候我们会需要先查询对象在不在数据库里面存储，假如没有的话就创建，有的话就取出</p>
<pre><code>obj, created = Person.objects.get_or_create(first_name=&apos;John&apos;, last_name=&apos;Lennon&apos;,
              defaults={&apos;birthday&apos;: date(1940, 10, 9)})
</code></pre><p>不过个人觉得这个方法用到的情况很少。。。。</p>
<p>###批量插入数据<br>    Entry.objects.bulk_create([<br>        Entry(headline=”Django 1.0 Released”),<br>        Entry(headline=”Django 1.1 Announced”),<br>        Entry(headline=”Breaking: Django is awesome”)<br>      ])<br>这玩意真的挺有用，具体的就不细说了</p>
<p>###使用Count方法来进行统计<br>虽然做统计的话可以先把过滤完的对象查询出来，然后再len(xx)一下，但是这种做法会把数据库里面一堆一堆的暑假都查出来的(￣◇￣;)，所以当需要做count操作的时候还是老老实实的用sql的count语句，在Django里面的话做法如下</p>
<pre><code>Entry.objects.filter(headline__contains=&apos;Lennon&apos;).count()
</code></pre><p>###判断数据是否存在:exists<br>    rs=some_queryset.filter(pk=entry.pk).exists()</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/16/一些pythonic代码的例子/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/16/一些pythonic代码的例子/" itemprop="url">一些pythonic代码的例子</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-16T20:53:22+08:00">
                2015-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##百分号的使用：<br>通常我们都是这样格式化字符串的:</p>
<pre><code>print &apos;hello world programme by %s&apos; % &apos;python&apos;  
</code></pre><p> 但是如果格式化的字符串中有很多%s,那么程序的可读性就会依靠于%后面 的变量名起得是否好了。</p>
<p>这个时候有一种用dict来格式化的%，我觉得很有用，尤其是在记log的 时候，作为log的格式，可读性非常高。<br>代码如下：</p>
<pre><code>#字符串  
value = {&apos;what&apos;: &apos;hello, world&apos;, &apos;language&apos;: &apos;python&apos;}  
print &apos;%(what)s, %(language)s&apos; % value  
#也可以包含int的  
value = {&apos;name&apos;: &apos;jianpx&apos;, &apos;age&apos;: 23}  
print &apos;%(name)s &apos;s age is  %(age)i&apos; % value
</code></pre><h2 id="用两个元素之间有对应关系的list构造一个dict："><a href="#用两个元素之间有对应关系的list构造一个dict：" class="headerlink" title="用两个元素之间有对应关系的list构造一个dict："></a>用两个元素之间有对应关系的list构造一个dict：</h2><p>运用zip可以非常简单的实现：</p>
<pre><code>names = [&apos;jianpx&apos;, &apos;yue&apos;]  
ages = [23, 40]  
m = dict(zip(names,ages))  
</code></pre><p> zip的使用可以help(zip)或者查看官方文档。</p>
<p>##交换两个值：<br>在其他语言可能要一个临时变量和三句话：</p>
<pre><code>temp = a
a = b
b = temp
</code></pre><p>但是在python，一句就ok了，而且不需要临时变量：</p>
<pre><code>a,b = b,a
</code></pre><p>右边的b,a 其实可以理解成一个tuple。</p>
<p>##数量多的字符串相连用join：<br>python字符串效率问题之一就是在连接字符串的时候使用‘+’号，例如 <code>s = &#39;s1&#39; + &#39;s2&#39; + &#39;s3&#39; + ...+&#39;sN&#39;</code>，总共将N个字符串连接起来，但是使用+号的话，python需要申请N-1次内存空间，然后进行字符串拷贝。原因是字符串对象<code>PyStringObject</code>在python当中是<strong>不可变对象</strong>，所以每当需要合并两个字符串的时候，就要重新申请一个新的内存空间（大小为两个字符串长度之和）来给这个合并之后的新字符串，然后进行拷贝。所以用+号效率非常低。建议在连接字符串的时候使用字符串本身的方法<code>join（list）</code>，这个方法能提高效率，原因是它只是申请了一次内存空间，因为它可以遍历list中的元素计算出总共需要申请的内存空间的大小，一次申请完。所以上面的例子可以写成<code>s = &#39;&#39;.join([&#39;s1&#39;,&#39;s2&#39;,....,&#39;sN&#39;])</code></p>
<p>例子是：</p>
<pre><code>#以前是这样写的  
fruits = [&apos;apple&apos;, &apos;banana&apos;]  
result = &apos;&apos;  
for f in fruits:  
    result += f  

#现在可以这样：  
fruits = [&apos;apple&apos;, &apos;banana&apos;]  
result = &apos;&apos;.join(fruits)  
</code></pre><p>##判断一个key是否在一个dict里面：<br>以前很经常犯的一个<strong>mistake</strong>是这样做：</p>
<pre><code>if key in dict_example:  
    do something  
</code></pre><p> 现在要这样写，就不用使用in操作了。</p>
<pre><code>if dict_example.has_key(key):  
    do something  
</code></pre><p>##去掉list中的重复元素：</p>
<pre><code>old_list = [1,1,1,3,4]  
new_list = list(set(old_list))  
</code></pre><p>##判断元素是否在列表中<br>如果对没有重复元素的列表对象，要判断某个元素是否在列表里面的话，当这个列表很大的时候，用set会比list<br>的性能要好，因为对于list，本身允许重复元素存在，所以它不是用hash实现的，但是set不一样，它不允许重复元素，看了python源代码，从set的实现源码setobject.c 中查找key的函数</p>
<pre><code>static setentry *
set_lookkey(PySetObject *so, PyObject *key, register long hash)    
</code></pre><p>的接口可以看出它真的使用hash去实现的。</p>
<p>所以对于in操作，set的实现是计算这个元素的hash值然后判断，理论上可以达到O(1)</p>
<p>##读文件操作：<br>    以前是这样写的：</p>
<pre><code>#默认文件存在，不处理Exception的情况  
f = open(&apos;filename&apos;, &apos;r&apos;)  
while 1:  
    line = f.readline()  
    if not line:  
        break  
    print line  

if f:  
    f.close()  
</code></pre><p>用with关键字可以这样简写了，</p>
<pre><code>from __future__ import with_statement  
with open(&apos;filename&apos;,&apos;r&apos;) as f:  
    for line in f:  
        print line  
</code></pre><p>具体关于with的可以参考<a href="http://jianpx.iteye.com/blog/505469" target="_blank" rel="external">这篇文章</a></p>
<p>##输出数组的index和值：<br>以前是要这样写的：</p>
<pre><code>l = [1,3,4]  
for i in xrange(len(l)):  
    print &apos;%d, %d&apos; % (i , l[i])  
</code></pre><p>现在可以用<strong>enumerate</strong>函数帮助你简写：</p>
<pre><code>l = [1,3, 4]  
for index, value in enumerate(l):  
    print &apos;%d, %d&apos; % (index, value)  
</code></pre><p>##关于使用map、filter、reduce的例子网上很多，这里不细说了，它们的使用也是pythonic的examples</p>
<p>##分隔一个字符串，去里面的元素<code>，</code>,但是空白字符串不要：<br>例如， names = ‘jianpx, yy, mm, , kk’</p>
<pre><code>names = &apos;jianpx, mm, yy, , kk&apos;  
name_list = names.split(&apos;,&apos;)  
result = []  
for name in name_list:  
    if name:  
        result.append(name)  
</code></pre><p>现在是这样写的：</p>
<pre><code>names = &apos;jianpx, yy, mm, , kk&apos;  
result = [name for name in names.split(&apos;,&apos;) if name.strip()]  
</code></pre><p>##模拟c语言中的  a?b:c<br>在python里面可以这样做：</p>
<pre><code>return_value = True if a == 1 else False  
</code></pre><p> 从而代替了这样的代码：</p>
<pre><code>if a == 1:  
    return_value = True  
else   
    return_value = False  
</code></pre><p>##用Decorator抽离公用代码或者解耦<br>例如要对一个函数做cache，对一个操作限制权限，如果需求随时可能变化，就是说有可能不需要做cache或者不需要做权限的时候，你如果把实现放到这些函数体里面，那么这时你必须把这些代码删除，而且要很小心。但是如果你用Decorator去做的话， 只要删除函数头顶上的@那一行就可以了。Django经常用这种方法做权限控制。<br>熟悉decorator的应该都很容易理解。</p>
<p>##如何将list的元素倒序并且生成到新的list呢？ </p>
<p>看到一个用list的slice做到的 :</p>
<pre><code>a = [1,2,3,4]  
c = &apos;abcdef&apos;  
aa= a[::-1]  
cc = c[::-1]  
</code></pre><p> 如果不用生成新的list，直接调用a.reverse()就得了。但是字符串类型没有reverse的方法.</p>
<p>关于list的slice特性， 其实也许很多人平时只是用list[start:end] 这样的， 这个意思是从start开始，每个元素都放到新的list里面， 直到end。但是其实还可以每隔N个元素才取一次的， 这种情况要3个参数:<code>·list[start:end:step]</code>，<code>step</code>就是间隔了。</p>
<p>##a = [i for i in xrange(5)]   和  a = (i for i in xrange(5)) </p>
<p>虽然看上去是一样都生成了5个元素，但是<br>前者是一个list对象， 如果遍历的话 <code>for item in a</code> 就会一下子返回全部元素然后再遍历， 而后者是个Generator，<br>用for item in a遍历是每次只是返回一个元素， 这样的好处是省内存（在list很大的情况下）。</p>
<p>##python的all函数可以简化逻辑表达式有很多”与“的时候的写法<br>比如：</p>
<pre><code>a, b, c = True, False, True
if a and b and c:
    return True
else:
    return False
可以简化成:
    return all([a, b, c])
</code></pre><p>由此可以看到all函数的作用是判断当且仅当参数里面都为真的时候返回真， 否则返回假。</p>
<p>但是这里更深入的话涉及all的判断顺序和传入的参数是list还是iterable对象是不同的。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/MTV-开发模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/MTV-开发模式/" itemprop="url">MTV 开发模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T20:15:05+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们来花点时间考虑下 Django 数据驱动 Web 应用的总体设计。</p>
<p>我们在前面章节提到过，Django 的设计鼓励松耦合及对应用程序中不同部分的严格分割。 遵循这个理念的话，要想修改应用的某部分而不影响其它部分就比较容易了。 在视图函数中，我们已经讨论了通过模板系统把业务逻辑和表现逻辑分隔开的重要性。 在数据库层中，我们对数据访问逻辑也应用了同样的理念。</p>
<p>把<code>数据存取逻辑</code>、<code>业务逻辑</code>和<code>表现逻辑</code>组合在一起的概念有时被称为软件架构的<code>Model-View-Controller (MVC)</code>模式。 在这个模式中， <code>Model</code> 代表数据存取层，<code>View</code>代表的是系统中选择显示什么和怎么显示的部分，<code>Controller</code> 指的是系统中根据用户输入并视需要访问模型，以决定使用哪个视图的那部分。</p>
<p>为什么用缩写？</p>
<p>像 MVC 这样的明确定义模式的主要用于改善开发人员之间的沟通。 比起告诉同事，“让我们采用抽象的数据存取方式，然后单独划分一层来显示数据，并且在中间加上一个控制它的层”，一个通用的说法会让你收益，你只需要说：“我们在这里使用MVC模式吧。”。</p>
<p>Django 紧紧地遵循这种 MVC 模式，可以称得上是一种 MVC 框架。 以下是 Django 中 M、V 和 C 各自的含义：</p>
<ul>
<li><p>M ，数据存取部分，由django数据库层处理，本章(第5章)要讲述的内容。</p>
</li>
<li><p>V ，选择显示哪些数据要显示以及怎样显示的部分，由视图和模板处理。</p>
</li>
<li><p>C ，根据用户输入委派视图的部分，由 Django 框架根据 URLconf 设置，对给定 URL 调用适当的 Python 函数。</p>
</li>
</ul>
<p>由于 C 由框架自行处理，而 Django 里更关注的是<strong>模型（Model）、模板(Template)和视图（Views）</strong>，Django 也被称为 <strong>MTV 框架</strong> 。在 MTV 开发模式中：</p>
<ul>
<li><p>M 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。</p>
</li>
<li><p>T 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。</p>
</li>
<li><p>V 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。</p>
</li>
</ul>
<p>如果你熟悉其它的 MVC Web开发框架，比方说 Ruby on Rails，你可能会认为 Django 视图是控制器，而 Django 模板是视图。 很不幸，这是对 MVC 不同诠释所引起的错误认识。 在 Django 对 MVC 的诠释中，视图用来描述要展现给用户的数据；不是数据 如何展现 ,而且展现 哪些 数据。 相比之下，Ruby on Rails 及一些同类框架提倡控制器负责决定向用户展现哪些数据，而视图则仅决定 如何 展现数据，而不是展现 哪些 数据。</p>
<p>两种诠释中没有哪个更加正确一些。 重要的是要理解底层概念。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/django-locals-技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/django-locals-技巧/" itemprop="url">django-locals()技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T19:54:43+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>思考一下我们对 current_datetime 的最后一次赋值:</p>
<pre><code>def current_datetime(request):
    now = datetime.datetime.now()
    return render_to_response(&apos;current_datetime.html&apos;, {&apos;current_date&apos;: now})
</code></pre><p>很多时候，就像在这个范例中那样，你发现自己一直在计算某个变量，保存结果到变量中（比如前面代码中的 now ），然后将这些变量发送给模板。 尤其喜欢偷懒的程序员应该注意到了，不断地为临时变量和临时模板命名有那么一点点多余。 不仅多余，而且需要额外的输入。</p>
<p>如果你是个喜欢偷懒的程序员并想让代码看起来更加简明，可以利用 Python 的内建函数 locals() 。它返回的字典对所有局部变量的名称与值进行映射。 因此，前面的视图可以重写成下面这个样子：</p>
<pre><code>def current_datetime(request):
    current_date = datetime.datetime.now()
    return render_to_response(&apos;current_datetime.html&apos;, locals())
</code></pre><p>在此，我们没有像之前那样手工指定 context 字典，而是传入了 locals() 的值，<strong>它囊括了函数执行到该时间点时所定义的一切变量</strong>。 因此，我们将 now 变量重命名为 current_date ，因为那才是模板所预期的变量名称。 在本例中， locals() 并没有带来多 大 的改进，但是如果有多个模板变量要界定而你又想偷懒，这种技术可以减少一些键盘输入。</p>
<p><strong>使用 locals() 时要注意是它将包括 所有 的局部变量，它们可能比你想让模板访问的要多。 在前例中， locals() 还包含了 request 。对此如何取舍取决你的应用程序。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/django载入模板的顺序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/django载入模板的顺序/" itemprop="url">Django载入模板的顺序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T19:43:01+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Django默认会在配置文件<code>setting.py</code>的<code>TEMPLATE_LOADERS</code>中开启<code>django.template.loaders.filesystem.Loader</code>，开启该选项后可以按照<code>TEMPLATE_DIRS</code>中列出的路径的先后顺序从中查找并载入模板。</p>
<p>比如有如下配置：</p>
<pre><code>TEMPLATE_LOADERS = (
    &apos;django.template.loaders.filesystem.Loader&apos;,
)
TEMPLATE_DIRS = (
    &apos;/var/www/site/mycitsm/mycitsm/templates&apos;,
    &apos;/var/www/site/mycitsm/sqlreview/templates&apos;,
)
</code></pre><p>现在<code>TEMPLATE_DIRS</code>中指定的两个目录中均存在<code>base.html</code>，渲染模板的语句为 <code>return render(request, &#39;base.html&#39;,context)</code>，<strong>那么Django会优先使用第一个目录中的<code>base.html</code>模板。当第一个目录中不存在<code>base.html</code>时，Django才会使用第二个目录中的base.html模板</strong>。当然，当两个目录都不存在<code>base.html</code>时，会提示找不到模板。因此为了避免混淆，在使用<code>&#39;django.template.loaders.filesystem.Loader&#39;</code>时尽量不要在<code>TEMPLATE_DIRS</code>指定的不同的位置放置同名模板。</p>
<p>如果确实想在不同的位置放置同名模板呢？比如，为了达到程序复用的目的，我们往往会创建一些某个Django APP特定的static文件和template文件，保存在该APP特定的目录中。而我们不能保证这些文件与其他位置的文件不发生重名。因此这里引入了另外一种模板载入模式<code>&#39;django.template.loaders.app_directories.Loader&#39;</code>，<strong>开启该选项后可以从INSTALLED_APPS中已安装app对应的templates/目录中查找要渲染的模板文件</strong>（对于静态文件对应的是app的static/目录）。</p>
<p>比如有如下配置：</p>
<pre><code>TEMPLATE_LOADERS = (
   &apos;django.template.loaders.app_directories.Loader&apos;，
)
TEMPLATE_DIRS = ()
</code></pre><p>这里我们没有在<code>TEMPLATE_DIRS</code> 中指定包含模板文件的路径信息，但由于我们使用的是 <code>&#39;django.template.loaders.app_directories.Loader&#39;</code>载入方式，<strong>他会自动从APP对应的templates目录中查找相应的模板文件</strong>。比如渲染语句为<code>return render(request, &#39;base.html&#39;,context)</code>，APP对应的模板目录为<code>/var/www/site/mycitsm/sqlreview/templates/</code>，只要该目录中存在<code>base.html</code>，Django就会渲染该模板，不存在则提示找不到，除此之外不会从其他地方找该模板文件了。</p>
<p>细心的你可能已经想到了：<strong>要是同时使用了两种载入模板的方式呢？比如同时使用了’django.template.loaders.filesystem.Loader’和’django.template.loaders.app_directories.Loader’会如何查找并载入模板？</strong></p>
<p>比如有如下配置：</p>
<pre><code>TEMPLATE_LOADERS = (
    &apos;django.template.loaders.filesystem.Loader&apos;,
    &apos;django.template.loaders.app_directories.Loader&apos;，
)
TEMPLATE_DIRS = (
    &apos;/var/www/site/mycitsm/mycitsm/templates&apos;,
    &apos;/var/www/site/mycitsm/sqlreview/templates&apos;,
)
</code></pre><p><code>TEMPLATE_DIRS</code>中指定的两个目录内均存在<code>base.html</code>模板，渲染模板的语句为 <code>return render(request, &#39;base.html&#39;,context)</code>，<strong>则Django会先依据<code>TEMPLATE_LOADERS</code>中最先列出的模板载入方式来查找并载入模板，方式同上，若找不到模板文件则使用列出的第二种方式查找，依次类推，直至找到或找不到。这样的话，Django要么找不到模板，要么会载入最先找到的模板，若在多个不同路径下存在同名的模板文件，最终载入的模板与列出的载入方式的顺序和列出的包含模板的目录的顺序嘻嘻相关。这往往是不明确的，极易造成混淆。</strong></p>
<p>因此，通常在APP各自的templates目录中保存APP特定的模板，并不直接在APP对应templates目录中直接存放模板文件本身，而是在该目录中在创建一层以APP名称命名的目录，比如APP名称为sqlreview则存放该APP模板的目录为…/sqlreview/templates/sqlreview/，在指定要渲染的模板时可以通过模板文件的上一层目录来限定模板文件，以避免混淆，这实际上是提供了一个命名空间。比如return render(request, ‘sqlreview/base.html’,context),可以在/var/www/site/mycitsm/sqlreview/templates目录中找到该模板。这样便不用担心Django载入的模板究竟是不是对的、需要的那个模板。</p>
<p>#django 1.8中的改变<br>在django 1.8中，setting里取消了<code>TEMPLATE_LOADERS</code>和<code>TEMPLATE_DIRS</code>设置，用一个<code>TEMPLATES</code>设置来代替</p>
<pre><code>TEMPLATES = [
    {
        &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;,
        &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;blog/templates&apos;),],
        &apos;APP_DIRS&apos;: True,
        &apos;OPTIONS&apos;: {
            &apos;context_processors&apos;: [
                &apos;django.template.context_processors.debug&apos;,
                &apos;django.template.context_processors.request&apos;,
                &apos;django.contrib.auth.context_processors.auth&apos;,
                &apos;django.contrib.messages.context_processors.messages&apos;,
            ],
        },
    },
]
</code></pre><p>其中’DIRS’字段的值是一个列表，用来代替<code>TEMPLATE_DIRS</code>，设置模板的路径</p>
<p><code>TEMPLATES</code>自带的loader是<code>&#39;django.template.loaders.filesystem.Loader&#39;</code>，如果我们想设置loader为<code>&#39;django.template.loaders.app_directories.Loader&#39;</code>，就将<code>APP_DIRS</code>的值设置为TRUE</p>
<p>##补充</p>
<p><code>&#39;django.template.loaders.filesystem.Loader&#39;</code>依赖于’DIRS’的设置，如果’DIRS’是一个空列表的话，他将找不到任何模板</p>
<p><code>&#39;django.template.loaders.app_directories.Loader&#39;</code>会自动去app下面的template目录下寻找模板，所以采用这种方法就无需给’DIRS’赋值</p>
<p>第一部分转载自<a href="http://blog.csdn.net/zyz511919766/article/details/18355827" target="_blank" rel="external">这里</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/django的时区/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/django的时区/" itemprop="url">Django的时区</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T17:20:07+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>视乎你的机器，显示的日期与时间可能和实际的相差几个小时。 这是因为Django是有时区意识的，并且默认时区为<code>America/Chicago</code>。 （它必须有个值，它的默认值是Django的诞生地：美国/芝加哥）如果你处在别的时区，你需要在settings.py文件中更改这个值。请参见它里面的注释，以获得最新世界时区列表。在中国我们设置为<code>Asia/Shanghai</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/13/scp不能拷贝符号链接/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/13/scp不能拷贝符号链接/" itemprop="url">scp不能拷贝符号链接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-13T09:42:34+08:00">
                2015-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天把一个web目录直接scp -r到另一台机器上，发现起不来，后来发现是在配置目录下的一些符号连接都没有拷贝过来。</p>
<p>如果要将这些符号连接拷贝过来，不能直接scp -r这个文件夹，<strong>需要先将文件夹打包，然后拷贝</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">163</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="michaelseu2011@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
