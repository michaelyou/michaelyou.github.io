<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/img/lufei.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/02/丢失私有密钥时连接到虚拟机/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/02/丢失私有密钥时连接到虚拟机/" itemprop="url">丢失私有密钥时连接到虚拟机(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-02T15:01:22+08:00">
                2015-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/openstack/" itemprop="url" rel="index">
                    <span itemprop="name">openstack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有一些镜像制作的时候，只允许使用ssh登陆。所以一般创建虚拟机时，我们会将自己的公钥通过ec2的meta服务写入虚拟机，而后在本地通过和公钥一起生成的私钥登陆。</p>
<p>但是，既然是钥匙，就具备了<code>“丢“</code>的属性，如果我们丢失了本地的私钥，那不就不能登陆虚拟机了？其实倒也不至于不能登陆，只是费事一点罢了。</p>
<p>原理是这样:你需要将本虚拟机的云硬盘(volume)断开，将云硬盘作为数据卷挂载到另一台虚拟机上，然后修改 authorized_keys 文件，将云硬盘挂载回原虚拟机，重启虚拟机即可。</p>
<p><strong>Note</strong>：本教程适用的虚拟机必须是从云硬盘创建的，从<strong>镜像或者快照</strong>创建的请参考<a href="http://michaelyou.github.io/2015/06/05/%E4%B8%A2%E5%A4%B1%E7%A7%81%E6%9C%89%E5%AF%86%E9%92%A5%E6%97%B6%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA-2/" target="_blank" rel="external">丢失私有密钥时连接到虚拟机(2)</a></p>
<p><img src="http://7xj6cl.com1.z0.glb.clouddn.com/launch.png" alt=""></p>
<p>###具体步骤</p>
<ul>
<li>暂停虚拟机，点击左侧导航栏的<strong>云硬盘</strong>，选择本机A的云硬盘，将其从本机断开</li>
<li>还是在<strong>云硬盘</strong>的目录，将此<strong>云硬盘</strong>挂载到另一台虚拟机B</li>
</ul>
<p><img src="http://7xj6cl.com1.z0.glb.clouddn.com/volume.png" alt=""></p>
<ul>
<li><p>登陆到虚拟机B，执行<code>lsblk</code>,命令确定volume是否已分区</p>
<pre><code>ubuntu@key-test1:~$ lsblk
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
vda    253:0    0  10G  0 disk 
└─vda1 253:1    0  10G  0 part /
vdb    253:16   0  10G  0 disk 
└─vdb1 253:17   0  10G  0 part
</code></pre><p>截图中已经说明，<code>在设备/dev/vdb上连接到key_test1</code>，所以最后一行的<code>vdb1</code>就是我们挂载过来的云硬盘。</p>
</li>
<li><p>创建临时目录以安装volume</p>
</li>
</ul>
<pre><code>ubuntu@key-test1:~$ sudo mkdir /mnt/tempvol
</code></pre><ul>
<li><p>使用之前确定的volume名称或设备名称在临时安装点安装volume（或分区）</p>
<pre><code>ubuntu@key-test1:~$ sudo mount /dev/vdb1 /mnt/tempvol
</code></pre></li>
<li><p>这样你进入<code>/mnt/tempvol</code>目录就是进入了挂载的云硬盘，修改<code>authorized_keys</code>文件，删除失效的<code>public_key</code>，添加新的<code>public_key</code></p>
<pre><code>ubuntu@key-test1:~$ vim /mnt/tempvol/home/ubuntu/.ssh/authorized_keys
</code></pre></li>
<li><p>修改完成后，卸载已连接的volume，以将其重新连接至原始实例</p>
<pre><code>ubuntu@key-test1:~$ sudo umount /mnt/tempvol
</code></pre></li>
</ul>
<p><strong>Note</strong>：卸载时可能会出现设备忙的告警，多试几次即可</p>
<p>回到<code>openstack</code>的控制面，将云硬盘重新挂载到机器A，启动机器A即可从拥有私钥的那台机器上登陆</p>
<p>##参考<br><a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html" target="_blank" rel="external">Amazon EC2 Key Pairs</a></p>
<p><a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html" target="_blank" rel="external">Instance Metadata and User Data</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/01/翻译-python中的关键字yield/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/01/翻译-python中的关键字yield/" itemprop="url">[翻译]python中的关键字yield</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-01T14:09:34+08:00">
                2015-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是<a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python/231855#231855" target="_blank" rel="external">stackoverflow上的一个问题</a>，这里翻译的是它得票最多的一个答案</p>
<p>#问题<br>Python关键字yield的作用是什么？用来干什么的？</p>
<p>比如，我正在试图理解下面的代码:</p>
<pre><code>def node._get_child_candidates(self, distance, min_dist, max_dist):
    if self._leftchild and distance - max_dist &lt; self._median:
        yield self._leftchild
    if self._rightchild and distance + max_dist &gt;= self._median:
        yield self._rightchild  
</code></pre><p>下面是这个函数的调用：</p>
<pre><code>result, candidates = list(), [self]
while candidates:
    node = candidates.pop()
    distance = node._get_dist(obj)
    if distance &lt;= max_dist and distance &gt;= min_dist:
        result.extend(node._values)
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))
return result
</code></pre><p>当调用 <code>_get_child_candidates</code>的时候发生了什么？返回了一个列表？返回了一个元素？被重复调用了么？ 什么时候这个调用结束呢？</p>
<p>#回答<br>为了理解什么是 yield,你必须理解什么是生成器。在理解生成器之前，我们需要先理解迭代。</p>
<p>##可迭代对象<br>当你建立了一个列表，你可以逐项地读取这个列表，这叫做一个可迭代对象:</p>
<pre><code>&gt;&gt;&gt; mylist = [1, 2, 3]
&gt;&gt;&gt; for i in mylist :
...    print(i)
1
2
3
</code></pre><p>mylist 是一个可迭代的对象。当你使用一个列表生成式来建立一个列表的时候，就建立了一个可迭代的对象:</p>
<pre><code>&gt;&gt;&gt; mylist = [x*x for x in range(3)]
&gt;&gt;&gt; for i in mylist :
...    print(i)
0
1
4
</code></pre><p>所有你可以应用 <code>for .. in ..</code>语法的叫做一个迭代器：列表，字符串，文件对象……这些可迭代对象易于操作，你可以如你所愿的读取其中的元素。但是你把所有的值都存储到了内存中，如果你有大量数据的话这个方式并不是你想要的。</p>
<p>##生成器<br><strong>生成器是可以迭代的，但是你只可以读取它一次</strong>，因为它并不把所有的值放在内存中，它是<strong>实时地生成数据</strong>:</p>
<pre><code>&gt;&gt;&gt; mygenerator = (x*x for x in range(3))
&gt;&gt;&gt; for i in mygenerator :
...    print(i)
0
1
4
</code></pre><p>看起来除了把 <code>[]</code> 换成 <code>()</code> 外没什么不同。但是，你不可以再次运行 <code>for i in mygenerator</code> , 因为生成器只能被迭代一次：先计算出0，然后继续计算1，然后计算4，一个接一个。</p>
<p>##yield关键字<br><code>yield</code> 是一个类似 <code>return</code> 的关键字，只是这个函数返回的是个生成器。</p>
<pre><code>&gt;&gt;&gt; def createGenerator() :
...    mylist = range(3)
...    for i in mylist :
...        yield i*i
...
&gt;&gt;&gt; mygenerator = createGenerator() # create a generator
&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!
&lt;generator object createGenerator at 0xb7555c34&gt;
&gt;&gt;&gt; for i in mygenerator:
...     print(i)
0
1
4
</code></pre><p>这个例子没什么用途，但是它让你知道，这个函数会返回一大批你只需要读一次的值.</p>
<p>为了精通 <code>yield</code> ,你必须要理解：<strong>当你调用这个函数的时候，函数内部的代码并不立马执行</strong>。这个函数只是返回一个生成器对象，这有点蹊跷不是吗。</p>
<p>那么，函数内的代码什么时候执行呢？当你使用<code>for</code>进行迭代的时候.</p>
<p>现在到了关键点了！</p>
<p>第一次迭代中你的函数会执行，从开始到达 <code>yield</code> 关键字，然后返回 <code>yield</code> 后的值作为第一次迭代的返回值. 然后，每次执行这个函数都会继续执行你在函数内部定义的那个循环的下一次，再返回那个值，直到没有可以返回的。</p>
<p>如果生成器内部没有定义 <code>yield</code> 关键字，那么这个生成器被认为成空的。这种情况可能因为是循环进行没了，或者是没有满足 <code>if/else</code> 条件。</p>
<p>##解释你的代码</p>
<p>生成器:</p>
<pre><code># 在这里定义node对象的方法来返回生成器
def node._get_child_candidates(self, distance, min_dist, max_dist):

  # 每一次你使用生成器对象都会调用这里的代码:

  # 如果node对象仍然有一个左孩子
  # 并且距离合理，返回这个左孩子
  if self._leftchild and distance - max_dist &lt; self._median:
      yield self._leftchild

  # 如果node对象仍然有一个右孩子
  # 并且距离合理，返回这个右孩子
  if self._rightchild and distance + max_dist &gt;= self._median:
      yield self._rightchild

  # 如果函数运行到了这里，生成器就是空的
  # 不可能有除了“左孩子”和“右孩子”之外的值
</code></pre><p>调用者:</p>
<pre><code># 建立一个空列表和一个元素是当前对象引用的列表
result, candidates = list(), [self]

# candidates循环 (一开始只拥有一个元素)
while candidates:

    # 获取最后一个candidate并将其从列表中删除
    node = candidates.pop()

    # 获取obj和这个candidate之间的距离        
    distance = node._get_dist(obj)

    # 如果距离ok，追加到result
    if distance &lt;= max_dist and distance &gt;= min_dist:
        result.extend(node._values)

    # 将candidate的孩子添加到candidate列表中
    # 循环会一直进行下去，知道遍历了孩子节点的孩子节点的孩子
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))

return result
</code></pre><p>这个代码包含了几个小部分：</p>
<ul>
<li>我们对一个列表进行迭代，但是迭代中列表还在不断的扩展。它是一个迭代这些嵌套的数据的简洁方式，即使这样有点危险，因为可能导致无限迭代。 <code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</code> 穷尽了生成器的所有值，但 <code>while</code> 不断地在产生新的生成器，它们会产生和上一次不一样的值，既然没有作用到同一个节点上.</li>
<li><code>extend()</code> 是一个迭代器方法，作用于迭代器，并把参数追加到迭代器的后面。</li>
</ul>
<p>通常我们传给它一个列表参数:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2]
&gt;&gt;&gt; b = [3, 4]
&gt;&gt;&gt; a.extend(b)
&gt;&gt;&gt; print(a)
[1, 2, 3, 4]
</code></pre><p>但是在你的代码中的是一个生成器，这样做很好，因为：</p>
<ol>
<li>你不必读两次所有的值</li>
<li>你可以有很多子对象，但不必叫他们都存储在内存里面。</li>
</ol>
<p>并且这很奏效，因为Python不关心一个方法的参数是不是个列表。Python只希望它是可以迭代的，所以这个参数可以是列表，元组，字符串，生成器… 这叫做 <code>duck typing</code>,这也是为何Python如此棒的原因之一，但这已经是另外一个故事了…</p>
<p>你可以在这里停下，或者来看看生成器的一些高级用法:</p>
<p>##控制生成器的穷尽</p>
<pre><code>&gt;&gt;&gt; class Bank(): # let&apos;s create a bank, building ATMs
...    crisis = False
...    def create_atm(self) :
...        while not self.crisis :
...            yield &quot;$100&quot;
&gt;&gt;&gt; hsbc = Bank() # when everything&apos;s ok the ATM gives you as much as you want
&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()
&gt;&gt;&gt; print(corner_street_atm.next())
$100
&gt;&gt;&gt; print(corner_street_atm.next())
$100
&gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])
[&apos;$100&apos;, &apos;$100&apos;, &apos;$100&apos;, &apos;$100&apos;, &apos;$100&apos;]
&gt;&gt;&gt; hsbc.crisis = True # crisis is coming, no more money!
&gt;&gt;&gt; print(corner_street_atm.next())
&lt;type &apos;exceptions.StopIteration&apos;&gt;
&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # it&apos;s even true for new ATMs
&gt;&gt;&gt; print(wall_street_atm.next())
&lt;type &apos;exceptions.StopIteration&apos;&gt;
&gt;&gt;&gt; hsbc.crisis = False # trouble is, even post-crisis the ATM remains empty
&gt;&gt;&gt; print(corner_street_atm.next())
&lt;type &apos;exceptions.StopIteration&apos;&gt;
&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # build a new one to get back in business
&gt;&gt;&gt; for cash in brand_new_atm :
...    print cash
$100
$100
$100
$100
$100
$100
$100
$100
$100
...
</code></pre><p>对于控制一些资源的访问来说这很有用。</p>
<p>##Itertools,你最好的朋友<br>itertools包含了很多特殊的迭代方法。是不是曾想过复制一个迭代器?串联两个迭代器？把嵌套的列表分组？不用创造一个新的列表的 zip/map?</p>
<p>只要 <code>import itertools</code></p>
<p>需要个例子？让我们看看比赛中4匹马可能到达终点的先后顺序的可能情况:</p>
<pre><code>&gt;&gt;&gt; horses = [1, 2, 3, 4]
&gt;&gt;&gt; races = itertools.permutations(horses)
&gt;&gt;&gt; print(races)
&lt;itertools.permutations object at 0xb754f1dc&gt;
&gt;&gt;&gt; print(list(itertools.permutations(horses)))
[(1, 2, 3, 4),
 (1, 2, 4, 3),
 (1, 3, 2, 4),
 (1, 3, 4, 2),
 (1, 4, 2, 3),
 (1, 4, 3, 2),
 (2, 1, 3, 4),
 (2, 1, 4, 3),
 (2, 3, 1, 4),
 (2, 3, 4, 1),
 (2, 4, 1, 3),
 (2, 4, 3, 1),
 (3, 1, 2, 4),
 (3, 1, 4, 2),
 (3, 2, 1, 4),
 (3, 2, 4, 1),
 (3, 4, 1, 2),
 (3, 4, 2, 1),
 (4, 1, 2, 3),
 (4, 1, 3, 2),
 (4, 2, 1, 3),
 (4, 2, 3, 1),
 (4, 3, 1, 2),
 (4, 3, 2, 1)]
</code></pre><p>##迭代器的内部机理<br>迭代是一个实现可迭代对象(实现的是 <code>__iter__()</code> 方法)和迭代器(实现的是 <code>__next__()</code>方法)的过程。可迭代对象是你可以从其获取到一个迭代器的任一对象。迭代器是那些允许你迭代可迭代对象的对象。</p>
<p>更多见这个文章 <a href="http://effbot.org/zone/python-for-statement.htm" target="_blank" rel="external">for循环是怎么工作的</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/26/解决-mac删除系统自带python后一些软件崩溃/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/26/解决-mac删除系统自带python后一些软件崩溃/" itemprop="url">[解决]mac删除系统自带python后一些软件崩溃</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-26T13:14:56+08:00">
                2015-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mac/" itemprop="url" rel="index">
                    <span itemprop="name">mac</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>mac 10.10.3</code>自带的python版本是<code>2.6</code>，而<code>2.0</code>版本现在已经不再更新，最终版是<code>2.7.9</code>。很多同学都会给mac装上最新版本来代替系统自带版本。有一些教程还好，会让你保存<code>2.6</code>。有一些就糟糕了，它会让你直接用<code>2.7</code>(或者<code>3.4</code>)来覆盖<code>2.6</code>。这样在终端中是没有问题的，但是有一些应用程序，比如<code>iPhoto</code>和<code>sublime</code>，它们依赖于系统的<code>2.6</code>，一旦找不到<code>2.6</code>的版本，打开软件就会崩溃。其实问题是很简单的，网上有一些答案，这里讲一下我的解决方法。</p>
<p>首先，你需要找到你的新版的python的安装路径<br>系统默认的是在</p>
<pre><code>/System/Library/Frameworks/Python.framework/Versions/2.7
</code></pre><p>如果你是用homebrew安装的python，那么应该在</p>
<pre><code>/usr/local/Cellar/python/2.7.9/Frameworks/Python.framework/Versions/2.7/
</code></pre><p>我们不需要再安装2.6的版本，只需要创建一个软链接即可：</p>
<pre><code>sudo ln -s /usr/local/Cellar/python/2.7.9/Frameworks/Python.framework/Versions/2.7/ /System/Library/Frameworks/Python.framework/Versions/2.6
</code></pre><p>第一个路径即是你的python的安装路径</p>
<p>PS1：<br>如果你打开软件显示<code>*** import error</code>，那是说明你的这个版本没有安装这个模块，<code>pip</code>安装即可。</p>
<p>PS2：<br>如果需要使用新版的python，还是建议大家使用<a href="https://github.com/yyuu/pyenv" target="_blank" rel="external">pyenv</a>，既能安装多个版本又不会搞乱系统，非常NB。</p>
<p>##参考资料</p>
<p><a href="https://apple.stackexchange.com/questions/114195/iphoto-and-python-2-6/140941#140941?newreg=cb8af983a6f248868b5043d1ec14d418" target="_blank" rel="external">Ask Different –Iphoto and Python2.6</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/25/使用traceback追踪异常/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/25/使用traceback追踪异常/" itemprop="url">使用traceback追踪异常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-25T21:34:20+08:00">
                2015-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>调试代码的时候，简单的try—except语句只能告诉我们哪里出了错，但是错误的根源可能在多个函数之前，所以我们有必要知道出现错误时的堆栈情况。python提供了traceback模块来帮助我们打印堆栈。</p>
<p>一般来说程序都是将信息写入log，所以这里以写入log为例</p>
<pre><code>import class
import logging

if __name__==&quot;__main__&quot;:
    logging.basicConfig(filename=&apos;trace.log&apos;)
    try:
        excep_class.except_fun(excep_args)
    except:
        s=traceback.format_exc()
        logging.error(s)
</code></pre><p>这样就可以打印出程序发生异常时，堆栈的信息。</p>
<pre><code>---Traceback (most recent call last):
  File &quot;/usr/lib/python2.7/dist-packages/keystoneclient/middleware/auth_token.py&quot;, line 578, in __call__
    token_info = self._validate_user_token(user_token, env)
  File &quot;/usr/lib/python2.7/dist-packages/keystoneclient/middleware/auth_token.py&quot;, line 838, in _validate_user_token
    raise InvalidUserToken(&apos;Token authorization failed&apos;)
InvalidUserToken: Token authorization failed
</code></pre><p>这里是一段出错信息，可以明显地看出，最上面的是最早调用的函数，上面的函数调用下面的函数，最后一个是最终出错的地方。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/22/Django国际化遇到的神坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/22/Django国际化遇到的神坑/" itemprop="url">Django国际化遇到的神坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-22T00:14:23+08:00">
                2015-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>配置完全是按照文档来，检查了一遍又一遍。来回地创建po，mo文件，可是web就是不显示中文，Django你坏了还是我坏了？</p>
<p>django国际化的问题纠缠了我5个小时，我从没有如此痛苦过，因为我很清楚这是一个很小的问题，但是因为没法调试，没有log，我根本不知道问题出在哪里。谁能TMD知道不能用<code>-</code>啊，草泥马！！！</p>
<p>解决方案：</p>
<p>语言包不要有<code>-</code>，例如语言包是<code>zh-hans</code>, 请将其改成<code>zh_hans</code>，其他地方的<code>zh-hans</code>不需要修改。</p>
<p>如果说这也能称为知识的话，我真是日了狗了。</p>
<p>django现在对<code>zh-cn</code>, <code>zh-CN</code>都不支持了，用了这些的话Django会提醒你：</p>
<pre><code>The use of the language code &apos;zh-cn&apos; is deprecated. Please use the &apos;zh-hans&apos; translation instead.
</code></pre><p>其实直接用<code>zh</code>也可以，而且，他还会主动到<code>zh_hans</code>的语言包里去找它里面没有翻译的内容。虽然我很想赞叹一声，但是竟然要这样区分<code>-</code>和<code>_</code>，我也是醉了。</p>
<p>切记切记，语言包的名称中不要有<code>-</code>!!!</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/20/为什么搬家之后手机地图定位仍是在原来的地方-Google-WiFi-定位的原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/20/为什么搬家之后手机地图定位仍是在原来的地方-Google-WiFi-定位的原理/" itemprop="url">搬家后手机地图定位仍在原来的地方--Google WiFi定位的原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-20T23:27:32+08:00">
                2015-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/长知识/" itemprop="url" rel="index">
                    <span itemprop="name">长知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前几天刚搬家，到了新家拿出手机，却发现手机地图的定位还是在原来的地方，怎么重新定位都不准确。过了两天却又好了，我以为是正常的延迟或者误差，就没把这事放在心上。今天看到了这篇文章终于恍然大悟，不禁感叹，生活处处是学问啊！</p>
<p>原文是一位台湾同行写的，是繁体字，我改成了简体贴在这里与大家共享，原文在<a href="http://www.dearhoney.idv.tw/?p=1293" target="_blank" rel="external">这里</a></p>
<hr>
<p>以前我不了解Google WiFi 定位时，一直对这技术嗤之以鼻，我想说从IP Address 哪里能定位到很精准，最多就是从一些公开的IP to GEO 资料库可以查询到这个IP 是在那个城市，是没办法精准定位的。</p>
<p>可是随着我发现没有GPS 卫星定位功能的iPod Touch 在打开WiFi 的情况下竟然可以在Google 地图上精准到我所在地的附近，这就引起了我很大的好奇心，到底这是怎么做到的？显然不可能是靠IP Address 去查询啊？</p>
<p>看了一些简体与繁体的文件，实在是觉得扯太远扯太多，还是没看到精髓处，所以直接从英文去查吧！果然查到了不少资料，也就了解Google WiFi 定位的原理了。在这之前先把几个名词给解释一下。</p>
<p><strong>GPS卫星定位</strong>：靠的是环绕在地球四周的数颗卫星发送讯号到地面，交叉连集出所在地的方法。从十几年前开始出现汽车导航产品，就是使用这种技术。初次定位时常要花上一分钟以上的时间，这也是目前汽车导航和智慧型手机都有提供的定位方式。当有遮蔽物阻挡来自天空的讯号时就会发生定位的困难。</p>
<p><strong>A-GPS定位</strong>：靠着事先下载星历资料，能够加速上述GPS定位的初次定位速度。由于一般车用导航机都不具备网路连线能力因此无法事先下载星历资料，所以也都不具备A-GPS定位。</p>
<p><strong>手机基地台定位</strong>：靠的是侦测到的手机基地台(Cell Tower)，比对资料库以及信号强度，交叉连集出所在地的方法。也因为要能够侦测手机基地台，所以一般车用导航机因不具备手机电话能力而无法 提供，几乎可以说手机基地台定位是智慧型手机或者能够插手机SIM卡的平板电脑才可以提供的功能。此法尚须有网路连线做资料库查询才能完成定位。</p>
<p><img src="http://7xj6cl.com1.z0.glb.clouddn.com/GoogleWiFi_CellTower.png" alt="附近手机基地台真多啊"></p>
<p><strong>WIFI定位</strong>：靠的是侦测附近周围所有的无线网路基地台（无线接入点）的MAC地址（类似10-78-D2-93-58-C2这样的格式），去比对资料库中该MAC地址的座標，交叉連集出所在地。此法尚須有網路連線做資料庫查詢才能完成定位。</p>
<p>所以问题来了：这份无线网路基地台MAC地址对应到经纬度的资料库，是怎么建立起来的呢？</p>
<p>基础建设靠的是谷歌街景车。谷歌街景车除了拍下街景以外，另外还做了两件事情(信息来源：<a href="http://googlepolicyeurope.blogspot.com/2010/04/data-collected-by-google-cars.html" target="_blank" rel="external">google blog</a>)：</p>
<p>沿路搜集所有公开的无线网路MAC地址，与当时的经纬度一并记录。<br>根据拍下的街景来建立建筑物的3D模型资料。</p>
<p><img src="http://7xj6cl.com1.z0.glb.clouddn.com/GoogleWiFi_3Dbuilding.png" alt="此效果截至本文刊出时仅能在谷歌Android手机上看到"></p>
<p>但資料庫一定會面臨過期與需要更新的問題，這時候全世界有在使用行動裝置谷歌+定位程式的人，等于是在不知不觉中帮忙做这件事情。更新的方法是当无线网络与手机基地台定位或GPS定位同时开启时，手持装置藉由手机基地台定位或GPS定位这两种方式可以获得目前的座标，再透过无线网络搜寻到附近所有的MAC地址，背后向谷歌的资料库做更新。（信息来源：<a href="http://www.google.com/support/forum/p/Google%20Mobile/thread?tid=6bef39e72c3abbb5&amp;hl=en" target="_blank" rel="external">谷歌员工克里斯托弗的公开说法</a>）</p>
<p>說穿了技術其實不難，但這麼龐大的資料庫，又能夠不痛不癢的號召每個行動裝置幫忙更新維護這份資料庫，大概也只有谷歌做得来了。</p>
<p>知道了原理之后，衍生出来的就是一些隐私权的问题。</p>
<p>首先就是谷歌搜集无线网络的MAC地址资讯合法吗？德国政府去年对此提出疑虑，而谷歌认为合法，两造后来怎么样了我懒得去追，反正从技术上来看，MAC地址在網路上要能夠被查詢到，那麼你與對方之間不能有路由器存在，一旦過了路由器那麼原始MAC地址就會被替換(詳細的原理這邊就不多說了)，所以一般人雖然可以用很多方法去找出對方的IP地址，但对方的MAC地址就没办法了，中间经过的路由器太多啦！也就无法利用MAC地址去查對方身處何處。除非將木馬植入對方電腦來回報，且對方有在使用無線網路而且他附近的無線網路基地台有被登記到谷歌資料庫中，那才有機會找到對方所在地附近，但這難度又高條件又多，對警察來說還是用IP地址行文法院与电信业者来找精确的地址最快。</p>
<p>所以回头来说隐私权，我个人觉得应该是不会，且无线网络的MAC地址是屬於公開資訊，並非刻意用什麼非法手段才能取得。一般人就算探測到你的MAC地址，也不晓得你是谁或什么人在使用。</p>
<p>再来就是定位错误的问题。</p>
<p>搬家后其无线网路基地台也跟着移动，那么以无线网络定位來看自己身在何處，可能會呈現仍然在上一個住所的問題。針對這種因為資料庫尚未被更新而產生的定位錯誤問題，Google提供了一个<a href="https://services.google.com/fb/forms/wifibugs/" target="_blank" rel="external">无线网路定位错误的表格</a>来申请回报，但一如一般谷歌的服務一樣，這表格並不能保證立即得到回應。想要加速更新資料庫，除了填寫這份表格以外，另外就是自己時常拿行動裝置開著无线+ GPS定位吧，这是刚才提过的资料库更新法，总有一天谷歌会因为你与行动装置的努力而修正过来的。😛</p>
<p>回头看我一开始以为谷歌的WiFi定位是靠着IP地址来定位，真是大错特错了啊！谷歌要的只是侦测到无线基地台的MAC地址就可以，也没有强调一定要与无线基地台连线，只要打开行动装置的无线网络功能，让谷歌定位可以藉由无线去搜集附近可侦测的MAC地址，接着透过3G行动上网或此时你真的有无线网络连线，就可以去向谷歌资料库查询这些MAC地址连集起来的可能位置，就这样完成定位了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/19/翻译-python招聘指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/19/翻译-python招聘指南/" itemprop="url">[翻译]python招聘指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-19T20:52:20+08:00">
                2015-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文在<a href="http://www.toptal.com/python/#hiring-guide" target="_blank" rel="external">这里toptal</a></p>
<p>##python专家or Snake in the Grass?</p>
<p><img src="http://7xj6cl.com1.z0.glb.clouddn.com/toptal-blog-image.png" alt=""></p>
<p>你已经发现什么样的表现是一个python高手。但是在你该如何确定你的top 1%精英候选者也是呢？尽管没有魔法或者万无一失的技术，但是确实有一些问题可以帮助你确定候选者对这门语言认识的深度。下面简要地列举了一些这样的问题。</p>
<p><strong>重要的是，这些样题仅仅旨在作为指导。不是所有的值得招聘的“A”级候选人都能正确地回答所有这些问题。同样，能正确回答所有问题也不能保证他/她就是一个“A”级候选人。招聘是一门科学，同样也是一门艺术。</strong></p>
<p>##杂草中的蟒蛇…</p>
<p>尽管确实最优秀的开发者不会浪费时间记住一些能轻易在语言手册或者API文档中找到的知识，但是，仍然有一些关键的特性和能力，任何编程语言的每个专家都能，并且应该<br>精通。这里就是一些python特定的例子。</p>
<p>###Q：为什么要用函数装饰器？请举例</p>
<p>装饰器本质上是用来修改，扩展函数或类定义的可调用Python对象。装饰器的一个美丽之处是，单个装饰器定义可作用于多种函数（或类）。大部分功能从而可以用装饰器实现，否则将需要大量的样板（或更糟多余的！）代码。例如<a href="http://flask.pocoo.org/" target="_blank" rel="external">Flask</a>，使用装饰器的机制来添加新的端点到web应用程序。一些装饰器的更常见的用途包括：增加同步，类型强制执行，日志，或前/后条件到一个类或函数。</p>
<p>###Q：什么是lambda表达式，列表解析和生成器表达式？各有什么优势和适当的用途？</p>
<p>lambda表达式是一种快速创建单行匿名函数的方法。它的简单，内联的本质往往-虽然不是总是-可以让代码比用正常函数定义方法更加可读和简洁。但另一方面，它的内联本质也极大地限制了它能做的事情。Being anonymous and inline, the only way to use the same lambda function in multiple locations in your code is to specify it redundantly.</p>
<p>List comprehensions provide a concise syntax for creating lists. List comprehensions are commonly used to make lists where each element is the result of some operation(s) applied to each member of another sequence or iterable. They can also be used to create a subsequence of those elements whose members satisfy a certain condition. In Python, list comprehensions provide an alternative to using the built-in map() and filter() functions.</p>
<p>As the applied usage of lambda expressions and list comprehensions can overlap, opinions vary widely as to when and where to use one vs. the other. One point to bear in mind, though, is that a list comprehension executes somewhat faster than a comparable solution using map and lambda (some quick tests yielded a performance difference of roughly 10%). This is because calling a lambda function creates a new stack frame while the expression in the list comprehension is evaluated without doing so.</p>
<p>Generator expressions are syntactically and functionally similar to list comprehensions but there are some fairly significant differences between the ways the two operate and, accordingly, when each should be used. In a nutshell, iterating over a generator expression or list comprehension will essentially do the same thing, but the list comprehension will create the entire list in memory first while the generator expression will create the items on the fly as needed. Generator expressions can therefore be used for very large (and even infinite) sequences and their lazy (i.e., on demand) generation of values results in improved performance and lower memory usage. It is worth noting, though, that the standard Python list methods can be used on the result of a list comprehension, but not directly on that of a generator expression.</p>
<p>###Q：考虑下面初始化列表的两种方法和产生的列表。所产生的列表将如何不同，为什么要使用这一初始化方法而不是另一个？</p>
<pre><code>&gt;&gt;&gt; # INITIALIZING AN ARRAY -- METHOD 1
...
&gt;&gt;&gt; x = [[1,2,3,4]] * 3
&gt;&gt;&gt; x
[[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; # INITIALIZING AN ARRAY -- METHOD 2
...
&gt;&gt;&gt; y = [[1,2,3,4] for _ in range(3)]
&gt;&gt;&gt; y
[[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]
&gt;&gt;&gt;
&gt;&gt;&gt; # WHICH METHOD SHOULD YOU USE AND WHY?
</code></pre><p>虽然这两种方法乍一看产生的结果相同，但两者之间的差异极其显著。如你所料，方法2产生有3个元素的列表，每个元素本身就是一个独立的4元素的列表。然而，在方法1中，列表的元素(4元素列表)都指向同一个对象。这会导致我们最始料未及和最不希望的行为，如下所示。</p>
<pre><code>&gt;&gt;&gt; # MODIFYING THE x ARRAY FROM THE PRIOR CODE SNIPPET:
&gt;&gt;&gt; x[0][3] = 99
&gt;&gt;&gt; x
[[1, 2, 3, 99], [1, 2, 3, 99], [1, 2, 3, 99]]
&gt;&gt;&gt; # UH-OH, DON’T THINK YOU WANTED THAT TO HAPPEN!
...
&gt;&gt;&gt;
&gt;&gt;&gt; # MODIFYING THE y ARRAY FROM THE PRIOR CODE SNIPPET:
&gt;&gt;&gt; y[0][3] = 99
&gt;&gt;&gt; y
[[1, 2, 3, 99], [1, 2, 3, 4], [1, 2, 3, 4]]
&gt;&gt;&gt; # THAT’S MORE LIKE WHAT YOU EXPECTED!
...
</code></pre><p>###Q： 下面的第二个append()语句输出什么？</p>
<pre><code>&gt;&gt;&gt; def append(list=[]):
...     # append the length of a list to the list
...     list.append(len(list))
...     return list
...
&gt;&gt;&gt; append([&apos;a&apos;,&apos;b&apos;])
[&apos;a&apos;, &apos;b&apos;, 2]
&gt;&gt;&gt;
&gt;&gt;&gt; append()  # calling with no arg uses default list value of []
[0]
&gt;&gt;&gt;
&gt;&gt;&gt; append()  # but what happens when we AGAIN call append with no arg?
</code></pre><p>如果一个函数参数的默认值是一个表达式，这个表达式仅被执行一次，而不是每次这个函数被调用都被执行。因此，一旦列表参数已经被初始化为了一个空列表，后续调用append函数时，如果不指定参数list，将会继续使用之前初始化的同一个列表。这会引起下面的意外行为：</p>
<pre><code>&gt;&gt;&gt; append()  # first call with no arg uses default list value of []
[0]
&gt;&gt;&gt; append()  # but then look what happens...
[0, 1]
&gt;&gt;&gt; append()  # successive calls keep extending the same default list!
[0, 1, 2]
&gt;&gt;&gt; append()  # and so on, and so on, and so on...
[0, 1, 2, 3]
</code></pre><p>###Q：在上述问题中，如何修改append方法的实现来避免描述的不当行为？</p>
<p>下面的append方法的替代实现是避免上述问题答案描述的不当行为的一个方法：</p>
<pre><code>&gt;&gt;&gt; def append(list=None):
...     if list is None:
            list = []
        # append the length of a list to the list
...     list.append(len(list))
...     return list
...
&gt;&gt;&gt; append()
[0]
&gt;&gt;&gt; append()
[0]
</code></pre><p>###Q：如何用一行python代码交换两个变量的值？</p>
<p>考虑这个简单的例子：</p>
<pre><code>&gt;&gt;&gt; x = &apos;X&apos;
&gt;&gt;&gt; y = &apos;Y&apos;
</code></pre><p>在很多语言中，交换x和y的值需要你进行以下的操作：</p>
<pre><code>&gt;&gt;&gt; tmp = x
&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = tmp
&gt;&gt;&gt; x, y
(&apos;Y&apos;, &apos;X&apos;)
</code></pre><p>但是在python中，你可以用一行代码完成swap功能（感谢元组隐式的打包和解包）</p>
<pre><code>&gt;&gt;&gt; x,y = y,x
&gt;&gt;&gt; x,y
(&apos;Y&apos;, &apos;X&apos;)
</code></pre><p>###Q：下面代码中最后一个表达式的输出是什么？</p>
<pre><code>&gt;&gt;&gt; flist = []
&gt;&gt;&gt; for i in range(3):
...     flist.append(lambda: i)
...
&gt;&gt;&gt; [f() for f in flist]   # what will this print out?
</code></pre><p>在Python的闭包中，变量都是通过名字来绑定。因此，上面代码的输出如下：</p>
<pre><code>[2, 2, 2]
</code></pre><p>可能并不是代码的作者预料的结果!</p>
<p>一个替代方法是：可以创建一个独立的函数，或者通过名字传递参数；比如：</p>
<pre><code>&gt;&gt;&gt; flist = []
&gt;&gt;&gt; for i in range(3):
...     flist.append(lambda i = i : i)
...
&gt;&gt;&gt; [f() for f in flist]
[0, 1, 2]
</code></pre><p>###Q: Python2和3之间的主要区别是什么？</p>
<p>尽管Python2现在被认为是遗留之物，但是对一个开发者来说，因为Python2使用广泛，知道Python2和Python3之间的区别是非常重要的。</p>
<p>这里是开发者应该了解的一些关键差异：</p>
<p>Text and Data instead of Unicode and 8-bit strings. Python 3.0 uses the concepts of text and (binary) data instead of Unicode strings and 8-bit strings. The biggest ramification of this is that any attempt to mix text and data in Python 3.0 raises a TypeError (to combine the two safely, you must decode bytes or encode Unicode, but you need to know the proper encoding, e.g. UTF-8)</p>
<p>This addresses a longstanding pitfall for naïve Python programmers. In Python 2, mixing Unicode and 8-bit data would work if the string happened to contain only 7-bit (ASCII) bytes, but you would get UnicodeDecodeError if it contained non-ASCII values. Moreover, the exception would happen at the combination point, not at the point at which the non-ASCII characters were put into the str object. This behavior was a common source of confusion and consternation for neophyte Python programmers.</p>
<p>print函数. <code>print表达式</code>已经被一个<code>print()函数</code>替代</p>
<p>xrange – buh-bye. <code>xrange()</code>不再存在(<code>range()</code>现在的效果和<code>xrange()</code>一样，except it works with values of arbitrary size) </p>
<p><strong>API changes</strong>:</p>
<ul>
<li><p>zip(), map() and filter() all now return iterators instead of lists</p>
</li>
<li><p>dict.keys(), dict.items() and dict.values() now return “views” instead of lists</p>
</li>
<li><p>dict.iterkeys(), dict.iteritems() and dict.itervalues() are no longer supported</p>
</li>
<li><p>Comparison operators. The ordering comparison operators (&lt;, &lt;=, &gt;=, &gt;) now raise a TypeError exception when the operands don’t have a meaningful natural ordering. Some examples of the ramifications of this include:</p>
</li>
</ul>
<blockquote>
<p>Expressions like 1 &lt; ‘’, 0 &gt; None or len &lt;= len are no longer valid<br>None &lt; None now raises a TypeError instead of returning False</p>
</blockquote>
<ul>
<li>Sorting a heterogeneous list no longer makes sense – all the elements must be comparable to each other</li>
</ul>
<p>更多关于Python2和Python3的区别可以参考<a href="https://docs.python.org/3/whatsnew/3.0.html" target="_blank" rel="external">这里</a>。</p>
<p>###Q: Python是解释型的还是编译型的？</p>
<p>As noted in Why Are There So Many Pythons?, this is, frankly, a bit of a trick question in that it is malformed. Python itself is nothing more than an interface definition (as is true with any language specification) of which there are multiple implementations. Accordingly, the question of whether “Python” is interpreted or compiled does not apply to the Python language itself; rather, it applies to each specific implementation of the Python specification.</p>
<p>Further complicating the answer to this question is the fact that, in the case of CPython (the most common Python implementation), the answer really is “sort of both”. Specifically, with CPython, code is first compiled and then interpreted. More precisely, it is not precompiled to native machine code, but rather to bytecode. While machine code is certainly faster, bytecode is more portable and secure. The bytecode is then interpreted in the case of CPython (or both interpreted and compiled to optimized machine code at runtime in the case of PyPy).</p>
<p>###Q: 有哪些CPython的替代实现？什么时候，为什么会使用他们？</p>
<p>One of the more prominent alternative implementations is Jython, a Python implementation written in Java that utilizes the Java Virtual Machine (JVM). While CPython produces bytecode to run on the CPython VM, Jython produces Java bytecode to run on the JVM.</p>
<p>Another is IronPython, written in C# and targeting the .NET stack. IronPython runs on Microsoft’s Common Language Runtime (CLR).</p>
<p>As also pointed out in Why Are There So Many Pythons?, it is entirely possible to survive without ever touching a non-CPython implementation of Python, but there are advantages to be had from switching, most of which are dependent on your technology stack.</p>
<p>Another noteworthy alternative implementation is PyPy whose key features include:</p>
<p>Speed. Thanks to its Just-in-Time (JIT) compiler, Python programs often run faster on PyPy.</p>
<p>Memory usage. Large, memory-hungry Python programs might end up taking less space with PyPy than they do in CPython.</p>
<p>Compatibility. PyPy is highly compatible with existing python code. It supports cffi and can run popular Python libraries like Twisted and Django.</p>
<p>Sandboxing. PyPy provides the ability to run untrusted code in a fully secure way.</p>
<p>Stackless mode. PyPy comes by default with support for stackless mode, providing micro-threads for massive concurrency.</p>
<p>###Q: What’s your approach to unit testing in Python?</p>
<p>The most fundamental answer to this question centers around Python’s unittest testing framework. Basically, if a candidate doesn’t mention unittest when answering this question, that should be a huge red flag.</p>
<p>unittest supports test automation, sharing of setup and shutdown code for tests, aggregation of tests into collections, and independence of the tests from the reporting framework. The unittest module provides classes that make it easy to support these qualities for a set of tests.</p>
<p>Assuming that the candidate does mention unittest (if they don’t, you may just want to end the interview right then and there!), you should also ask them to describe the key elements of the unittest framework; namely, test fixtures, test cases, test suites and test runners.</p>
<p>A more recent addition to the unittest framework is mock. mock allows you to replace parts of your system under test with mock objects and make assertions about how they are to be used. mock is now part of the Python standard library, available as unittest.mock in Python 3.3 onwards.</p>
<p>The value and power of mock are well explained in An Introduction to Mocking in Python. As noted therein, system calls are prime candidates for mocking: whether writing a script to eject a CD drive, a web server which removes antiquated cache files from /tmp, or a socket server which binds to a TCP port, these calls all feature undesired side-effects in the context of unit tests. Similarly, keeping your unit-tests efficient and performant means keeping as much “slow code” as possible out of the automated test runs, namely filesystem and network access.</p>
<hr>
<p>####[注意:这个问题针对的是同样有java开发经验的python开发者.]</p>
<p>###Q: What are some key differences to bear in mind when coding in Python vs. Java?</p>
<p>Disclaimer #1. The differences between Java and Python are numerous and would likely be a topic worthy of its own (lengthy) post. Below is just a brief sampling of some key differences between the two languages.</p>
<p>Disclaimer #2. The intent here is not to launch into a religious battle over the merits of Python vs. Java (as much fun as that might be!). Rather, the question is really just geared at seeing how well the developer understands some practical differences between the two languages. The list below therefore deliberately avoids discussing the arguable advantages of Python over Java from a programming productivity perspective.</p>
<p>With the above two disclaimers in mind, here is a sampling of some key differences to bear in mind when coding in Python vs. Java:</p>
<p>Dynamic vs static typing. One of the biggest differences between the two languages is that Java is restricted to static typing whereas Python supports dynamic typing of variables.</p>
<p>Static vs. class methods. A static method in Java does not translate to a Python class method.</p>
<p>In Python, calling a class method involves an additional memory allocation that calling a static method or function does not.</p>
<p>In Java, dotted names (e.g., foo.bar.method) are looked up by the compiler, so at runtime it really doesn’t matter how many of them you have. In Python, however, the lookups occur at runtime, so “each dot counts”.</p>
<p>Method overloading. Whereas Java requires explicit specification of multiple same-named functions with different signatures, the same can be accomplished in Python with a single function that includes optional arguments with default values if not specified by the caller.</p>
<p>Single vs. double quotes. Whereas the use of single quotes vs. double quotes has significance in Java, they can be used interchangeably in Python (but no, it won’t allow beginnning the same string with a double quote and trying to end it with a single quote, or vice versa!).</p>
<p>Getters and setters (not!). Getters and setters in Python are superfluous; rather, you should use the ‘property’ built-in (that’s what it’s for!). In Python, getters and setters are a waste of both CPU and programmer time.</p>
<p>Classes are optional. Whereas Java requires every function to be defined in the context of an enclosing class definition, Python has no such requirement.</p>
<p>Indentation matters… in Python. This bites many a newbie Python programmer.</p>
<p><strong>The Big Picture</strong></p>
<p>An expert knowledge of Python extends well beyond the technical minutia of the language. A Python expert will have an in-depth understanding and appreciation of Python’s benefits as well as its limitations. Accordingly, here are some sample questions that can help assess this dimension of a candidate’s expertise:</p>
<p>###Q: What is Python particularly good for? When is using Python the “right choice” for a project?</p>
<p>Although likes and dislikes are highly personal, a developer who is “worth his or her salt” will highlight features of the Python language that are generally considered advantageous (which also helps answer the question of what Python is “particularly good for”). Some of the more common valid answers to this question include:</p>
<p>便于使用和重构，感谢Python灵活的语法，让它在快速建模时非常有用。</p>
<p>更多简洁的代码，再次感谢Python的语法和众多Python库。(distributed freely with most Python language implementations).</p>
<p>A dynamically-typed and strongly-typed language, offering the rare combination of code flexibility while at the same time avoiding pesky implicit-type-conversion bugs.</p>
<p>免费且开源，还要我说更多吗？</p>
<p>With regard to the question of when using Python is the “right choice” for a project, the complete answer also depends on a number of issues orthogonal to the language itself, such as prior technology investment, skill set of the team, and so on. Although the question as stated above implies interest in a strictly technical answer, a developer who will raise these additional issues in an interview will always “score more points” with me since it indicates an awareness of, and sensitivity to, the “bigger picture” (i.e., beyond just the technology being employed). Conversely, a response that Python is always the right choice is a clear sign of an unsophisticated developer.</p>
<p>###Q: Python语言的有哪些缺陷？</p>
<p>对于初学者来说，如果你很了解一门语言，你就应该知道它的缺点，因此回答如“他没有任何我不喜欢的东西”或者“它没有缺点”都非常telling indeed。</p>
<p>这个问题两个最常见的有效答案(绝不是详细列表)是：</p>
<p><a href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="external">全局解释器锁（GIL）</a>。 CPython（最常用的Python实现）是非完全线程安全的。为了支持多线程的Python程序，当前线程必须保持CPython提供的一个全局锁，之后才能安全地访问python对象。其结果是，不管有多少线程或处理器存在，在任意时刻只有一个线程被执行。相比较而言，值得注意的是，<a href="http://www.toptal.com/python#aboutPyPy" target="_blank" rel="external">之前讨论的PyPy实现</a>提供了对海量micro-threads并发的支持。</p>
<p>执行速度。 Python可能比编译语言要慢，因为它是被解释的。 （嗯，有点慢。查看<a href="http://www.toptal.com/python#interpretedOrCompiled" target="_blank" rel="external">之前我们针对这个问题的讨论</a>。）<br>包起来</p>
<p>##总结</p>
<p>本文中所列举的问题和技巧可以帮助你识别真正的python高手。我们希望在你寻找顶尖python开发者的时候，这些问题和技巧能成为一个“从谷壳分离麦子”的有用工具。然而，要记住，这些仅仅应该是作为工具被纳入你的整体招聘工具箱和战略中。</p>
<p>另外，对于那些可能会错误地阅读本指南，希望学习如何捕捉爬行动物（对不起，伙计，一类错误的蟒蛇！）的人，我们推荐你来弗罗里达州野生动物基金会的Python挑战赛。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/19/翻译-7个经典python面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/19/翻译-7个经典python面试题/" itemprop="url">[翻译]7个经典python面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-19T17:30:02+08:00">
                2015-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文在<a href="http://www.toptal.com/python/interview-questions" target="_blank" rel="external">这里toptal</a></p>
<p>##下面的代码输出什么？</p>
<pre><code>list = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]
print list[10:]
</code></pre><p>上面的代码输出<code>[]</code>，并且不会导致<code>IndexError</code>错误</p>
<p>跟你想的一样，当取列表元素的时候，如果索引值超过了元素的个数(例如在上面的列表中，取list[10])将会导致<code>IndexError</code>错误。但是，取一个列表的切片的时候，如果起始索引超过了元素个数，将不会引起<code>IndexError</code>错误，仅返回一个空列表。</p>
<p>这一特性将会导致一些非常难于追踪的bug，因为在运行时根本没有错误产生。</p>
<p>##下面的代码在Python2中的输出是什么？解释你的答案</p>
<pre><code>def div1(x,y):
    print &quot;%s/%s = %s&quot; % (x, y, x/y)

def div2(x,y):
    print &quot;%s//%s = %s&quot; % (x, y, x//y)

div1(5,2)
div1(5.,2)
div2(5,2)
div2(5.,2.)
</code></pre><p>另外，在Python3中上面的代码的输出有何不同(假设代码中的print语句都转化成了Python3中的语法结构)？</p>
<p>在<strong>Python2</strong>中，代码的输出是：</p>
<pre><code>5/2 = 2
5.0/2 = 2.5
5//2 = 2
5.0//2.0 = 2.0
</code></pre><p>默认情况下，如果两个操作数都是整数，Python2默认执行整数运算。所以，<code>5/2</code> 结果是<code>2</code>，而<code>5./2</code>结果是<code>2.5</code></p>
<p>注意你可以通过下面的import语句来覆盖Python2中的这一行为</p>
<pre><code>from __future__ import division 
</code></pre><p>还要注意“双斜杠”(<code>//</code>)操作符将会一直执行整除，忽略操作数的类型。这就是为什么5.0//2.0即使在Python2中结果也是2.0</p>
<p>但是在Python3并没有这一行为。两个操作数都是整数时，也不执行整数运算。在Python3中，输出如下：</p>
<pre><code>5/2 = 2.5
5.0/2 = 2.5
5//2 = 2
5.0//2.0 = 2.0
</code></pre><p>##下面代码的输出是什么？请解释你的答案</p>
<pre><code>def extendList(val, list=[]):
    list.append(val)
    return list

list1 = extendList(10)
list2 = extendList(123,[])
list3 = extendList(&apos;a&apos;)

print &quot;list1 = %s&quot; % list1
print &quot;list2 = %s&quot; % list2
print &quot;list3 = %s&quot; % list3
</code></pre><p>如何修改函数<code>ExtendList</code>的定义才能产生我们希望的行为？</p>
<p>输出为：</p>
<pre><code>list1 = [10, &apos;a&apos;]
list2 = [123]
list3 = [10, &apos;a&apos;]
</code></pre><p>很多人会错误地预计<code>list1</code>等于<code>［10］</code>，<code>list3</code>等于<code>[&#39;a&#39;]</code>，认为<code>extendList</code>函数的<code>list</code>参数在每一次函数被调用时都会被设置为默认值<code>[]</code></p>
<p>但是，真实的情况是，默认的<code>list</code>只在函数定义的时候被创建一次。之后不指定<code>list</code>参数地调用<code>extendList</code>函数时，使用的都是同一个<code>list</code>。这是因为带默认参数的表达式是在函数定义的时候被计算的，而不是在函数调用时。</p>
<p>所以，<code>list1</code>和<code>list3</code>都是在操作同一个默认<code>list</code>，而<code>list2</code>是在操作它自己创建的一个独立的<code>list</code>(将自己的空<code>list</code>作为参数传递过去)</p>
<p><code>extendlist</code>的定义可以这样定义来达到我们预期的效果：</p>
<pre><code>def extendList(val, list=None):
    if list is None:
        list = []
    list.append(val)
    return list
</code></pre><p>调用修改后的函数，输出是：</p>
<pre><code>list1 = [10]
list2 = [123]
list3 = [&apos;a&apos;]
</code></pre><p>##下面代码的输出是什么？请解释你的答案</p>
<pre><code>class Parent(object):
    x = 1

class Child1(Parent):
    pass

class Child2(Parent):
    pass

print Parent.x, Child1.x, Child2.x
Child1.x = 2
print Parent.x, Child1.x, Child2.x
Parent.x = 3
print Parent.x, Child1.x, Child2.x
</code></pre><p>输出为：</p>
<pre><code>1 1 1
1 2 1
3 2 3
</code></pre><p>让很多人感到疑惑和惊讶的是，最后一行的输出竟然不是<code>3 2 1</code>而是<code>3 2 3</code>. 为什么修改了Parent.X的值会影响到<code>Child2.x</code>，但是同时又没有改变<code>Child1.x</code>的值呢？        </p>
<p>这个问题的关键在于，在python中，类中的变量在内部被当作字典处理。如果一个变量名在当前类的字典中没有被发现，系统将会在这个类的祖先(例如，它的父类)中继续寻找，直到找到为止(如果一个变量名在这个类和这个类的祖先中都没有，那么将会引发一个<code>AttributeError</code>错误)</p>
<p>因此，在父类中将变量x赋值为1，那么x变量将可以被当前类和所有这个类的子类引用。这就是为什么第一个print语句输出为<code>1 1 1</code>.</p>
<p>接下来，如果它的子类覆盖了这个值(例如， 当我们执行<code>Child1.x = 2</code>)，那么这个变量的值仅仅在这个子类中发生了改变。这就是为什么第二个print语句输出<code>1 2 1</code></p>
<p>最后，如果父类改变了这个变量的值(例如，我们执行<code>Parent.x = 3</code>)，所有没有覆盖这个参数值的子类(在这个例子中覆盖了参数的就是<code>Child2</code>)都会受到影响，这就是为什么第三个print语句的输出为<code>3 2 3</code></p>
<p>##下面代码的输出是什么？请解释你的答案</p>
<pre><code>def multipliers():
    return [lambda x : i * x for i in range(4)]

print [m(2) for m in multipliers()]
</code></pre><p>怎么修改multipliers的定义才能达到期望的效果？</p>
<p>上面代码的输出是<code>[6, 6, 6, 6]</code>(不是<code>[0, 2, 4, 6]</code>).</p>
<p>原因是Python的闭包是延迟绑定(<code>late binding</code>)的。这表明在闭包中使用的变量直到内层函数被调用的时候才会被查找。结果是，当调用<code>multipliers()</code>返回的函数时，<code>i</code>参数的值会在这时被在调用环境中查找。所以，无论调用返回的哪个函数，<code>for</code>循环此时已经结束，<code>i</code>等于它最终的值<code>3</code>。因此，所有返回的函数都要乘以传递过来的<code>3</code>，因为上面的代码传递了<code>2</code>作为参数，所以他们都返回了<code>6</code>（即，<code>3 * 2</code>）</p>
<p>(顺便提一句，正如在书<a href="http://docs.python-guide.org/en/latest/" target="_blank" rel="external">《The Hitchhiker’s Guide to Python》</a>中提出来的一样, 有一种广泛传播的误解认为这个问题和lambda表达式有关，事实并非如此。通过labda表达式产生的函数并没有什么特别之处，使用普通的<code>def</code>定义的函数的行为和lambda表达式产生的函数的行为是一样的.)</p>
<p>下面是一些可以绕过这个问题的方法。</p>
<p>方法一是像下面一样使用Python的生成器(generator)</p>
<pre><code>def multipliers():
     for i in range(4): yield lambda x : i * x 
</code></pre><p>另一个方法是创造一个闭包，通过使用一个默认参数来立即绑定它的参数</p>
<pre><code>def multipliers():
    return [lambda x, i=i : i * x for i in range(4)]
</code></pre><p>或者，你也可以使用functools.partial函数：</p>
<pre><code>from functools import partial
from operator import mul

def multipliers():
    return [partial(mul, i) for i in range(4)]
</code></pre><p>##考虑下面的代码片段:</p>
<pre><code>1. list = [ [ ] ] * 5
2. list  # output?
3. list[0].append(10)
4. list  # output?
5. list[1].append(20)
6. list  # output?
7. list.append(30)
8. list  # output?
</code></pre><p>第2，4，6，8行的输出是什么？解释你的答案.</p>
<p>输出如下:</p>
<pre><code>[[], [], [], [], []]
[[10], [10], [10], [10], [10]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]
</code></pre><p>下面是解释:</p>
<p>第一行的输出凭直觉就能知道，很容易理解。即：<code>list = [ [ ] ] * 5</code>创建了一个元素是5个列表的列表。</p>
<p>但是，这里要理解的关键是，<code>list = [ [ ] ] * 5</code>并没有创建一个包含5个不同列表的列表。创建的这个列表里的5个列表，是对同一个列表的引用（a a list of 5 references to the same list）。理解了这些，你就能更好地理解余下的输出。</p>
<p><code>list[0].append(10)</code>将数字10添加到第一个列表。但是由于5个列表是对同一个列表的引用，所以输出是<code>[[10], [10], [10], [10], [10]]</code>。</p>
<p>同样的，<code>list[1].append(20)</code>将20追加到第二个列表。但是同样，由于这5个列表引用同一个列表，所以输出：<code>[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]</code>.</p>
<p>相比之下， <code>list.append(30)</code>是将一个全新的元素追加到“外层”的列表，所以产生了这样的输出：<code>[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]</code>.</p>
<p>##有一个拥有N个元素的列表，用一个列表解析式生成一个新的列表，元素的值同时满足以下条件:</p>
<pre><code>(a) 偶数，以及
(b) 在原列表中，索引为偶数
</code></pre><p>例如，如果list[2]的值是偶数，那么这个元素应该也被包含在新列表中，因为它在原列表中的索引也是偶数(即 2). 但是， 如果list[3]是偶数，那这个值不应该被包含在新列表中，因为它在原列表中的索引是一个奇数。</p>
<p>一个简单的解法如下：</p>
<pre><code>[x for x in list[::2] if x%2 == 0]
</code></pre><p>例如，给出下面的列表:</p>
<pre><code>#        0   1   2   3    4    5    6    7    8
list = [ 1 , 3 , 5 , 8 , 10 , 13 , 18 , 36 , 78 ]
</code></pre><p>列表解析式<code>[x for x in list[::2] if x%2 == 0]</code> 会生成:</p>
<pre><code>[10, 18, 78]
</code></pre><p>这个表达式首先取列表中索引是偶数的数字，然后过滤掉所有的奇数.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/19/部署multi-region-openstack环境/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/19/部署multi-region-openstack环境/" itemprop="url">部署multi-region openstack环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-19T17:17:06+08:00">
                2015-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/openstack/" itemprop="url" rel="index">
                    <span itemprop="name">openstack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Icehouse</code>默认的<code>region</code>是<code>RegionOne</code>。因为默认<code>region</code>的存在，无论是在命令行，还是在web上，我们都不需要指定<code>region</code>。在命令行中你还可以用<code>os-region-name</code>来指定region，在web中你就根本找不到与region相关的东西。</p>
<p>因为这样，很多人都不了解region的概念，如果你已经使用过openstack，并且不知道在哪看到了可以设置多region这样一件事，所以想自己部署一个看看，那么你可以把这篇文章读完。</p>
<p>因为只是一个实验，我们怎么简单怎么来。网上有很多快速部署openstack环境的教程，首先你需要按照教程部署两套完整的openstack环境。有了这两套环境，我们稍微改一下配置即可。</p>
<p>##增加endpoint</p>
<p>选择一台机器作为RegionOne，另一台则为RegionTwo。我们需要在RegionOne上增加Regiontwo上的service的endpoint。</p>
<p><img src="http://7xj6cl.com1.z0.glb.clouddn.com/Multi-Site_shared_keystone_horizon_swift1.png" alt=""></p>
<p>如图，可以看到Horizon，Keystone和Swift是公用的，我们只需要增加这些服务之外的服务的endpoint</p>
<p><img src="http://7xj6cl.com1.z0.glb.clouddn.com/service-list.png" alt=""></p>
<p>如图我们需要增加cinder,ec2,glance,neutron,nova的endpoint。添加endpoint的命令是：</p>
<pre><code>keystone endpoint-create --region RegionTwo 
                         --service &lt;service&gt; 
                          --publicurl &lt;public-url&gt;
                         --adminurl &lt;admin-url&gt;
                         --internalurl &lt;internal-url&gt;
</code></pre><p>这样添加好了之后，工作就完成一半了。</p>
<p>如果就这样打开RegionOne的web，会发现在页面上出现了一个之前没有的选择框，可以选择RegionOne或者RegionTwo，但是选了Regiontwo之后，按概况或者云主机之类的按钮，会出现各种<strong>无权限</strong>的错误，好蛋疼。其实这时候我们的web还没有配置好。</p>
<p>##配置horizon</p>
<p>打开文件</p>
<pre><code>vim /etc/openstack-dashboard/local_settings.py
</code></pre><p>找到</p>
<pre><code># For multiple regions uncomment this configuration, and add (endpoint, title).
# AVAILABLE_REGIONS = [
#     (&apos;http://cluster1.example.com:5000/v2.0&apos;, &apos;cluster1&apos;),
#     (&apos;http://cluster2.example.com:5000/v2.0&apos;, &apos;cluster2&apos;),
# ]
</code></pre><p>去掉注释，改成这样：</p>
<pre><code># For multiple regions uncomment this configuration, and add (endpoint, title).
AVAILABLE_REGIONS = [ 
     (&apos;http://10.10.7.208:5000/v2.0&apos;, &apos;RegionOne&apos;),
     (&apos;http://10.10.7.200:5000/v2.0&apos;, &apos;RegionTwo&apos;),
]
</code></pre><p>我的两台环境是<code>10.10.7.208</code>和<code>10.10.7.200</code>，你需要改成你的环境的ip。后面的5000端口不需要改，5000是keystone监听的端口，剩下的都不需要改。</p>
<p>改完之后，保存，重启web</p>
<pre><code>service apache2 restart
#这里也是，如果你不是用的apache，请改成你重启web的方式
</code></pre><p>这时候再登录就一切OK啦！</p>
<p><img src="http://7xj6cl.com1.z0.glb.clouddn.com/region.png" alt=""></p>
<p>右上角的region控制你登录的是哪个region，中间的那个是用户自由切换的用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/19/让mac的终端实现克隆会话功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/19/让mac的终端实现克隆会话功能/" itemprop="url">让mac的终端实现克隆会话功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-19T10:34:12+08:00">
                2015-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mac/" itemprop="url" rel="index">
                    <span itemprop="name">mac</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>win上的securecrt和xshell都支持克隆回话，这样ssh到别的主机就不需要每次都输入密码。mac版的securecrt非常难用，网上找到方法可以让mac自带的终端实现克隆会话的功能，如下。</p>
<pre><code>cd ~/.ssh
touch config
</code></pre><p>在config文件中写入下面的内容：</p>
<pre><code>Host *
    ControlMaster auto
    ControlPath ~/.ssh/%h-%p-%r
    ControlPersist yes
</code></pre><p>第一次登陆输入密码后，第二次登陆就不需要密码了。每次登陆，会在~/.ssh中建立一个soket文件，下次用相同用户名，端口，主机名进行连接就会自动复用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">163</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
