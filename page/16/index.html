<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/img/lufei.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/page/16/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/16/"/>





  <title>Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/10/cookie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/10/cookie/" itemprop="url">cookie</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-10T18:33:54+08:00">
                2015-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载自<a href="http://www.cnblogs.com/TankXiao/archive/2013/04/15/2848906.html" target="_blank" rel="external">这里</a></p>
<p>##网站自动登录<br>我们以”博客园自动登陆“的例子，来说明cookie是如何传递的。</p>
<p>大家知道博客园是可以自动登陆的。 如下图，这个是什么原理呢?</p>
<p><img src="/img/cookie1.png" alt=""></p>
<p>假如我已经在登陆页面输入了用户名，密码，选择了保存密码，登陆。</p>
<p>（这时候，其实在你的机器上保存好了登陆的cookie, 不信你可以按照上节介绍方法去你的电脑上找下博客园的cookie）  </p>
<p>当我下次访问博客园流程如下。</p>
<ol>
<li><p>用户打开IE浏览器，在地址栏上输入www.cnblogs.com.</p>
</li>
<li><p>IE首先会在硬盘中查找关于cnblogs.com的cookie. 然后把cookie放到HTTP Request中，再把Request发给Web服务器。</p>
</li>
<li><p>Web服务器返回博客园首页（你会看到你已经登陆了）。</p>
</li>
</ol>
<p><img src="/img/自动登录.png" alt=""></p>
<p>##截获Cookie，冒充别人身份<br>通过上面这个例子，可以看到cookie是很重要的，识别是否是登陆用户，就是通过cookie。  假如截获了别人的cookie是否可以冒充他人的身份登陆呢？  当然可以， 这就是一种黑客技术叫Cookie欺骗。</p>
<p>利用Cookie 欺骗， 不需要知道用户名密码。就可以直接登录，使用别人的账户做坏事。</p>
<p>我知道有两种方法可以截获他人的cookie，</p>
<ol>
<li><p>通过XSS脚步攻击， 获取他人的cookie. 具体原理可以看 <a href="http://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html" target="_blank" rel="external">Web安全性测试之XSS</a></p>
</li>
<li><p>想办法获取别人电脑上保存的cookie文件（这个比较难）</p>
</li>
</ol>
<p>##Cookie 泄露隐私<br>2013年央视的315晚会上， 曝光了很多不法公司利用Cookie跟踪并采集用户的个人信息，并转卖给网络广告商，形成了一条窃取用户信息的灰色产业链。从而实现广告准确投放。严重干扰了用户的正常网络应用，侵害了个人的隐私和利益。</p>
<p>我经常就在门户网站上发现广告位上显示的是我在电商网站上流量过的商品。  这就是我的cookie被泄露了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/10/在浏览器输入url回车，和直接按F5刷新有什么区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/10/在浏览器输入url回车，和直接按F5刷新有什么区别/" itemprop="url">在浏览器输入url回车，和直接按F5刷新有什么区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-10T16:12:03+08:00">
                2015-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>按F5刷新浏览器和在地址栏里输入网址然后回车。 这两个行为是不一样的。</p>
<p>按F5刷新浏览器， 浏览器会去Web服务器验证缓存。</p>
<p>如果是在地址栏输入网址然后回车，浏览器会”直接使用有效的缓存”, 而不会发http request 去服务器验证缓存，这种情况叫做缓存命中，如下图</p>
<p><img src="/img/缓存命中.png" alt=""></p>
<p>实例： 比较第一次访问博客园主页和第二次博客园主页</p>
<ol>
<li><p>启动Fiddler, 用firefox打开博客园主页， 发现有50多个session。</p>
</li>
<li><p>按CTRL+X将Fiddler中的所有session删除。 关闭firefox,重新打开一个firefox，打开博客园主页。   发现只有30多个session.</p>
</li>
</ol>
<p>分析；  少了的session是因为firefox直接用了缓存，而没有发http request。</p>
<p><img src="/img/第一次访问.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/10/http判断缓存是否有效，为什么有了last-modified还需要etag/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/10/http判断缓存是否有效，为什么有了last-modified还需要etag/" itemprop="url">http判断缓存是否有效，为什么有了last-modified还需要etag</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-10T15:49:54+08:00">
                2015-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>If-Modified-Since：<br>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</p>
<p>ETag：<br>是实体标签（Entity Tag）的缩写， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。</p>
<p>ETag是Web服务端产生的，然后发给浏览器客户端。浏览器客户端是不用关心Etag是如何产生的。</p>
<p>问题是，我们知道last-modified可以用来判断浏览器的本地缓存是否有效，那为什么还要使用ETag呢？ 主要是为了解决Last-Modified 无法解决的一些问题。</p>
<ol>
<li><p>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。</p>
</li>
<li><p>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</p>
</li>
<li><p>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/10/为什么http协议是无连接的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/10/为什么http协议是无连接的/" itemprop="url">为什么http协议是无连接的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-10T14:13:31+08:00">
                2015-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HTTP 协议本身是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。</p>
<p> TCP的面向连接是传输层的，而HTTP的无连接则是应用层的 。HTTP协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端（即浏览器）与服务器之间交换数据的间歇性较大（即传输具有突发性、瞬时性），并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，如果按照上面的方式，则需要在服务器端开的进程和句柄数目都是不可接受的，大部分通道实际上会很空闲、无端占用资源。因此HTTP的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。HTTP1.1现在设计为长连接，就是在一个连接内可以发生多个请求，避免了多次建立断开连接造成的消耗。</p>
<p>UDP尽管不象TCP那样占用资源，但它不保证数据的完整性、有序性，想像如果服务器返回的HTML错序了或者丢失一部分你将看到什么效果；并且UDP没有流量控制，而互联网的传输质量又不是很好，服务器随便仍出一大堆UDP包可能导致网络风暴，这是相当危险的。</p>
<p>归根结底，TCP的面向连接是传输层的，而HTTP的无连接则是应用层的。</p>
<hr>
<p><strong>无状态</strong>是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系</p>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</p>
<p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p> Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/05/TCP和UDP的工作过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/05/TCP和UDP的工作过程/" itemprop="url">TCP和UDP的工作过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-05T16:41:11+08:00">
                2015-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP-IP/" itemprop="url" rel="index">
                    <span itemprop="name">TCP/IP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##TCP和UDP的工作过程<br>UDP的工作过程是简单的，仅仅将用户数据封装到一个IP数据报中发送到目的地而已，而不关注其他方面。</p>
<p>TCP却是一个极其复杂的协议，以下只是冰山一角</p>
<p>###建立连接的三次握手</p>
<ul>
<li>主动方发送（SYN J），进入SYN_SENT状态</li>
<li>被动方收到（SYN J），并往回发送（SYN K, ACK J+1），进入SYN_RCVD状态</li>
<li>主动方收到（SYN K, ACK J+1），并往回发送（ACK K+1），进入ESTABLISHED状态</li>
<li>被动方收到（ACK K+1），也进入ESTABLISHED状态<br>以上过程如下图所示：</li>
</ul>
<p><img src="/img/establish.png" alt="establish"></p>
<p>注意到在TCP三次握手的过程中，服务器有这么一条：</p>
<blockquote>
<p>被动方收到（SYN J），并往回发送（SYN K, ACK J+1），进入SYN_RCVD状态</p>
</blockquote>
<p>服务器进入<code>SYN_RCVD</code>状态（此时连接称为半开连接）后，应当期待再收到一个ACK。 如果超时未收到客户端的<code>ACK</code>，服务器将重发<code>（SYN K, ACK J+1）</code>。 于是，就有一种叫做<code>SYN Flooding</code>的攻击方式。 攻击者向服务器高速发送<code>（SYN J）</code>（而且可以将SYN分节中的IP地址设为随机数）， 并且在随后收到服务器回复的<code>（SYN K, ACK J+1）</code>之后不再继续回复， 这使得服务器上存在很多的半开连接，这些半开连接一般情况下会持续63秒 （在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会把断开这个连接）。 它的危害有两方面，一方面自然是占用了服务器的资源；另一方面是填充了半开连接的队列，使得合法的SYN分节无法排队。</p>
<p>根据SYN Flooding的攻击原理，它的防范主要有以下措施：</p>
<ol>
<li>过滤掉最大嫌疑攻击的IP或IP段</li>
<li>将tcp_synack_retries设为0，表示回应第二个握手包（SYN K, ACK J+1）给客户端后，如果收不到ACK，不进行重试，加快回收“半开连接”。</li>
<li>将tcp_max_syn_backlog参数根据内存情况适当调大，该参数一般指的是维护的半开连接的队列的长度（不同OS不一样）。</li>
<li>设置tcp_abort_on_overflow选项，处理不过来就直接拒绝掉。</li>
</ol>
<p>###断开连接的四次握手</p>
<ol>
<li>主动方发送<code>（FIN M）</code>，进入<code>FIN_WAIT_1</code>状态</li>
<li>被动方收到<code>（FIN M）</code>，并往回发送<code>（ACK M+1）</code>，进入<code>CLOSE_WAIT</code>状态</li>
<li>主动方收到<code>（ACK M+1）</code>，进入<code>FIN_WAIT_2</code>状态</li>
<li>被动方发送<code>（FIN N）</code>，进入<code>LAST_ACK</code>状态</li>
<li>主动方收到<code>（FIN N）</code>，并往回发送<code>（ACK N+1）</code>，进入<code>TIME_WAIT</code>状态</li>
<li>被动方收到<code>（ACK N+1）</code>，进入<code>CLOSED</code>状态</li>
<li>主动方在<code>TIME_WAIT</code>状态中超时后，进入<code>CLOSED</code>状态</li>
</ol>
<p>以上过程如下图所示：</p>
<p><img src="/img/close.png" alt="close"></p>
<p>其实就是2次，只不过TCP是全双工的，所以，发送方和接收方都需要FIN和ACK。 只不过，有一方是被动的，所以看上去就成了所谓的4次挥握手。</p>
<p>注意到最后有这么一条涉及到TIME_WAIT的状态</p>
<blockquote>
<p>主动方在TIME_WAIT状态中超时后，进入CLOSED状态</p>
</blockquote>
<p>需要经过一个<code>TIME_WAIT</code>超时的状态而不是直接进入<code>CLOSED</code>的原因有两个，一是确保有足够的时间让对端收到<code>ACK</code>，二是允许老的分节在网络中慢慢的消逝。</p>
<p>然而，如果系统中存在着大量的短链接，那么大量的<code>TIME_WAIT</code>状态就会成为系统的累赘。网上一些资料提到的<code>tcp_tw_reuse</code>和<code>tcp_tw_recycle</code>选项来解决这个问题，但是最好还是别乱用，好像<code>coolshell</code>中有提到过，可能会出很多诡异的问题。还可以调整<code>tcp_max_tw_buckets</code>，当并发的<code>TIME_WAIT</code>过多时，会直接把多的给destory掉，然后在日志里打一个警告。引用一句“其实，<code>TIME_WAIT</code>表示的是你主动断连接，所以，这就是所谓的<code>&quot;no zuo， no die&quot;</code>。</p>
<p>##TCP连接在“非正常”情况下的工作状况</p>
<p>###服务器进程终止</p>
<p>首先，服务器进程终止（收到<code>SIGKILL</code>信号）。作为进程中止处理的工作之一，该进程所有打开着的描述符将被关闭，这会导致向对端（客户端）发送（<code>FIN N</code>），而客户端则回复（<code>ACK N+1</code>），这就是TCP断开连接的前半部分。</p>
<p>然后，此时客户端收到（<code>FIN N</code>）并不意味着连接断开（虽然在这个例子中，确实断开了），只是意味着服务器不再向客户端发送数据了，客户端还可以继续向服务器发送数据。如果此时客户端还继续向服务器发送数据，服务器TCP将发现之前的打开该套接字的进程已终止，于是回应一个<code>RST</code>。客户端在收到这个<code>RST</code>之前的read操作将会返回EOF，在收到这个<code>RST</code>后的read操作会返回<code>ECONNRESET</code>错误，在收到这个<code>RST</code>后的write操作会使当前进程收到<code>SIGPIPE</code>信号。</p>
<p>以上过程如下图所示：</p>
<p><img src="/img/server_kill.png" alt="server_kill"></p>
<p>###服务器主机崩溃</p>
<p>服务器主机崩溃的意思是，没有任何预兆，来不及在网络上发送任何消息，主机就无法工作了。这种情况等价于直接切断网络，或者通俗的说，可以直接拔掉网线来模拟这一情况。</p>
<p>这时，如果客户端向服务器发送数据，后调用read操作，TCP会一直等待服务器的ACK确认消息，并且不断的超时重传（按照Berkeley的实现，重传12次，共需9分钟），直到到达重传次数，返回<code>ETIMEOUT</code>错误。如果是由中间的路由器判定服务器主机不可达，响应“destination unreasonable”的ICMP消息，将返回<code>EHOSTUNREACH</code>和<code>ENETUNREACH</code>错误。</p>
<p>###服务器主机崩溃后重启</p>
<p>重启之后的服务器已经丢失了之前的TCP信息，所以即使收到了客户端发来的TCP数据，也会回复<code>RST</code>，往后的情况和“服务器主机崩溃”中提到的类似。</p>
<p>###服务器主机关机</p>
<p>Unix系统关机时，init进程通常会给其他进程发送<code>SIGTERM</code>信号，然后等待10s左右给仍在运行的进程发送<code>SIGKILL</code>信号。所以如果进程不捕获<code>SIGTERM</code>信号，则将由<code>SIGKILL</code>信号终止，和“服务器进程终止”中提到的类似。</p>
<p>##参考链接<br><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">TCP 的那些事儿（上）</a></p>
<p><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/05/另一个Lambda表达式教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/05/另一个Lambda表达式教程/" itemprop="url">另一个Lambda表达式教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-05T15:21:06+08:00">
                2015-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载自<a href="http://python.jobbole.com/80954/" target="_blank" rel="external">这里</a>，原文在<a href="http://www.blog.pythonlibrary.org/2010/07/19/the-python-lambda/" target="_blank" rel="external">这里</a></p>
<p>有很多Python的<a href="http://docs.python.org/tutorial/controlflow.html#lambda-forms" target="_blank" rel="external">lambda</a>教程[1]。最近我偶然发现一个，真挺有用的。是Mike Driscoll在<a href="http://www.blog.pythonlibrary.org/" target="_blank" rel="external">Mouse VS Python</a> 博客上的<a href="http://www.blog.pythonlibrary.org/2010/07/19/the-python-lambda/" target="_blank" rel="external">关于lambda的讨论</a>) 。</p>
<p>当我刚开始学习Python，最容易困惑的概念之一，是lambda语句。我敢肯定，<br>其他新的程序员也对它很困惑…</p>
<p>Mike的讨论非常好：清晰，直接，且含有实用的示例。它帮助我终于领会了lambda，并导致我写的另一篇lambda教程。</p>
<p>一个用来构造函数的工具 基本上，Python的lambda是用于构造函数（或更精确地说，函数对象）的工具。这意味着，Python有两个构造函数的工具：def和lambda。</p>
<p>下面是一个例子。您可以以正常的方式用def构造一个函数，就像这样：</p>
<pre><code>def square_root(x): return math.sqrt(x)
</code></pre><p>或者你可以用lambda</p>
<pre><code>square_root = lambda x: math.sqrt(x)
</code></pre><p>下面是lambda的其他的一些有趣的例子：</p>
<pre><code>sum = lambda x, y:   x + y   #  def sum(x,y): return x + y
out = lambda   *x:   sys.stdout.write(&quot; &quot;.join(map(str,x)))
lambda event, name=button8.getLabel(): self.onButton(event, name)
</code></pre><p>lambda的好处在哪里？ 已经困扰我有很长一段时间的一个问题是：lambda的好处在哪里？为什么我们需要lambda？</p>
<p>答案是： 我们并不需要lambda，我们不用它一样可以做所有的事情。但是… 在特定的情况下，很是方便 - 它让编写代码更容易一些，而且编写的代码更整洁。</p>
<p>什么样的情况？ 好，其中一个情况是，我们需要一个简单的一次性功能：将被只使用一次函数。</p>
<p>通常，写函数有两个目的：(a)以减少代码重复（b）模块化代码。</p>
<ul>
<li>如果你的应用程序在不同的地方包含重复的代码块，那么你就可以把代码拷贝到一个函数，给函数名，然后 – 使用该函数名 - 在代码中的不同位置调用它。</li>
<li>如果你有一个代码块执行一个明确的操作 - 但真的是冗长、粗糙、破坏程序的可读性，那么你可以把那么长的粗糙的所有代码变成一个函数。</li>
</ul>
<p>但是，假设你需要创建一个函数，将只被使用一次 - 只从应用程序中的一个地方调用。好吧，首先，你不需要给函数的名称。它可以是“匿名的”。而且你可以把它定义在你想使用它的地方。这就是lambda是非常有用的时候。</p>
<p>但是，但是，但是…你会说。</p>
<ul>
<li><p>首先是，为什么你想要一个只调用一次函数？排除原因（a）。</p>
</li>
<li><p>一个lambda的函数体只能包含单个表达式。这意味着，lambda表达式必须很短。排除了原因（b）。</p>
</li>
</ul>
<p>创造一个短的匿名函数可能的原因是什么？</p>
<p>那么，考虑一下代码片段，使用lambda来定义一个Tkinter的GUI界面按钮的行为。 （这个例子是来自Mike的教程。）</p>
<pre><code>frame = tk.Frame(parent)
frame.pack()

btn22 = tk.Button(frame, 
        text=&quot;22&quot;, command=lambda: self.printNum(22))
btn22.pack(side=tk.LEFT)

btn44 = tk.Button(frame, 
        text=&quot;44&quot;, command=lambda: self.printNum(44))
btn44.pack(side=tk.LEFT)
</code></pre><p>这里要记住的一点是，tk.Button需要一个函数对象作为参数传递给该函数的参数。该函数对象将是它（按钮）点击按钮时调用的函数。基本上，该函数指定了点击该按钮时，GUI会做什么。</p>
<p>因此，我们必须通过函数参数传递一个函数对象到一个按钮。并注意 – 因为不同的按钮做不同的事情 - 我们需要为每个按钮对象提供不同的函数对象。每个函数将只使用一次。 所以，尽管我们可以这样写</p>
<pre><code>def __init__(self, parent):
    &quot;&quot;&quot;Constructor&quot;&quot;&quot;
    frame = tk.Frame(parent)
    frame.pack()

    btn22 = tk.Button(frame, 
        text=&quot;22&quot;, command=self.buttonCmd22)
    btn22.pack(side=tk.LEFT)

    btn44 = tk.Button(frame, 
        text=&quot;44&quot;, command=self.buttonCmd44)
    btn44.pack(side=tk.LEFT)

def buttonCmd22(self):
    self.printNum(22)

def buttonCmd44(self):
    self.printNum(44)
</code></pre><p>这样写更容易（且更清楚）</p>
<pre><code>def __init__(self, parent):
    &quot;&quot;&quot;Constructor&quot;&quot;&quot;
    frame = tk.Frame(parent)
    frame.pack()

    btn22 = tk.Button(frame, 
        text=&quot;22&quot;, command=lambda: self.printNum(22))
    btn22.pack(side=tk.LEFT)

    btn44 = tk.Button(frame, 
        text=&quot;44&quot;, command=lambda: self.printNum(44))
    btn44.pack(side=tk.LEFT)
</code></pre><p>当一个GUI程序有这样的代码，该按钮对象需要“call back”到被提供给作为其命令的函数对象。 因此，我们可以说，lambda的最常见的用途之一是在GUI框架，如Tkinter和wxPython中写“回调（callback）”，。</p>
<p>这一切似乎很简单。所以… 为什么lambda如此难以理解？ 我能想到四个原因:</p>
<p>首先Lambda难以理解，因为：一个lambda只能用一个表达式：什么是表达式？</p>
<p>很多人想知道这个问题的答案。如果你在Google上搜索了一下，你会看到很多的帖子，“在Python中，表达式和语句之间的区别是什么？”</p>
<p>一个很好的答案是，表达式返回（或计算结果为）值，而语句则没有。不幸的是，在Python中表达式也可以是一个语句，这种情况很容易造成糊涂。 – 赋值语句就像 A = B = 0，Python支持链式赋值。 （Python不是C）</p>
<p>很多情况下在当人们问这个问题时，他们真正想知道的是：什么样的情况下可以放入lambda，什么情况下不可以？ 而对于这个问题，我觉得遵循一些简单的规则就足够了。</p>
<ul>
<li>如果它不返回一个值，它不是一个表达式，不能放入一个lambda。</li>
<li>如果你能想象它在赋值语句中放在等号的右边，那它是一个表达式，可以放进一个lambda。</li>
</ul>
<p>利用这些规则意味着：</p>
<ol>
<li>赋值语句不能在lambda中使用。在Python中，赋值语句不返回任何东西，甚至没有None（null）。</li>
<li>如数学运算，字符串操作，列表解析等都是一个lambda。</li>
<li>函数调用是表达式。可以在lambda中放置函数调用，并将参数传递给该函数。这样就在一个新的匿名函数中封装了原函数调用（参数其他内容）。</li>
<li>在Python3，print成了一个函数，所以在Python3+，print（…）可以在lambda中使用。</li>
<li>即使函数是返回None，就像在Python3print函数，可以在一个lambda中使用。</li>
<li><p>[条件表达式]，它是在Python2.5中引入，是表达式（而不是仅仅是一个语法不同的if / else语句）。它们返回一个值，并且可以在一个lambda使用。</p>
<pre><code>lambda: a if some_condition() else b
lambda x: ‘big’ if x &gt; 100 else ‘small’
</code></pre></li>
</ol>
<p>难以理解的第二个原因是：一个lambda只有一个表达式：为什么？为什么只有一个？为什么不能多表达式？为什么不能是语句？</p>
<p>对于一些开发人员来说，这个问题的意思是为什么Python的lambda语法如此怪异？对于其他人，尤其是那些有Lisp的背景的，这个问题是指为什么Python的lambda这么残废？为什么不像Lisp的lambda那么强大？</p>
<p>答案是很复杂，它涉及Python语法的“pythonicity”。lambda是一个相对较晚加入Python的。它加入的时候，Python语法已经固定下来了。在这种情况下，语法的lambda必须用“Pythonic”的方式硬塞进一个已经建立好的Python语法中。导致可以在lambda表达式上来完成一些事情有一定的局限性。</p>
<p>坦率地说，我仍然认为lambda语法看起来有点怪异。尽管那样，但是Guido解释了为什么lambda的语法是不会改变的。 Python不会成为Lisp。</p>
<p>难以理解的第三个原因是：：lambda通常被描述为一种工具，用于创建函数，但lambda语句中不含有返回语句。</p>
<p>在某种意义上，return语句隐含在lambda中。lambda规范必须包含只有一个表达式，表达式必须返回一个值，由lambda创建一个匿名函数隐式地返回表达式的返回值。这非常有意义。</p>
<p>还是 - 我想缺乏一个明确的return语句使得很难理解lambda，或者至少很难迅速理解。</p>
<p>难以理解的第四个原因是在lambda教程中通常会用作为创建匿名函数来引入lambda，其实最常见的lambda用途是用于创建匿名过程。</p>
<p>在编程的上古时期，我们就将子程序区分为两种不同的形式：过程和函数。过程是用来做事情的，并没有返回任何东西。函数是用于计算和返回值。函数和过程之间的差异已经成为一些编程语言的一部分了。在Pascal，例如，程序和函数是不同的关键字。</p>
<p>在大多数现代语言中，语言的语法中不再区分过程和函数。 例如Python的函数，可以像过程，函数，或两者兼而有之。（不是完全理想的）结果是一个Python函数总是被称为“函数”，即使它是本质上充当过程。</p>
<p>虽然过程和函数之间的区别已经基本消失的语言结构中，当思考有关程序如何工作的时候我们仍然时常用它。例如，当我读一个程序的源代码，并看到一些函数F，我揣摩F是做什么的。我经常可以把它归类到一个过程或函数 - 我会对自己说“F的目的是做这个的”，或“F的目的是计算和返回等这个和这个的”。</p>
<p>所以现在我想我们可以明白为什么lambda的许多解释是难以理解。 First of all, the Python language itself masks the distinction between a function and a procedure. 首先，Python语言本身模糊了函数和过程的区别。</p>
<p>第二，大多数教程介绍把lambda作为创建匿名函数的工具来介绍，其主要目的是要计算并返回结果。在大多数教程看到（这个包含）的第一个例子展示了如何编写一个lambda来返回值，x的平方根。</p>
<p>但是，这不是lambda最常用的方式，不是当他们在Google上搜索“python lambda教程”的时候要找的。对于lambda最常见的用途是创建匿名的过程，在GUI回调中使用。在这些用例中，我们不关心什么lambda返回什么，我们关心它做了什么。</p>
<p>这就解释了为什么典型的Python程序员难以理解大多数的lambda说明。因为他尝试学习如何编写一些GUI框架的代码：Tkinter，wxPython。运行这些lambda，想理解他们。Google“python lambda教程”。他发现那些以例子开始的教程是完全不适合他。</p>
<p>所以，如果你是这样的程序员 - 本教程是给你写的。我希望它能帮助到你。对不起，我们在本教程的结尾看到了这点，而不是开头。我们希望有一天，有人会写一个lambda教程，而不是以这种方式开头</p>
<ul>
<li>lambda是一个用来构造匿名函数的工具</li>
</ul>
<p>而以这样的句子开始：</p>
<ul>
<li>lambda是一个用来构造回调的工具</li>
</ul>
<p>所以你需要有它。另一个lambda教程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/05/十个我希望早点知道的python方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/05/十个我希望早点知道的python方法/" itemprop="url">十个我希望早点知道的python方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-05T14:38:37+08:00">
                2015-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文在<a href="http://nbviewer.ipython.org/github/Prooffreader/Misc_ipynb/blob/master/top_10_python_idioms.ipynb" target="_blank" rel="external">这里</a></p>
<p>##在Python 2中使用Python 3式的输出<br>Python 2与Python 3不兼容，这让我不知道该选择哪个版本的Python。最终我选择了Python 2，因为当时许多我需要用的库都与Python 3不兼容。</p>
<p>但实际上，日常使用中最大的版本差异是输出（print）和除法行为。现在我在Python 2的代码中都用import from future来导入Python 3的输出和除法。现在我用到的几乎所有库都支持Python 3，因此会很快迁移到Python 3中。</p>
<pre><code>mynumber = 5

print &quot;Python 2:&quot;
print &quot;The number is %d&quot; % (mynumber)
print mynumber / 2,
print mynumber // 2

from __future__ import print_function
from __future__ import division

print(&apos;nPython 3:&apos;)
print(&quot;The number is {}&quot;.format(mynumber))
print(mynumber / 2, end=&apos; &apos;)
print(mynumber // 2)

输出：
Python 2:
The number is 5
2 2

Python 3:
The number is 5
2.5 2
</code></pre><p>##enumerate(list)<br>很明显，迭代列表时，应该同时迭代其中的元素及其索引，但在很长一段时间内，我都尴尬的使用计数变量或切片。</p>
<pre><code>mylist = [&quot;It&apos;s&quot;, &apos;only&apos;, &apos;a&apos;, &apos;model&apos;]

for index, item in enumerate(mylist):
    print(index, item)

输出：
0 It&apos;s
1 only
2 a
3 model
</code></pre><p>##链式比较操作符<br>由于我以前使用的是静态语言（在这些语言中该用法有二义性），从来没有将两个比较操作符放在一个表达式中。在许多语言中，4 &gt; 3 &gt; 2会返回False，因为4 &gt; 3的结果是布尔值，而True &gt; 2将得出False。</p>
<pre><code>mynumber = 3

if 4 &gt; mynumber &gt; 2:
    print(&quot;Chained comparison operators work! n&quot; * 3)

输出：
Chained comparison operators work!
Chained comparison operators work!
Chained comparison operators work!
</code></pre><p>##collections.Counter<br>Python的集合库看上去是最好的。在计算需要集合中元素的个数时，StackOverflow找到的答案是创建有序字典，但我坚持使用一个代码片段来创建字典，计算结果中元素出现的频率。直到有一天，我发现可以用collections.deque。</p>
<pre><code>from collections import Counter
from random import randrange
import pprint

mycounter = Counter()

for i in range(100):
    random_number = randrange(10)
    mycounter[random_number] += 1

for i in range(10):
    print(i, mycounter[i])

输出：
0 10
1 10
2 13
3 6
4 6
5 11
6 10
7 14
8 12
9 8
</code></pre><p>##字典推导</p>
<p>Python开发者的一个重要标志就是理解列表推导，但最终我发现字典推导也很有用，特别是在交换字典的键和值的时候。</p>
<pre><code>my_phrase = [&quot;No&quot;, &quot;one&quot;, &quot;expects&quot;, &quot;the&quot;, &quot;Spanish&quot;, &quot;Inquisition&quot;]
my_dict = {key: value for value, key in enumerate(my_phrase)}
print(my_dict)
reversed_dict = {value: key for key, value in my_dict.items()}
print(reversed_dict)

输出：
{&apos;Inquisition&apos;: 5, &apos;No&apos;: 0, &apos;expects&apos;: 2, &apos;one&apos;: 1, &apos;Spanish&apos;: 4, &apos;the&apos;: 3}
{0: &apos;No&apos;, 1: &apos;one&apos;, 2: &apos;expects&apos;, 3: &apos;the&apos;, 4: &apos;Spanish&apos;, 5: &apos;Inquisition&apos;}
</code></pre><p>##用subprocess执行shell命令</p>
<pre><code>import subprocess
output = subprocess.check_output(&apos;dir&apos;, shell=True)
print(output)
</code></pre><p>注意，用os库完成这个特定命令比用subprocess更好。我只想有一个大家都熟悉的命令。同时，一般来说，在subprocess中使用shell=True参数是非常糟糕的主意，在这里使用这个参数仅仅是为了能在一个IPython notebook单元中放置命令的输出。不要自己使用这个参数！下面是用os模块执行shell命令</p>
<pre><code>import os
os.system(&apos;dir&apos;)
</code></pre><p>注意，这里的<code>dir</code>命令会立刻在shell中输出，不能够保存到文件(变量)中，如果想要保存到变量中，可以使用popen：</p>
<pre><code>import os
output = os.popen(&apos;dir&apos;)
print output.read()
</code></pre><p>##字典的.get()和.iteritems()方法<br>字典的get()方法可以设置默认值，当用get()查找的键不存在时，返回方法中的默认值参数是很有用的。与列表中的enumerate()相同，可以用键值元组迭代字典中的元素。<br>    my_dict = {‘name’: ‘Lancelot’, ‘quest’: ‘Holy Grail’, ‘favourite_color’: ‘blue’}</p>
<pre><code>print(my_dict.get(&apos;airspeed velocity of an unladen swallow&apos;, &apos;African or European?n&apos;))

for key, value in my_dict.iteritems():
    print(key, value, sep=&quot;: &quot;)

输出：
African or European?

quest: Holy Grail
name: Lancelot
favourite_color: blue
</code></pre><p>如果要用for迭代输出字典，就要用到字典的<code>iteritems()</code>方法，这个方法在python3.x中已经废除了，取代的是<code>items()</code>方法，<code>items()</code>方法在python2.x中也存在</p>
<p>##用于交换元素的元组解包<br>在VB中，每当需要交换两个变量时，都要用要一个愚蠢的临时变量：c = a; a = b; b = c</p>
<pre><code>a = &apos;Spam&apos;
b = &apos;Eggs&apos;

print(a, b)

a, b = b, a
print(a, b)

输出：
Spam Eggs
Eggs Spam
</code></pre><p>##内省工具Introspection tools<br>我知道dir()方法，我本以为help()方法和IPython中的?魔法命令是一样的，但help()的功能更强大。</p>
<pre><code>my_dict = {&apos;That&apos;: &apos;an ex-parrot!&apos;}

help(my_dict)

输出：
Help on dict object:

class dict(object)
 | dict() -&gt; new empty dictionary
 | dict(mapping) -&gt; new dictionary initialized from a mapping object&apos;s
 | (key, value) pairs
 | dict(iterable) -&gt; new dictionary initialized as if via:
 | d = {}
 | for k, v in iterable:
 | d[k] = v
 | dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
 | in the keyword argument list. For example: dict(one=1, two=2)
 |
 | Methods defined here:
 |
 | __cmp__(...)
 | x.__cmp__(y) &lt;==&gt; cmp(x,y)
 |
 | __contains__(...)
 | D.__contains__(k) -&gt; True if D has a key k, else False
 |
 | __delitem__(...)
 | x.__delitem__(y) &lt;==&gt; del x[y]
 |
 | __eq__(...)
 | x.__eq__(y) &lt;==&gt; x==y
 |

[TRUNCATED FOR SPACE]

 | 
 | update(...)
 | D.update([E, ]**F) -&gt; None. Update D from dict/iterable E and F.
 | If E present and has a .keys() method, does: for k in E: D[k] = E[k]
 | If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v
 | In either case, this is followed by: for k in F: D[k] = F[k]
 |
 | values(...)
 | D.values() -&gt; list of D&apos;s values
 |
 | viewitems(...)
 | D.viewitems() -&gt; a set-like object providing a view on D&apos;s items
 |
 | viewkeys(...)
 | D.viewkeys() -&gt; a set-like object providing a view on D&apos;s keys
 |
 | viewvalues(...)
 | D.viewvalues() -&gt; an object providing a view on D&apos;s values
 |
 | ----------------------------------------------------------------------
 | Data and other attributes defined here:
 |
 | __hash__ = None
 |
 | __new__ =
 | T.__new__(S, ...) -&gt; a new object with type S, a subtype of T
</code></pre><p>##PEP-8兼容的字符串连接<br>PEP8是Python编码样式指南。撇开其他的不看，PEP8要求每行不能超过80个字符，超过的部分要换行并缩进。</p>
<p>可以通过反斜杠、带逗号“,”的圆括号“()”、或者额外的加号“+”来完成换行。但对于多行字符串，这些解决方案都不够优雅。Python有个多行字符串记号，即三个引号，但这样无法换行后保持缩进。</p>
<p>还有一个方法，那就是不带逗号的圆括号。我不知道为什么这种方式能工作，但能用就行。</p>
<pre><code>my_long_text = (&quot;We are no longer the knights who say Ni! &quot;
                &quot;We are now the knights who say ekki-ekki-&quot;
                &quot;ekki-p&apos;tang-zoom-boing-z&apos;nourrwringmm!&quot;)
print(my_long_text)

输出：
We are no longer the knights who say Ni! We are now the knights who say ekki-ekki-ekki-p&apos;tang-zoom-boing-z&apos;nourrwringmm!
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/04/scrapy的一些知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/04/scrapy的一些知识点/" itemprop="url">scrapy的一些知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-04T11:23:27+08:00">
                2015-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scrapy/" itemprop="url" rel="index">
                    <span itemprop="name">scrapy</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>###运行spider，将爬取到的信息用JSON形式存到scraped_data.json文件中</p>
<pre><code>scrapy crawl my_spider -o scraped_data.json
</code></pre></li>
<li><p>###在scrapy shell里面打印返回的html</p>
<pre><code>response.body
</code></pre></li>
<li><p>###创建一个Spider，我们必须继承<code>scrapy.Spider</code>类(或者别的爬虫类)，并且定义以下3个属性</p>
<ul>
<li>name：用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。</li>
<li>start_urls：包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一(每个url都会被爬取)。 <code>后续的URL则从初始的URL获取到的数据中提取</code>。</li>
<li>parse() 是spider的一个方法。 被调用时，<code>每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数</code>。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。parse只是初始url的回调函数，可以定义别的回调函数来处理后序的链接。</li>
</ul>
</li>
<li><p>###scrapy shell</p>
<pre><code>scrapy shell &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;
</code></pre><blockquote>
<p>当您在终端运行Scrapy时，请一定记得给url地址加上<code>引号</code>，否则包含参数的url(例如 &amp; 字符)会导致Scrapy运行失败。</p>
</blockquote>
</li>
<li><p>###Item 对象是自定义的python字典。 您可以使用标准的字典语法来获取到其每个字段的值。(字段即是我们之前用Field赋值的属性):</p>
<pre><code>&gt;&gt;&gt; item = DmozItem()
&gt;&gt;&gt; item[&apos;title&apos;] = &apos;Example title&apos;
&gt;&gt;&gt; item[&apos;title&apos;]
&apos;Example title&apos;
</code></pre></li>
<li><p>###<code>scrapy.cfg</code> 存放的目录被认为是 项目的根目录 。该文件中包含python模块名的字段定义了项目的设置</p>
</li>
<li><h3 id="Link-Extractors-是用于从网页-scrapy-http-Response-中抽取会被follow的链接的对象。"><a href="#Link-Extractors-是用于从网页-scrapy-http-Response-中抽取会被follow的链接的对象。" class="headerlink" title="Link Extractors 是用于从网页(scrapy.http.Response )中抽取会被follow的链接的对象。"></a>Link Extractors 是用于从网页(scrapy.http.Response )中抽取会被follow的链接的对象。</h3><pre><code>scrapy.contrib.linkextractors import LinkExtractor
</code></pre></li>
<li><p>###log服务<br>Scrapy提供了log功能。您可以通过 scrapy.log 模块使用。当前底层实现使用了 Twisted logging ，不过可能在之后会有所变化。</p>
</li>
<li><p>###使用FormRequest.from_response()方法模拟用户登录<br>通常网站通过 <input type="hidden"> 实现对某些表单字段（如数据或是登录界面中的认证令牌等）的预填充。 使用Scrapy抓取网页时，如果想要预填充或重写像用户名、用户密码这些表单字段， 可以使用 FormRequest.from_response() 方法实现。下面是使用这种方法的爬虫例子:</p>
<pre><code>import scrapy

class LoginSpider(scrapy.Spider):
    name = &apos;example.com&apos;
    start_urls = [&apos;http://www.example.com/users/login.php&apos;]

    def start_requests(self):
        return scrapy.FormRequest.from_response(
            &quot;url&quot;,
            formdata={&apos;username&apos;: &apos;john&apos;, &apos;password&apos;: &apos;secret&apos;},
            callback=self.after_login
        )

    def after_login(self, response):
        # check login succeed before going on
        if &quot;authentication failed&quot; in response.body:
            self.log(&quot;Login failed&quot;, level=log.ERROR)
            return

        # continue scraping with authenticated session...
</code></pre></li>
<li><p>###Scrapy是以广度优先还是深度优先进行爬取的呢<br>默认情况下，Scrapy使用 LIFO 队列来存储等待的请求。简单的说，就是 深度优先顺序 。深度优先对大多数情况下是更方便的。如果您想以 广度优先顺序 进行爬取，你可以设置以下的设定:</p>
<pre><code>DEPTH_PRIORITY = 1
SCHEDULER_DISK_QUEUE = &apos;scrapy.squeue.PickleFifoDiskQueue&apos;
SCHEDULER_MEMORY_QUEUE = &apos;scrapy.squeue.FifoMemoryQueue&apos;
</code></pre></li>
<li><p>###避免被禁止(ban)<br>有些网站实现了特定的机制，以一定规则来避免被爬虫爬取。 与这些规则打交道并不容易，需要技巧，有时候也需要些特别的基础。 如果有疑问请考虑联系 商业支持 。</p>
<p>  下面是些处理这些站点的建议(tips):</p>
<ul>
<li>使用user agent池，轮流选择之一来作为user agent。池中包含常见的浏览器的user agent(google一下一大堆)</li>
<li>禁止cookies(参考 COOKIES_ENABLED)，有些站点会使用cookies来发现爬虫的轨迹。</li>
<li>设置下载延迟(2或更高)。参考 DOWNLOAD_DELAY 设置。</li>
<li>如果可行，使用 <a href="http://www.googleguide.com/cached_pages.html" target="_blank" rel="external">Google cache</a> 来爬取数据，而不是直接访问站点。</li>
<li>使用IP池。例如免费的 <a href="https://www.torproject.org/" target="_blank" rel="external">Tor</a>项目 或付费服务(<a href="http://proxymesh.com/" target="_blank" rel="external">ProxyMesh</a>)。</li>
<li>使用高度分布式的下载器(downloader)来绕过禁止(ban)，您就只需要专注分析处理页面。这样的例子有: <a href="http://crawlera.com/" target="_blank" rel="external">Crawlera</a></li>
</ul>
</li>
<li><p>###禁止重试<br>对失败的HTTP请求进行重试会减慢爬取的效率，尤其是当站点响应很慢(甚至失败)时， 访问这样的站点会造成超时并重试多次。这是不必要的，同时也占用了爬虫爬取其他站点的能力。</p>
<p>  禁止重试:</p>
<pre><code>RETRY_ENABLED = False
</code></pre></li>
<li>###使用相对Xpaths</li>
</ul>
<p>如果你使用嵌套的选择器，并使用起始为 <code>/</code> 的XPath，那么该XPath将对文档使用绝对路径，而且对于你调用的 Selector 不是相对路径。</p>
<p>比如，假设你想提取在 <code>&lt;div&gt;</code>元素中的所有 <code>&lt;p&gt;</code>元素。首先，你将先得到所有的 <code>&lt;div&gt;</code> 元素:</p>
<pre><code>&gt;&gt;&gt; divs = response.xpath(&apos;//div&apos;)
</code></pre><p>开始时，你可能会尝试使用下面的错误的方法，<strong>因为它其实是从整篇文档中，而不仅仅是从那些 <code>&lt;div&gt;</code> 元素内部提取所有的 <code>&lt;p&gt;</code>元素</strong>:</p>
<pre><code>&gt;&gt;&gt; for p in divs.xpath(&apos;//p&apos;):  # this is wrong - gets all &lt;p&gt; from the whole document
...     print p.extract()
</code></pre><p>下面是比较合适的处理方法(注意 .//p XPath的点前缀):</p>
<pre><code>&gt;&gt;&gt; for p in divs.xpath(&apos;.//p&apos;):  # extracts all &lt;p&gt; inside
...     print p.extract()
</code></pre><p>另一种常见的情况将是提取所有直系 <code>&lt;p&gt;</code>的结果:</p>
<pre><code>&gt;&gt;&gt; for p in divs.xpath(&apos;p&apos;):
...     print p.extract()
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/03/python的-classmethod-修饰符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/03/python的-classmethod-修饰符/" itemprop="url">python的@classmethod 修饰符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-03T14:37:00+08:00">
                2015-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通常情况下，如果我们要使用一个类的方法，那我们只能将一个类实体化成一个对象，进而调用对象使用方法。</p>
<pre><code>class Hello(object):
    def __init__:
        ...

    def print_hello(self):
        print &quot;Hello&quot;
</code></pre><p> 要用 print_hello() 就得：</p>
<pre><code>hlo = Hello()
hlo.print_hello()
输出：Hello
</code></pre><p>如果用了 @classmethod 就简单了：</p>
<pre><code>class Hello(object):
    def __init__:
        ...

    @classmethod
    def print_hello(cls):
        print &quot;Hello&quot;
</code></pre><p>要用的话直接：</p>
<pre><code>Hello.print_hello()
Hello
</code></pre><p>注意：@classmethod 仅仅适用于单独的，与类本身的数据结构无关函数，其实用了它的函数，与使用普通函数无异，甚至不能在参数里加入 self，如果要在其中使用类的数据结构，仍然需要将类实例化一次才可以，所以要小心使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/03/每天一个python小程序-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/03/每天一个python小程序-7/" itemprop="url">每天一个python小程序(7)--敏感词</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-03T14:34:54+08:00">
                2015-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。</p>
<p>love</p>
<p>sex</p>
<p>jiangge</p>
<p>bitch</p>
</blockquote>
<p>代码中有两种从txt文件中获取敏感词的方法，有一种被注释掉了，因为用这种方法获得的list最后会有一个空的字符串，导致下面find的时候一直会匹配成功，感兴趣的同学可以去掉注释试一下（同时需要注释掉注释下面的4行）</p>
<pre><code>#!/usr/bin/python
#encoding=utf-8

def get_sensitive_word(filepath):
    f = open(filepath, &apos;r&apos;)
    #data = f.read()
    #filt = data.split(&apos;\n&apos;) 这个方法得到的序列中最后有一个空的字符串，导致匹配一直成功
    words = []
    for word in f:
        #strip删除字符序列，这里是删除word中的&apos;\n&apos;
        words.append(word.strip(&apos;\n&apos;))
    f.close()
    return words

def filter_word(words):
    flag = False
    text = raw_input(&apos;please input: &apos;)
    for word in words:
        if text.find(word) != -1:
            flag = True

    if flag:
        print &apos;freedom&apos;
    else:
        print &apos;human rights&apos;

if __name__ == &apos;__main__&apos;:
    filepath = &apos;filtered_words.txt&apos;
    words = get_sensitive_word(filepath)
    filter_word(words)
</code></pre><p>完整项目见<a href="https://github.com/michaelyou/a-python-a-day/tree/master/no.11" target="_blank" rel="external">这里</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">199</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
