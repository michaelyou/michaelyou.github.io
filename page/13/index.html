<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/img/lufei.ico?v=5.1.2" />






<meta name="description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:type" content="website">
<meta property="og:title" content="Youmai の Blog">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Youmai の Blog">
<meta name="twitter:description" content="世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/13/"/>





  <title>Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/03/02/语言中的指针和内存泄漏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/02/语言中的指针和内存泄漏/" itemprop="url">语言中的指针和内存泄漏</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-02T09:27:39+08:00">
                2015-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载自<a href="http://www.ibm.com/developerworks/cn/aix/library/au-toughgame/" target="_blank" rel="external">这里</a></p>
<p>##引言</p>
<p>对于任何使用 C 语言的人，如果问他们 C 语言的最大烦恼是什么，其中许多人可能会回答说是指针和内存泄漏。这些的确是消耗了开发人员大多数调试时间的事项。指针和内存泄漏对某些开发人员来说似乎令人畏惧，但是一旦您了解了指针及其关联内存操作的基础，它们就是您在 C 语言中拥有的最强大工具。</p>
<p>本文将与您分享开发人员在开始使用指针来编程前应该知道的秘密。本文内容包括：</p>
<ul>
<li>导致内存破坏的指针操作类型</li>
<li>在使用动态内存分配时必须考虑的检查点</li>
<li>导致内存泄漏的场景</li>
</ul>
<p>如果您预先知道什么地方可能出错，那么您就能够小心避免陷阱，并消除大多数与指针和内存相关的问题。</p>
<p>##什么地方可能出错？<br>有几种问题场景可能会出现，从而可能在完成生成后导致问题。在处理指针时，您可以使用本文中的信息来避免许多问题。</p>
<p>###未初始化的内存<br>在本例中，p 已被分配了 10 个字节。这 10 个字节可能包含垃圾数据，如图 1 所示。</p>
<pre><code>char *p = malloc ( 10 );
</code></pre><p><img src="/img/垃圾数据.png" alt="图1.垃圾数据"></p>
<p>如果在对这个 p 赋值前，某个代码段尝试访问它，则可能会获得垃圾值，您的程序可能具有不可预测的行为。p 可能具有您的程序从未曾预料到的值。</p>
<p><strong>良好的实践是始终结合使用 memset 和 malloc，或者使用 calloc。</strong></p>
<pre><code>char *p = malloc (10);
memset(p,’’,10);
</code></pre><p>现在，即使同一个代码段尝试在对 p 赋值前访问它，该代码段也能正确处理 Null 值（在理想情况下应具有的值），然后将具有正确的行为。</p>
<p>###内存覆盖<br>由于 p 已被分配了 10 个字节，如果某个代码片段尝试向 p 写入一个 11 字节的值，则该操作将在不告诉您的情况下自动从其他某个位置“吃掉”一个字节。让我们假设指针 q 表示该内存。</p>
<p><img src="/img/原始q内容.png" alt="图2.原始q内容"></p>
<p><img src="/img/覆盖后的q内容.png" alt="图3.覆盖后的q内容"></p>
<p>结果，指针 q 将具有从未预料到的内容。即使您的模块编码得足够好，也可能由于某个共存模块执行某些内存操作而具有不正确的行为。下面的示例代码片段也可以说明这种场景。</p>
<pre><code>char *name = (char *) malloc(11);
// Assign some value to name
memcpy ( p,name,11); // Problem begins here
</code></pre><p>在本例中，memcpy 操作尝试将 11 个字节写到 p，而后者仅被分配了 10 个字节。</p>
<p>作为良好的实践，每当向指针写入值时，都要确保对可用字节数和所写入的字节数进行交叉核对。一般情况下，memcpy 函数将是用于此目的的检查点。</p>
<p>###内存读取越界<br>内存读取越界 (overread) 是指所读取的字节数多于它们应有的字节数。这个问题并不太严重，在此就不再详述了。下面的代码提供了一个示例。</p>
<pre><code>char *ptr = (char *)malloc(10);
char name[20] ;
memcpy ( name,ptr,20); // Problem begins here
</code></pre><p>在本例中，memcpy 操作尝试从 ptr 读取 20 个字节，但是后者仅被分配了 10 个字节。这还会导致不希望的输出。</p>
<p>###内存泄漏<br>内存泄漏可能真正令人讨厌。下面的列表描述了一些导致内存泄漏的场景。<br>重新赋值我将使用一个示例来说明重新赋值问题。</p>
<pre><code>char *memoryArea = malloc(10);
char *newArea = malloc(10);
</code></pre><p>这向如下面的图 4 所示的内存位置赋值。</p>
<p><img src="/img/图4.内存位置.png" alt="图4.内存位置"></p>
<p>memoryArea 和 newArea 分别被分配了 10 个字节，它们各自的内容如图 4 所示。如果某人执行如下所示的语句（指针重新赋值）……</p>
<pre><code>memoryArea = newArea;
</code></pre><p>则它肯定会在该模块开发的后续阶段给您带来麻烦。</p>
<p>在上面的代码语句中，开发人员将 memoryArea 指针赋值给 newArea 指针。结果，memoryArea 以前所指向的内存位置变成了孤立的，如下面的图 5 所示。它无法释放，因为没有指向该位置的引用。这会导致 10 个字节的内存泄漏。</p>
<p><img src="/img/内存泄漏.png" alt="图5.内存泄漏"></p>
<p>在对指针赋值前，请确保内存位置不会变为孤立的。</p>
<ul>
<li>首先释放父块</li>
</ul>
<p>假设有一个指针 memoryArea，它指向一个 10 字节的内存位置。该内存位置的第三个字节又指向某个动态分配的 10 字节的内存位置，如图 6 所示。</p>
<p><img src="/img/图6.动态分配的内存.png" alt="图6.动态分配的内存"></p>
<pre><code>free(memoryArea)
</code></pre><p>如果通过调用 free 来释放了 memoryArea，则 newArea 指针也会因此而变得无效。newArea 以前所指向的内存位置无法释放，因为已经没有指向该位置的指针。换句话说，newArea 所指向的内存位置变为了孤立的，从而导致了内存泄漏。</p>
<p>每当释放结构化的元素，而该元素又包含指向动态分配的内存位置的指针时，应首先遍历子内存位置（在此例中为 newArea），并从那里开始释放，然后再遍历回父节点。</p>
<p>这里的正确实现应该为：</p>
<pre><code>free( memoryArea-&gt;newArea);
free(memoryArea);
</code></pre><ul>
<li>返回值的不正确处理</li>
</ul>
<p>有时，某些函数会返回对动态分配的内存的引用。跟踪该内存位置并正确地处理它就成为了 calling 函数的职责。</p>
<pre><code>char *func ( )
{
 return malloc(20); // make sure to memset this location to ‘’…
}
void callingFunc ( )
{
 func ( ); // Problem lies here
}
</code></pre><p>在上面的示例中，callingFunc() 函数中对 func() 函数的调用未处理该内存位置的返回地址。结果，func() 函数所分配的 20 个字节的块就丢失了，并导致了内存泄漏。</p>
<p>###归还您所获得的<br>在开发组件时，可能存在大量的动态内存分配。您可能会忘了跟踪所有指针（指向这些内存位置），并且某些内存段没有释放，还保持分配给该程序。</p>
<p>始终要跟踪所有内存分配，并在任何适当的时候释放它们。事实上，可以开发某种机制来跟踪这些分配，比如在链表节点本身中保留一个计数器（但您还必须考虑该机制的额外开销）。</p>
<p>###访问空指针<br>访问空指针是非常危险的，因为它可能使您的程序崩溃。始终要确保您不是 在访问空指针。</p>
<p>##总结<br>本文讨论了几种在使用动态内存分配时可以避免的陷阱。要避免内存相关的问题，良好的实践是：</p>
<ul>
<li>始终结合使用 memset 和 malloc，或始终使用 calloc。</li>
<li>每当向指针写入值时，都要确保对可用字节数和所写入的字节数进行交叉核对。</li>
<li>在对指针赋值前，要确保没有内存位置会变为孤立的。</li>
<li>每当释放结构化的元素（而该元素又包含指向动态分配的内存位置的指针）时，都应首先遍历子内存位置并从那里开始释放，然后再遍历回父节点。</li>
<li>始终正确处理返回动态分配的内存引用的函数返回值。</li>
<li>每个 malloc 都要有一个对应的 free。</li>
<li>确保您不是在访问空指针。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/03/01/线程安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/01/线程安全/" itemprop="url">线程安全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-01T22:01:15+08:00">
                2015-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。</p>
<p>线程安全问题都是由全局变量及静态变量引起的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p>##举例<br>比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成：</p>
<ol>
<li>在 Items[Size] 的位置存放此元素</li>
<li>增大 Size 的值。</li>
</ol>
<p>在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；</p>
<p>而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。</p>
<p>那好，我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/03/01/排序算法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/01/排序算法总结/" itemprop="url">排序算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-01T20:11:03+08:00">
                2015-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考书籍是:《数据结构与算法分析-c语言描述，weiss著》</p>
<p>下图是排序算法时间复杂度等特性的一个总结：</p>
<p><img src="/img/排序算法.png" alt=""></p>
<p>下面详细总结一下各个算法，总结的方面包括：</p>
<ol>
<li>每个算法的思想是什么？</li>
<li>每个算法的稳定性怎样？时间复杂度如何？</li>
<li>在什么情况下，算法出现最好情况 or 最坏情况？</li>
<li>每种算法的具体实现又是怎样的？</li>
</ol>
<p>##各个排序算法的空间复杂度<br>大家往往只关心时间复杂度，而忽略了空间复杂度，所以这里讲空间复杂度提到前面来讲</p>
<p><code>冒泡排序</code>，<code>简单选择排序</code>，<code>堆排序</code>，<code>直接插入排序</code>，<code>希尔排序</code>的空间复杂度为O(1),因为需要一个临时变量来交换元素位置，(另外遍历序列时自然少不了用一个变量来做索引)</p>
<p>快速排序空间复杂度为log2n(因为递归调用了)；归并排序空间复杂是O(n)，需要一个大小为n的临时数组.</p>
<p>这里的一个问题是，归并排序也递归了，为什么时间复杂度不是log2n?</p>
<p>答：<br>归并排序每次递归都要用到一个辅助表，长度与待排序的表长度相同，虽然递归次数是O(log2n)，但每次递归都会释放掉所占的辅助空间，所以下次递归的栈空间和辅助空间与这部分释放的空间就不相关了，因而空间复杂度还是O（n）。</p>
<p>快速排序空间复杂度只是在通常情况下才为O(log2n)，如果是最坏情况的话，很显然就要O(n)的空间了。当然，可以通过随机化选择pivot来将空间复杂度降低到O(log2n)。</p>
<p>##冒泡排序</p>
<p>###基本思想<br>通过无序区中相邻记录关键字间的比较和位置的交换,使关键字最小的记录如气泡一般逐渐往上“漂浮”直至“水面”。</p>
<p><img src="/img/冒泡排序.png" alt=""></p>
<p>###时间复杂度</p>
<p><strong>最好情况下</strong>：正序有序，则只需要比较n次。故，为O(n)</p>
<p><strong>最坏情况下</strong>：逆序有序，则需要比较(n-1)+(n-2)+……+1，故为O(n*n)</p>
<p>###稳定性<br>排序过程中只交换相邻两个元素的位置。因此，当两个数相等时，是没必要交换两个数的位置的。所以，它们的相对位置并没有改变，<strong>冒泡排序算法是稳定的</strong>！</p>
<p>##代码</p>
<pre><code>#define elementtype int
void bubble_sort(elementtype *array, int n) {
    elementtype tmp;
    int i = 0, j = 0;
    for(; i &lt; n - 1; i++) {
        for(j = n -1; j &gt; i; j--) {
            if(array[j] &lt; array[j - 1]) {
                swap(array[j], array[j-1]);
            }
        }
    }
}
</code></pre><p>##选择排序</p>
<p>###思想<br>首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。具体做法是：选择最小的元素与未排序部分的首部交换，使得序列的前面为有序。</p>
<p>选择排序是和冒泡排序差不多的一种排序。和冒泡排序交换相连数据不一样<br>的是，选择排序只有在确定了最小的数据之后，才会发生交换</p>
<p>###时间复杂度<br><strong>最好情况</strong>：交换0次，但是每次都要找到最小的元素，因此大约必须遍历<code>N*N</code>次，因此为O(N*N)。减少了交换次数！ </p>
<p><strong>最坏情况</strong>：平均情况下：O(N*N)</p>
<p>###稳定性<br>由于每次都是选取未排序序列A中的最小元素x与A中的第一个元素交换，因此跨距离了，很可能破坏了元素间的相对位置，因此<strong>选择排序是不稳定的</strong>！</p>
<p>例如数组为5,5,3，第一次就会将第一个5和3交换</p>
<p>###代码</p>
<pre><code>void select_sort(elementtype *array, int n) {
    elementtype tmp;
    int i, j, index;
    if(array == NULL &amp;&amp; n &lt; 0)
        exit(-1);

    for(i = 0; i &lt; n - 1; i++) {
        index = i;
        for(j = i + 1; j &lt; n; j ++) {
            if(array[j] &lt; array[index])
                index = j;
        }

        if(index != i) {
            swap(array[i], array[index]);
        }
    }
}
</code></pre><p>##插入排序</p>
<p>###思想<br>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法—-插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>
<p>###时间复杂度<br><strong>最好的情况</strong>：正序有序(从小到大)，这样只需要比较n次，不需要移动。因此时间复杂度为O(n)<br><strong>最坏的情况</strong>：逆序有序,这样每一个元素就需要比较n次，共有n个元素，因此实际复杂度为O(n­2)<br><strong>平均情况</strong>：O(n­2)</p>
<p>###稳定性<br>理解性记忆比死记硬背要好。因此，我们来分析下。稳定性，就是有两个相同的元素，排序先后的相对位置是否变化，主要用在排序时有多个排序规则的情况下。在插入排序中，K1是已排序部分中的元素，当K2和K1比较时，直接插到K1的后面(没有必要插到K1的前面，这样做还需要移动！！)，因此，插入排序是稳定的。</p>
<p>###代码</p>
<pre><code>void insert_sort(elementtype *array, int n) {
    elementtype tmp;
    int p, j;
    for(p = 1; p &lt; n; p++) {
        tmp = array[p];
        for(j = p; j &gt; 0 &amp;&amp; array[j - 1] &gt; tmp; j--) {
            array[j]= array[j - 1];
        }
        array[j] = tmp;
    }
}
</code></pre><p>##shell排序</p>
<p>###思想<br>Shell排序是DL. Shell于1959年针对直接插入排序算法改进提出的，属于插入排序的范畴，是对直接插入排序算法的改进。直接插入排序在基本有序时效率较高，并且在序列规模不是很大时效率也很高，Shell排序就是针对这两点进行改进。核心思想是：待排序列有n个元素，先取一个小于n的整数h1作为第一个增量，把待排序列以间隔h1分成若干子序列，子序列内使用插入排序；然后取第二个增量h2(&lt; h1)，重复上述的划分和排序，<br>直至所取的增量hl = 1 (h1 &gt; h2 &gt; … &gt; hl)。</p>
<p>这样不管序列多么庞大，在先前较大步长分组下每个子序列规模都不是很大，用直接插入效率很高；后面步长变小，子序列变大，但由于整体有序性越来越明显，排序效率依然很高，大大提高了时间效率。</p>
<p>###时间复杂度</p>
<p><strong>最好情况</strong>：由于希尔排序的好坏和步长d的选择有很多关系，因此，目前还没有得出最好的步长如何选择(现在有些比较好的选择了，但不确定是否是最好的)。所以，不知道最好的情况下的算法时间复杂度。  </p>
<p><strong>最坏情况</strong>：O(N*logN)，最坏的情况下和平均情况下差不多。  </p>
<p><strong>平均情况</strong>：O(N*logN)</p>
<p>###稳定性<br>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以<strong>shell排序是不稳定的</strong>。</p>
<blockquote>
<p>有个猜测，方便记忆：一般来说，若存在不相邻元素间交换，则很可能是不稳定的排序。</p>
</blockquote>
<p>###代码</p>
<pre><code>void shell_sort(elementtype *array, int n) {
    elementtype tmp;
    int increment, i, j;
    for(increment = n/2; increment &gt; 0; increment /= 2) {
        for(i = increment; i &lt; n; i++) {
            tmp = array[i];
            for(j = i; j &gt;= increment &amp;&amp; array[j - increment] &gt; tmp; j -= increment)
                    array[j] = array[j - increment];

            array[j] = tmp;
        }
    }
}
</code></pre><p>##堆排序</p>
<p>###思想<br>利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大(或者最小)的记录。也就是说，以最小堆为例，根节点为最小元素，较大的节点偏向于分布在堆底附近。</p>
<p>###时间复杂度<br>最坏情况下，接近于最差情况下：O(N*logN)，因此它是一种效果不错的排序算法</p>
<p>###稳定性<br>堆排序需要不断地调整堆，因此<strong>堆排序是一种不稳定的排序</strong>！</p>
<p>###代码</p>
<pre><code>#define LeftChild(i) (2 * (i) + 1)
void perc_down(int *a, int i, int size)
{
    int child;

    int tmp = a[i];

    for(; LeftChild(i) &lt; size ; i = child)
    {
        child = LeftChild(i);
        if(child != size - 1 &amp;&amp; a[child] &lt; a[child + 1])
                child ++;

        /***************************
         * 提升儿子到父结点，
         * 儿子结点的位置上存在空穴，
         * 需要继续比较
         **************************/
        if(a[child] &gt; tmp)
                a[i] = a[child];
        else/*不需要提升*/
                break;
    }
    /*保存结点的位置找到*/
    a[i] = tmp;
}

void build_maxheap(int *a, int size)
{
    int step = 0;

    /***************************************
     * (size-1)/2实质是找到a[size-1]的父结点，
     * 也就是倒数第二层，堆的创建过程是一个
     * 由低层到高层逐渐创建的过程
     **************************************/
    for(step = (size - 1) / 2 ; step &gt;= 0; -- step)
        perc_down(a, step, size);
}

void heap_sort(int *a, int size)
{
    int i = 0;
    /*创建堆*/
    build_maxheap(a,size);

    for(; i &lt; size; i++)
        printf(&quot;%d &quot;, a[i]);
    printf(&quot;\n&quot;);

    for(i = size - 1; i &gt; 0; --i)
    {
        swap(a[i],a[0])；

        /*更新堆的结构*/
        perc_down(a,0,i);

    }

}
</code></pre><p>##归并排序</p>
<p>###思想<br>多次将两个或两个以上的有序表合并成一个新的有序表。</p>
<p><img src="/img/归并排序.png" alt=""></p>
<p>###时间复杂度</p>
<p><strong>最好的情况</strong>：一趟归并需要n次，总共需要logN次，因此为O(N*logN) </p>
<p><strong>最坏的情况</strong>： 接近于平均情况，为O(N*logN) </p>
<p>说明：对长度为n的文件，需进行logN 趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。</p>
<p>###稳定性<br><strong>归并排序最大的特色就是它是一种稳定的排序算法</strong>。归并过程中是不会改变元素的相对位置的。 </p>
<p>缺点是，它需要O(n)的额外空间。但是很<strong>适合于多链表排序</strong>。</p>
<p>###代码</p>
<pre><code>/*left_start is the start of the left half, right_start is the start of the
  right half*/
void merge(int *array, int *tmp_array, int left_start, int right_start, int right_end)
{
    int left_end = right_start-1;
    int length = right_end-left_start+1;

    int tmp_pos = left_start;

    while(left_start &lt;= left_end &amp;&amp; right_start &lt;= right_end) {
        if(array[left_start] &lt;= array[right_start])
            tmp_array[tmp_pos++] = array[left_start++];
        else
            tmp_array[tmp_pos++] = array[right_start++];
    }

    /*main loop*/
    while(left_start &lt;= left_end)
        tmp_array[tmp_pos++] = array[left_start++];
    while(right_start &lt;= right_end)
        tmp_array[tmp_pos++] = array[right_start++];

    /*copy tmp_array back
      注意这里必须使用right_end作为数组下标，不能用tmp_pos，因为此时的
      tmp_pos已经越界了，上面多了一次++*/
    int i;
    for(i = 0; i &lt; length; i++, right_end--)  
        array[right_end] = tmp_array[right_end];
}

void m_sort(int *array, int *tmp_array, int left, int right)
{
    int mid;

    if(left &lt; right) {
        mid = (left + right)/2;
        m_sort(array, tmp_array, left, mid);
        m_sort(array, tmp_array, mid+1, right);
        merge(array, tmp_array, left, mid+1, right);
    }
}

void merge_sort(int *array, int n)
{
    if(array == NULL || n &lt;= 0)
        exit(-1);

    int *tmp_array = (int *)malloc(n * sizeof(int));

    if(tmp_array != NULL) {
        m_sort(array, tmp_array, 0, n-1);
        free(tmp_array);
    }
    else
        exit(-1);
}
</code></pre><blockquote>
<p>merge例程是精妙的。如果对merge的每个递归调用均局部声明一个临时数组，那么在任一时刻就可能有logN个临时数组处在活动期，这对于小内存的机器则是致命的。另一方面，如果merge例程动态分配并释放最小量临时内存，那么由malloc占用的时间会很多。严格测试指出，由于merge位于m_sort的最后一行，因此在任一时刻只需要一个临时数组活动，而且可以使用该临时数组的任意部分；我们将使用与输入数组array相同的部分。</p>
</blockquote>
<p>#快速排序</p>
<p>###思想<br>它是由冒泡排序改进而来的。在待排序的n个记录中任取一个记录(通常取第一个记录),把该记录放入适当位置后,数据序列被此记录划分成两部分。所有关键字比该记录关键字小的记录放置在前一部分,所有比它大的记录放置在后一部分,并把该记录排在这两部分的中间(称为该记录归位),这个过程称作一趟快速排序。</p>
<p><img src="/img/http://img2.imgtn.bdimg.com/it/u=2694285242,78285384&amp;fm=21&amp;gp=0.jpg" alt=""></p>
<p>###时间复杂度<br><strong>最好的情况</strong>：因为每次都将序列分为两个部分(一般二分都复杂度都和logN相关)，故为 O(N*logN)  </p>
<p><strong>最坏的情况</strong>：序列基本有序，选取的枢轴元素为最大值或最小值时，退化为冒泡排序，几乎要比较<code>N*N/2</code>次，故为O(N*N)</p>
<blockquote>
<p>如何避免最坏情况：为改进快速排序算法，随机选取界点或最左、最右、中间三个元素中的值处于中间的作为界点，通常可以避免原始序列有序的最坏情况。</p>
</blockquote>
<p>###稳定性<br>由于每次都需要和中轴元素交换，因此原来的顺序就可能被打乱。如序列为 5 3 3 4 3 8 9 10 11会将3的顺序打乱。所以说，<strong>快速排序是不稳定的</strong>！</p>
<p>###代码</p>
<pre><code>/*数据交换*/
void swap(int *x,int *y)
{
   int temp;
   temp = *x;
   *x = *y;
   *y = temp;
}

int choose_pivot(int i,int j )
{
   return((i+j) /2);
}

/*递归和分治*/
void quick_sort(int list[],int left,int right)
{
   int key,i,j,k;
   if(left &lt; right)
   {
      k = (left + right) / 2;
      swap(&amp;list[left],&amp;list[k]);
      key = list[left];
      i = left+1;
      j = right;
      while(1)
      {
         while((i &lt; right) &amp;&amp; (list[i] &lt; key))
                i++;
         while((j &gt; left) &amp;&amp; (list[j] &gt; key))
                j--;
         if( i &lt; j) {
                swap(&amp;list[i],&amp;list[j]);
                //仅仅是为了防止死循环，见P183
                if(list[i] == list[j] &amp;&amp; list[i] == key) {  
                    i++;  //j--;
                }
         }
         else
            break;
      }
     // 交换两个元素的位置
      swap(&amp;list[left],&amp;list[j]);
     // 递归地对较小的数据序列进行排序
      quick_sort(list,left,j-1);
      quick_sort(list,j+1,right);
   }
} 
</code></pre><p>快排在数据少的时候是不占优势的，所以一般是在数据少的时候用插入排序，数据多的时候用快排。上面的快排程序对书上的程序作了修改，防止了死循环，但并不是一个好程序。比较好的快排实现可以看<a href="https://github.com/michaelyou/data_structure/blob/master/sort.c" target="_blank" rel="external">这里</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/27/linux磁盘空间命令-df和du/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/27/linux磁盘空间命令-df和du/" itemprop="url">linux磁盘空间命令--df和du</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-27T09:16:16+08:00">
                2015-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##df<br>对于磁盘存储方面，有很多命令行或基于GUI的工具，它可以告诉你关于当前磁盘空间的使用情况。这些工具用各种人们可读的格式展示磁盘利用率的详细信息，比如易于理解的总结，详细的统计信息或直观的可视化报告。如果你只想知道不同文件系统有多少空闲的磁盘空间，那么df命令可能是你所需要的。</p>
<pre><code>[root@pc105 /]# df
Filesystem           1K-blocks     Used Available Use% Mounted on
/dev/mapper/VolGroup-lv_root
                      51475068 48090628    763000  99% /
tmpfs                  8135664       72   8135592   1% /dev/shm
/dev/sda1               487652    93128    368924  21% /boot
/dev/mapper/VolGroup-lv_home
                     901109008  4270596 851058036   1% /home
tmpfs                   102400        4    102396   1% /var/log/pearl2
tmpfs                  8135664        4   8135660   1% /var/run/pearl2
</code></pre><p>df命令可以展示任何“mounted”文件系统的磁盘利用率。该命令可以用不同的方式调用。</p>
<p>###用人们可读的方式展示<br>默认情况下，df命令用1K为块来展示磁盘空间，这看起来不是很直观。“-h”参数使df用更可读的方式打印磁盘空间（例如 100K，200M，3G）。</p>
<pre><code>[root@pc105 /]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/VolGroup-lv_root
                       50G   46G  746M  99% /
tmpfs                 7.8G   72K  7.8G   1% /dev/shm
/dev/sda1             477M   91M  361M  21% /boot
/dev/mapper/VolGroup-lv_home
                      860G  4.1G  812G   1% /home
tmpfs                 100M  4.0K  100M   1% /var/log/pearl2
tmpfs                 7.8G  4.0K  7.8G   1% /var/run/pearl2
</code></pre><p>###展示Inode使用情况<br>当你监视磁盘使用情况时，你必须注意的不仅仅是磁盘空间还有“inode”的使用情况。在Linux中，inode是用来存储特定文件的元数据的一种数据结构，在创建一个文件系统时，inode的预先定义数量将被分配。这意味着，<strong>一个文件系统可能耗尽空间不只是因为大文件用完了所有可用空间，也可能是因为很多小文件用完了所有可能的inode</strong>。用“-i”选项展示inode使用情况。</p>
<pre><code>[root@pc105 /]# df -i
Filesystem             Inodes  IUsed    IFree IUse% Mounted on
/dev/mapper/VolGroup-lv_root
                      3276800 635298  2641502   20% /
tmpfs                 2033916      3  2033913    1% /dev/shm
/dev/sda1              128016     53   127963    1% /boot
/dev/mapper/VolGroup-lv_home
                     57229312  35042 57194270    1% /home
tmpfs                 2033916      2  2033914    1% /var/log/pearl2
tmpfs                 2033916      2  2033914    1% /var/run/pearl2
</code></pre><p>###展示磁盘总利用率<br>默认情况下， df命令显示磁盘的单个文件系统的利用率。如果你想知道的所有文件系统的总磁盘使用量，增加“ –total ”选项（见最下面的汇总行）。</p>
<pre><code>[root@pc105 /]# df -h --total
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/VolGroup-lv_root
                       50G   46G  746M  99% /
tmpfs                 7.8G   72K  7.8G   1% /dev/shm
/dev/sda1             477M   91M  361M  21% /boot
/dev/mapper/VolGroup-lv_home
                      860G  4.1G  812G   1% /home
tmpfs                 100M  4.0K  100M   1% /var/log/pearl2
tmpfs                 7.8G  4.0K  7.8G   1% /var/run/pearl2
total                 925G   51G  829G   6%
</code></pre><p>##du<br>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的.</p>
<p>###显示目录或者文件所占空间 </p>
<pre><code>[root@localhost test]# du
608     ./test6
308     ./test4
4       ./scf/lib
4       ./scf/service/deploy/product
4       ./scf/service/deploy/info
12      ./scf/service/deploy
16      ./scf/service
4       ./scf/doc
4       ./scf/bin
32      ./scf
8       ./test3
1288    .
[root@localhost test]#
</code></pre><p>只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的1288为当前目录的总大小</p>
<p>###显示指定文件所占空间</p>
<pre><code>[root@localhost test]# du log2012.log 
300     log2012.log
[root@localhost test]#
</code></pre><p>###查看指定目录的所占空间</p>
<pre><code>[root@localhost test]# du scf
4       scf/lib
4       scf/service/deploy/product
4       scf/service/deploy/info
12      scf/service/deploy
16      scf/service
4       scf/doc
4       scf/bin
32      scf
[root@localhost test]#
</code></pre><p>###显示多个文件所占空间</p>
<pre><code>[root@localhost test]# du log30.tar.gz log31.tar.gz 
4       log30.tar.gz
4       log31.tar.gz
[root@localhost test]#
</code></pre><p>###只显示总和的大小</p>
<pre><code>[root@localhost test]# du -s
1288    .
[root@localhost test]# du -s scf
32      scf
[root@localhost test]# cd ..
[root@localhost soft]# du -s test
1288    test
[root@localhost soft]#
</code></pre><p>###方便阅读的格式显示</p>
<pre><code>[root@localhost soft]# du -h test
608K    test/test6
308K    test/test4
4.0K    test/scf/lib
4.0K    test/scf/service/deploy/product
4.0K    test/scf/service/deploy/info
12K     test/scf/service/deploy
16K     test/scf/service
4.0K    test/scf/doc
4.0K    test/scf/bin
32K     test/scf
8.0K    test/test3
1.3M    test
[root@localhost soft]#
</code></pre><p>###文件和目录都显示</p>
<pre><code>[root@localhost soft]# du -ah test
4.0K    test/log31.tar.gz
4.0K    test/test13.tar.gz
300K    test/test6/linklog.log
4.0K    test/test6/log2013.log
300K    test/test6/log2012.log
608K    test/test6
4.0K    test/test4/log2013.log
300K    test/test4/log2012.log
308K    test/test4
4.0K    test/scf/lib
4.0K    test/scf/service/deploy/product
4.0K    test/scf/service/deploy/info
12K     test/scf/service/deploy
16K     test/scf/service
4.0K    test/scf/doc
4.0K    test/scf/bin
32K     test/scf
4.0K    test/log2013.log
300K    test/log2012.log
4.0K    test/log30.tar.gz
4.0K    test/log.tar.bz2
4.0K    test/log.tar.gz
4.0K    test/test3/log2013.log
8.0K    test/test3
4.0K    test/scf.tar.gz
1.3M    test
[root@localhost soft]#
</code></pre><p>###显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</p>
<pre><code>[root@localhost test]# du -c log30.tar.gz log31.tar.gz 
4       log30.tar.gz
4       log31.tar.gz
8       总计
[root@localhost test]#
</code></pre><p>###按照空间大小排序</p>
<pre><code>[root@localhost test]# du|sort -nr|more
1288    .
608     ./test6
308     ./test4
32      ./scf
16      ./scf/service
12      ./scf/service/deploy
8       ./test3
4       ./scf/service/deploy/product
4       ./scf/service/deploy/info
4       ./scf/lib
4       ./scf/doc
4       ./scf/bin
[root@localhost test]#
</code></pre><p>###输出当前目录下各个子目录所使用的空间</p>
<pre><code>[root@localhost test]# du -h  --max-depth=1
608K    ./test6
308K    ./test4
32K     ./scf
8.0K    ./test3
1.3M    .
[root@localhost test]#
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/12/cookie-和session-的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/12/cookie-和session-的区别/" itemprop="url">cookie 和session 的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-12T14:37:50+08:00">
                2015-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载自<a href="http://www.cnblogs.com/shiyangxt/archive/2008/10/07/1305506.html" target="_blank" rel="external">这里</a>  </p>
<p>当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会把你在网站上所打的文字或是一些选择都纪录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie<br>里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多提供个人化服务的网站，都是利用 Cookie来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。</p>
<p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p>
<p>同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。</p>
<p>cookie机制。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。</p>
<p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。</p>
<p>会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p>
<p>session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p>
<p>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来<br>使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。</p>
<p>经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如： </p>
<pre><code>&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; 
&lt;input type=&quot;hidden&quot; name=&quot;jsessionid&quot; value=&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764&quot;&gt; 
&lt;input type=&quot;text&quot;&gt; 
&lt;/form&gt; 
</code></pre><p>实际上这种技术可以简单的用对action应用URL重写来代替。</p>
<p>cookie 和session 的区别：</p>
<ol>
<li><p>cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
</li>
<li><p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>考虑到安全应当使用session。</p>
</li>
<li><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>考虑到减轻服务器性能方面，应当使用COOKIE。</p>
</li>
<li><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
</li>
<li><p>所以个人建议：<br>将登陆信息等重要信息存放为SESSION<br>其他信息如果需要保留，可以放在COOKIE中</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/11/Python编程中常用的基础知识总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/11/Python编程中常用的基础知识总结/" itemprop="url">Python编程中常用的基础知识总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-11T10:34:19+08:00">
                2015-02-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Python编程中常用的12种基础知识总结：遍历目录方法，列表按列排序、去重，字典排序，字典、列表、字符串互转，时间对象操作，命令行参数解析(getopt)，print 格式化输出，进制转换，Python调用系统命令或者脚本，Python 读写文件。</p>
<h2 id="遍历目录方法"><a href="#遍历目录方法" class="headerlink" title="遍历目录方法"></a>遍历目录方法</h2><p>在某些时候，我们需要遍历某个目录找出特定的文件列表，可以通过os.walk方法来遍历，非常方便</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">fileList = []</div><div class="line">rootdir = <span class="string">"/data"</span></div><div class="line"><span class="keyword">for</span> root, subFolders, files <span class="keyword">in</span> os.walk(rootdir):</div><div class="line">    <span class="keyword">if</span> <span class="string">'.svn'</span> <span class="keyword">in</span> subFolders: </div><div class="line">        subFolders.remove(<span class="string">'.svn'</span>)  <span class="comment"># 排除特定目录</span></div><div class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</div><div class="line">        <span class="keyword">if</span> file.find(<span class="string">".t2t"</span>) != <span class="number">-1</span>:<span class="comment"># 查找特定扩展名的文件</span></div><div class="line">            file_dir_path = os.path.join(root,file)</div><div class="line">            fileList.append(file_dir_path)  </div><div class="line">    </div><div class="line"><span class="keyword">print</span> fileList</div></pre></td></tr></table></figure>
<h2 id="列表按列排序-list-sort"><a href="#列表按列排序-list-sort" class="headerlink" title="列表按列排序(list sort)"></a>列表按列排序(list sort)</h2><p>如果列表的每个元素都是一个元组(tuple),我们要根据元组的某列来排序的话，可参考如下方法</p>
<p>下面例子我们是根据元组的第2列和第3列数据来排序的,而且是倒序(reverse=True)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [(<span class="string">'2011-03-17'</span>, <span class="string">'2.26'</span>, <span class="number">6429600</span>, <span class="string">'0.0'</span>), (<span class="string">'2011-03-16'</span>, <span class="string">'2.26'</span>, <span class="number">12036900</span>, <span class="string">'-3.0'</span>),</div><div class="line"> (<span class="string">'2011-03-15'</span>, <span class="string">'2.33'</span>, <span class="number">15615500</span>,<span class="string">'-19.1'</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> a[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line"><span class="number">2011</span><span class="number">-03</span><span class="number">-17</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = sorted(a, key=<span class="keyword">lambda</span> result: result[<span class="number">1</span>],reverse=<span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> b</div><div class="line">[(<span class="string">'2011-03-15'</span>, <span class="string">'2.33'</span>, <span class="number">15615500</span>, <span class="string">'-19.1'</span>), (<span class="string">'2011-03-17'</span>, <span class="string">'2.26'</span>, <span class="number">6429600</span>, <span class="string">'0.0'</span>),</div><div class="line">(<span class="string">'2011-03-16'</span>, <span class="string">'2.26'</span>, <span class="number">12036900</span>, <span class="string">'-3.0'</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = sorted(a, key=<span class="keyword">lambda</span> result: result[<span class="number">2</span>],reverse=<span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> c</div><div class="line">[(<span class="string">'2011-03-15'</span>, <span class="string">'2.33'</span>, <span class="number">15615500</span>, <span class="string">'-19.1'</span>), (<span class="string">'2011-03-16'</span>, <span class="string">'2.26'</span>, <span class="number">12036900</span>, <span class="string">'-3.0'</span>),</div><div class="line">(<span class="string">'2011-03-17'</span>, <span class="string">'2.26'</span>, <span class="number">6429600</span>, <span class="string">'0.0'</span>)]</div></pre></td></tr></table></figure>
<h2 id="列表去重-list-uniq"><a href="#列表去重-list-uniq" class="headerlink" title="列表去重(list uniq)"></a>列表去重(list uniq)</h2><p>有时候需要将list中重复的元素删除，就要使用如下方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst= [(<span class="number">1</span>,<span class="string">'sss'</span>),(<span class="number">2</span>,<span class="string">'fsdf'</span>),(<span class="number">1</span>,<span class="string">'sss'</span>),(<span class="number">3</span>,<span class="string">'fd'</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>set(lst)</div><div class="line">set([(<span class="number">2</span>, <span class="string">'fsdf'</span>), (<span class="number">3</span>, <span class="string">'fd'</span>), (<span class="number">1</span>, <span class="string">'sss'</span>)])</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>set(lst)</div><div class="line">set([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</div></pre></td></tr></table></figure>
<h2 id="字典排序-dict-sort"><a href="#字典排序-dict-sort" class="headerlink" title="字典排序(dict sort)"></a>字典排序(dict sort)</h2><p>一般来说，我们都是根据字典的key来进行排序，但是我们如果想根据字典的value值来排序，就使用如下方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>aa = &#123;<span class="string">"a"</span>:<span class="string">"1"</span>,<span class="string">"sss"</span>:<span class="string">"2"</span>,<span class="string">"ffdf"</span>:<span class="string">'5'</span>,<span class="string">"ffff2"</span>:<span class="string">'3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sort_aa = sorted(aa.items(),key=itemgetter(<span class="number">1</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sort_aa</div><div class="line">[(<span class="string">'a'</span>, <span class="string">'1'</span>), (<span class="string">'sss'</span>, <span class="string">'2'</span>), (<span class="string">'ffff2'</span>, <span class="string">'3'</span>), (<span class="string">'ffdf'</span>, <span class="string">'5'</span>)]</div><div class="line">或者：</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sort_aa = sorted(aa.items(), key=<span class="keyword">lambda</span> result: result[<span class="number">1</span>])</div></pre></td></tr></table></figure>
<h2 id="字典-列表-字符串互转"><a href="#字典-列表-字符串互转" class="headerlink" title="字典,列表,字符串互转"></a>字典,列表,字符串互转</h2><p>以下是生成数据库连接字符串,从字典转换到字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>params = &#123;<span class="string">"server"</span>:<span class="string">"mpilgrim"</span>, <span class="string">"database"</span>:<span class="string">"master"</span>, <span class="string">"uid"</span>:<span class="string">"sa"</span>, <span class="string">"pwd"</span>:<span class="string">"secret"</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">"%s=%s"</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> params.items()]</div><div class="line">[<span class="string">'server=mpilgrim'</span>, <span class="string">'uid=sa'</span>, <span class="string">'database=master'</span>, <span class="string">'pwd=secret'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">";"</span>.join([<span class="string">"%s=%s"</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> params.items()])</div><div class="line"><span class="string">'server=mpilgrim;uid=sa;database=master;pwd=secret'</span></div></pre></td></tr></table></figure>
<p>下面的例子 是将字符串转化为字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'server=mpilgrim;uid=sa;database=master;pwd=secret'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>aa = &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> a.split(<span class="string">';'</span>):aa[i.split(<span class="string">'='</span>,<span class="number">1</span>)[<span class="number">0</span>]] = i.split(<span class="string">'='</span>,<span class="number">1</span>)[<span class="number">1</span>]  <span class="comment">#split('=',1)表示按'='分割1次</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>aa</div><div class="line">&#123;<span class="string">'pwd'</span>: <span class="string">'secret'</span>, <span class="string">'database'</span>: <span class="string">'master'</span>, <span class="string">'uid'</span>: <span class="string">'sa'</span>, <span class="string">'server'</span>: <span class="string">'mpilgrim'</span>&#125;</div></pre></td></tr></table></figure>
<h2 id="时间对象操作"><a href="#时间对象操作" class="headerlink" title="时间对象操作"></a>时间对象操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">将时间对象转换成字符串</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M"</span>)</div><div class="line">  <span class="string">'2011-01-20 14:05'</span></div><div class="line"> </div><div class="line">时间大小比较</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = time.strptime(<span class="string">'2011-01-20 14:05'</span>,<span class="string">"%Y-%m-%d %H:%M"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = time.strptime(<span class="string">'2011-01-20 16:05'</span>,<span class="string">"%Y-%m-%d %H:%M"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 &gt; t2</div><div class="line">  <span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 &lt; t2</div><div class="line">  <span class="keyword">True</span></div><div class="line"> </div><div class="line">时间差值计算,计算<span class="number">8</span>小时前的时间</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M"</span>)</div><div class="line">  <span class="string">'2011-01-20 15:02'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>(datetime.datetime.now() - datetime.timedelta(hours=<span class="number">8</span>)).strftime(<span class="string">"%Y-%m-%d %H:%M"</span>)</div><div class="line">  <span class="string">'2011-01-20 07:03'</span></div><div class="line"> </div><div class="line">将字符串转换成时间对象</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>endtime=datetime.datetime.strptime(<span class="string">'20100701'</span>,<span class="string">"%Y%m%d"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(endtime)</div><div class="line">  &lt;type <span class="string">'datetime.datetime'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> endtime</div><div class="line">  <span class="number">2010</span><span class="number">-07</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></div><div class="line"> </div><div class="line">将从 <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> UTC 到现在的秒数，格式化输出   </div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1302153828</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,time.localtime(a))</div><div class="line">  <span class="string">'2011-04-07 13:23:48'</span></div></pre></td></tr></table></figure>
<h2 id="命令行参数解析-getopt"><a href="#命令行参数解析-getopt" class="headerlink" title="命令行参数解析(getopt)"></a>命令行参数解析(getopt)</h2><p>通常在编写一些日运维脚本时，需要根据不同的条件，输入不同的命令行选项来实现不同的功能 在Python中提供了getopt模块很好的实现了命令行参数的解析,下面距离说明。请看如下程序:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> sys,os,getopt</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span><span class="params">()</span>:</span></div><div class="line"><span class="keyword">print</span> <span class="string">'''''</span></div><div class="line"><span class="string">Usage: analyse_stock.py [options...]</span></div><div class="line"><span class="string">Options:</span></div><div class="line"><span class="string">-e : Exchange Name</span></div><div class="line"><span class="string">-c : User-Defined Category Name</span></div><div class="line"><span class="string">-f : Read stock info from file and save to db</span></div><div class="line"><span class="string">-d : delete from db by stock code</span></div><div class="line"><span class="string">-n : stock name</span></div><div class="line"><span class="string">-s : stock code</span></div><div class="line"><span class="string">-h : this help info</span></div><div class="line"><span class="string">test.py -s haha -n "HA Ha"</span></div><div class="line"><span class="string">'''</span></div><div class="line"> </div><div class="line"><span class="keyword">try</span>:</div><div class="line">opts, args = getopt.getopt(sys.argv[<span class="number">1</span>:],<span class="string">'he:c:f:d:n:s:'</span>)</div><div class="line"><span class="keyword">except</span> getopt.GetoptError:</div><div class="line">usage()</div><div class="line">sys.exit()</div><div class="line"><span class="keyword">if</span> len(opts) == <span class="number">0</span>:</div><div class="line">usage()</div><div class="line">sys.exit()  </div><div class="line"> </div><div class="line"><span class="keyword">for</span> opt, arg <span class="keyword">in</span> opts:</div><div class="line"><span class="keyword">if</span> opt <span class="keyword">in</span> (<span class="string">'-h'</span>, <span class="string">'--help'</span>):</div><div class="line">  usage()</div><div class="line">  sys.exit()</div><div class="line"><span class="keyword">elif</span> opt == <span class="string">'-d'</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">"del stock %s"</span> % arg</div><div class="line"><span class="keyword">elif</span> opt == <span class="string">'-f'</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">"read file %s"</span> % arg</div><div class="line"><span class="keyword">elif</span> opt == <span class="string">'-c'</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">"user-defined %s "</span> % arg</div><div class="line"><span class="keyword">elif</span> opt == <span class="string">'-e'</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">"Exchange Name %s"</span> % arg</div><div class="line"><span class="keyword">elif</span> opt == <span class="string">'-s'</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">"Stock code %s"</span> % arg</div><div class="line"><span class="keyword">elif</span> opt == <span class="string">'-n'</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">"Stock name %s"</span> % arg  </div><div class="line"> </div><div class="line">sys.exit()</div></pre></td></tr></table></figure>
<h2 id="print-格式化输出"><a href="#print-格式化输出" class="headerlink" title="print 格式化输出"></a>print 格式化输出</h2><pre><code>截取字符串输出,下面例子将只输出字符串的前3个字母
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>str=<span class="string">"abcdefg"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%.3s"</span> % str</div><div class="line">  abc</div><div class="line">按固定宽度输出，不足使用空格补全,下面例子输出宽度为<span class="number">10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str=<span class="string">"abcdefg"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%10s"</span> % str</div><div class="line">     abcdefg</div><div class="line">截取字符串，按照固定宽度输出</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str=<span class="string">"abcdefg"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%10.3s"</span> % str</div><div class="line">         abc</div><div class="line">浮点类型数据位数保留</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fpformat</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a= <span class="number">0.0030000000005</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b=fpformat.fix(a,<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> b</div><div class="line">  <span class="number">0.003000</span></div><div class="line">对浮点数四舍五入,主要使用到round函数</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> *</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a =<span class="string">"2.26"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b =<span class="string">"2.29"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = Decimal(a) - Decimal(b)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> c</div><div class="line">  <span class="number">-0.03</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c / Decimal(a) * <span class="number">100</span></div><div class="line">  Decimal(<span class="string">'-1.327433628318584070796460177'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(str(round(c / Decimal(a) * <span class="number">100</span>, <span class="number">2</span>)))</div><div class="line">  Decimal(<span class="string">'-1.33'</span>)</div></pre></td></tr></table></figure>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>有些时候需要作不同进制转换，可以参考下面的例子(%x 十六进制,%d 十进制,%o 八进制)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="number">10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"Hex = %x,Dec = %d,Oct = %o"</span> %(num,num,num)</div><div class="line">  Hex = a,Dec = <span class="number">10</span>,Oct = <span class="number">12</span></div></pre></td></tr></table></figure>
<h2 id="Python调用系统命令或者脚本"><a href="#Python调用系统命令或者脚本" class="headerlink" title="Python调用系统命令或者脚本"></a>Python调用系统命令或者脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">使用 os.system() 调用系统命令 , 程序中无法获得到输出和返回值</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">'ls -l /proc/cpuinfo'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">"ls -l /proc/cpuinfo"</span>)</div><div class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">53</span> /proc/cpuinfo</div><div class="line">  <span class="number">0</span></div><div class="line"> </div><div class="line">使用 os.popen() 调用系统命令, 程序中可以获得命令输出，但是不能得到执行的返回值</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>out = os.popen(<span class="string">"ls -l /proc/cpuinfo"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> out.read()</div><div class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">59</span> /proc/cpuinfo  </div><div class="line"> </div><div class="line">使用 commands.getstatusoutput() 调用系统命令, 程序中可以获得命令输出和执行的返回值</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> commands</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>commands.getstatusoutput(<span class="string">'ls /bin/ls'</span>)</div><div class="line">  (<span class="number">0</span>, <span class="string">'/bin/ls'</span>)</div></pre></td></tr></table></figure>
<h2 id="Python-读写文件"><a href="#Python-读写文件" class="headerlink" title="Python 读写文件"></a>Python 读写文件</h2><pre><code class="python">一次性读入文件到列表，速度较快，适用文件比较小的情况下
track_file = <span class="string">"track_stock.conf"</span>
fd = open(track_file)
content_list = fd.readlines()
fd.close()
<span class="keyword">for</span> line <span class="keyword">in</span> content_list:
    <span class="keyword">print</span> line  

逐行读入，速度较慢,适用没有足够内存读取整个文件(文件太大)
fd = open(file_path)
fd.seek(<span class="number">0</span>)
title = fd.readline()
keyword = fd.readline()
uuid = fd.readline()
fd.close()  

写文件 write 与 writelines 的区别   

Fd.write(str) : 把str写到文件中，write()并不会在str后加上一个换行符
Fd.writelines(content) : 把content的内容全部写到文件中,原样写入，不会在每行后面加上任何东西
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/10/在浏览器输入url回车，和直接按F5刷新有什么区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/10/在浏览器输入url回车，和直接按F5刷新有什么区别/" itemprop="url">在浏览器输入url回车，和直接按F5刷新有什么区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-10T16:12:03+08:00">
                2015-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>按F5刷新浏览器和在地址栏里输入网址然后回车。 这两个行为是不一样的。</p>
<p>按F5刷新浏览器， 浏览器会去Web服务器验证缓存。</p>
<p>如果是在地址栏输入网址然后回车，浏览器会”直接使用有效的缓存”, 而不会发http request 去服务器验证缓存，这种情况叫做缓存命中，如下图</p>
<p><img src="/img/缓存命中.png" alt=""></p>
<p>实例： 比较第一次访问博客园主页和第二次博客园主页</p>
<ol>
<li><p>启动Fiddler, 用firefox打开博客园主页， 发现有50多个session。</p>
</li>
<li><p>按CTRL+X将Fiddler中的所有session删除。 关闭firefox,重新打开一个firefox，打开博客园主页。   发现只有30多个session.</p>
</li>
</ol>
<p>分析；  少了的session是因为firefox直接用了缓存，而没有发http request。</p>
<p><img src="/img/第一次访问.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/10/http判断缓存是否有效，为什么有了last-modified还需要etag/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/10/http判断缓存是否有效，为什么有了last-modified还需要etag/" itemprop="url">http判断缓存是否有效，为什么有了last-modified还需要etag</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-10T15:49:54+08:00">
                2015-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>If-Modified-Since：<br>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</p>
<p>ETag：<br>是实体标签（Entity Tag）的缩写， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。</p>
<p>ETag是Web服务端产生的，然后发给浏览器客户端。浏览器客户端是不用关心Etag是如何产生的。</p>
<p>问题是，我们知道last-modified可以用来判断浏览器的本地缓存是否有效，那为什么还要使用ETag呢？ 主要是为了解决Last-Modified 无法解决的一些问题。</p>
<ol>
<li><p>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。</p>
</li>
<li><p>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</p>
</li>
<li><p>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/10/为什么http协议是无连接的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/10/为什么http协议是无连接的/" itemprop="url">为什么http协议是无连接的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-10T14:13:31+08:00">
                2015-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HTTP 协议本身是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。</p>
<p> TCP的面向连接是传输层的，而HTTP的无连接则是应用层的 。HTTP协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端（即浏览器）与服务器之间交换数据的间歇性较大（即传输具有突发性、瞬时性），并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，如果按照上面的方式，则需要在服务器端开的进程和句柄数目都是不可接受的，大部分通道实际上会很空闲、无端占用资源。因此HTTP的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。HTTP1.1现在设计为长连接，就是在一个连接内可以发生多个请求，避免了多次建立断开连接造成的消耗。</p>
<p>UDP尽管不象TCP那样占用资源，但它不保证数据的完整性、有序性，想像如果服务器返回的HTML错序了或者丢失一部分你将看到什么效果；并且UDP没有流量控制，而互联网的传输质量又不是很好，服务器随便仍出一大堆UDP包可能导致网络风暴，这是相当危险的。</p>
<p>归根结底，TCP的面向连接是传输层的，而HTTP的无连接则是应用层的。</p>
<hr>
<p><strong>无状态</strong>是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系</p>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</p>
<p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p> Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/05/TCP和UDP的工作过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/05/TCP和UDP的工作过程/" itemprop="url">TCP和UDP的工作过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-05T16:41:11+08:00">
                2015-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP-IP/" itemprop="url" rel="index">
                    <span itemprop="name">TCP/IP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##TCP和UDP的工作过程<br>UDP的工作过程是简单的，仅仅将用户数据封装到一个IP数据报中发送到目的地而已，而不关注其他方面。</p>
<p>TCP却是一个极其复杂的协议，以下只是冰山一角</p>
<p>###建立连接的三次握手</p>
<ul>
<li>主动方发送（SYN J），进入SYN_SENT状态</li>
<li>被动方收到（SYN J），并往回发送（SYN K, ACK J+1），进入SYN_RCVD状态</li>
<li>主动方收到（SYN K, ACK J+1），并往回发送（ACK K+1），进入ESTABLISHED状态</li>
<li>被动方收到（ACK K+1），也进入ESTABLISHED状态<br>以上过程如下图所示：</li>
</ul>
<p><img src="/img/establish.png" alt="establish"></p>
<p>注意到在TCP三次握手的过程中，服务器有这么一条：</p>
<blockquote>
<p>被动方收到（SYN J），并往回发送（SYN K, ACK J+1），进入SYN_RCVD状态</p>
</blockquote>
<p>服务器进入<code>SYN_RCVD</code>状态（此时连接称为半开连接）后，应当期待再收到一个ACK。 如果超时未收到客户端的<code>ACK</code>，服务器将重发<code>（SYN K, ACK J+1）</code>。 于是，就有一种叫做<code>SYN Flooding</code>的攻击方式。 攻击者向服务器高速发送<code>（SYN J）</code>（而且可以将SYN分节中的IP地址设为随机数）， 并且在随后收到服务器回复的<code>（SYN K, ACK J+1）</code>之后不再继续回复， 这使得服务器上存在很多的半开连接，这些半开连接一般情况下会持续63秒 （在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会把断开这个连接）。 它的危害有两方面，一方面自然是占用了服务器的资源；另一方面是填充了半开连接的队列，使得合法的SYN分节无法排队。</p>
<p>根据SYN Flooding的攻击原理，它的防范主要有以下措施：</p>
<ol>
<li>过滤掉最大嫌疑攻击的IP或IP段</li>
<li>将tcp_synack_retries设为0，表示回应第二个握手包（SYN K, ACK J+1）给客户端后，如果收不到ACK，不进行重试，加快回收“半开连接”。</li>
<li>将tcp_max_syn_backlog参数根据内存情况适当调大，该参数一般指的是维护的半开连接的队列的长度（不同OS不一样）。</li>
<li>设置tcp_abort_on_overflow选项，处理不过来就直接拒绝掉。</li>
</ol>
<p>###断开连接的四次握手</p>
<ol>
<li>主动方发送<code>（FIN M）</code>，进入<code>FIN_WAIT_1</code>状态</li>
<li>被动方收到<code>（FIN M）</code>，并往回发送<code>（ACK M+1）</code>，进入<code>CLOSE_WAIT</code>状态</li>
<li>主动方收到<code>（ACK M+1）</code>，进入<code>FIN_WAIT_2</code>状态</li>
<li>被动方发送<code>（FIN N）</code>，进入<code>LAST_ACK</code>状态</li>
<li>主动方收到<code>（FIN N）</code>，并往回发送<code>（ACK N+1）</code>，进入<code>TIME_WAIT</code>状态</li>
<li>被动方收到<code>（ACK N+1）</code>，进入<code>CLOSED</code>状态</li>
<li>主动方在<code>TIME_WAIT</code>状态中超时后，进入<code>CLOSED</code>状态</li>
</ol>
<p>以上过程如下图所示：</p>
<p><img src="/img/close.png" alt="close"></p>
<p>其实就是2次，只不过TCP是全双工的，所以，发送方和接收方都需要FIN和ACK。 只不过，有一方是被动的，所以看上去就成了所谓的4次挥握手。</p>
<p>注意到最后有这么一条涉及到TIME_WAIT的状态</p>
<blockquote>
<p>主动方在TIME_WAIT状态中超时后，进入CLOSED状态</p>
</blockquote>
<p>需要经过一个<code>TIME_WAIT</code>超时的状态而不是直接进入<code>CLOSED</code>的原因有两个，一是确保有足够的时间让对端收到<code>ACK</code>，二是允许老的分节在网络中慢慢的消逝。</p>
<p>然而，如果系统中存在着大量的短链接，那么大量的<code>TIME_WAIT</code>状态就会成为系统的累赘。网上一些资料提到的<code>tcp_tw_reuse</code>和<code>tcp_tw_recycle</code>选项来解决这个问题，但是最好还是别乱用，好像<code>coolshell</code>中有提到过，可能会出很多诡异的问题。还可以调整<code>tcp_max_tw_buckets</code>，当并发的<code>TIME_WAIT</code>过多时，会直接把多的给destory掉，然后在日志里打一个警告。引用一句“其实，<code>TIME_WAIT</code>表示的是你主动断连接，所以，这就是所谓的<code>&quot;no zuo， no die&quot;</code>。</p>
<p>##TCP连接在“非正常”情况下的工作状况</p>
<p>###服务器进程终止</p>
<p>首先，服务器进程终止（收到<code>SIGKILL</code>信号）。作为进程中止处理的工作之一，该进程所有打开着的描述符将被关闭，这会导致向对端（客户端）发送（<code>FIN N</code>），而客户端则回复（<code>ACK N+1</code>），这就是TCP断开连接的前半部分。</p>
<p>然后，此时客户端收到（<code>FIN N</code>）并不意味着连接断开（虽然在这个例子中，确实断开了），只是意味着服务器不再向客户端发送数据了，客户端还可以继续向服务器发送数据。如果此时客户端还继续向服务器发送数据，服务器TCP将发现之前的打开该套接字的进程已终止，于是回应一个<code>RST</code>。客户端在收到这个<code>RST</code>之前的read操作将会返回EOF，在收到这个<code>RST</code>后的read操作会返回<code>ECONNRESET</code>错误，在收到这个<code>RST</code>后的write操作会使当前进程收到<code>SIGPIPE</code>信号。</p>
<p>以上过程如下图所示：</p>
<p><img src="/img/server_kill.png" alt="server_kill"></p>
<p>###服务器主机崩溃</p>
<p>服务器主机崩溃的意思是，没有任何预兆，来不及在网络上发送任何消息，主机就无法工作了。这种情况等价于直接切断网络，或者通俗的说，可以直接拔掉网线来模拟这一情况。</p>
<p>这时，如果客户端向服务器发送数据，后调用read操作，TCP会一直等待服务器的ACK确认消息，并且不断的超时重传（按照Berkeley的实现，重传12次，共需9分钟），直到到达重传次数，返回<code>ETIMEOUT</code>错误。如果是由中间的路由器判定服务器主机不可达，响应“destination unreasonable”的ICMP消息，将返回<code>EHOSTUNREACH</code>和<code>ENETUNREACH</code>错误。</p>
<p>###服务器主机崩溃后重启</p>
<p>重启之后的服务器已经丢失了之前的TCP信息，所以即使收到了客户端发来的TCP数据，也会回复<code>RST</code>，往后的情况和“服务器主机崩溃”中提到的类似。</p>
<p>###服务器主机关机</p>
<p>Unix系统关机时，init进程通常会给其他进程发送<code>SIGTERM</code>信号，然后等待10s左右给仍在运行的进程发送<code>SIGKILL</code>信号。所以如果进程不捕获<code>SIGTERM</code>信号，则将由<code>SIGKILL</code>信号终止，和“服务器进程终止”中提到的类似。</p>
<p>##参考链接<br><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">TCP 的那些事儿（上）</a></p>
<p><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">168</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="michaelseu2011@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
