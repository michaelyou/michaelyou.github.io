<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-URLconf的url匹配" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/15/URLconf的url匹配/" class="article-date">
  <time datetime="2015-04-15T08:26:40.000Z" itemprop="datePublished">2015-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Django/">Django</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/15/URLconf的url匹配/">URLconf的url匹配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Django在检查URL模式前，移除每一个申请的URL开头的斜杠(/)。 这意味着我们为<code>/hello/</code>写URL模式不用包含斜杠(/)。（刚开始，这样可能看起来不直观，但这样的要求简化了许多工作，如URL模式内嵌，我们将在django book第八章谈及。）</p>
<p>模式包含了一个尖号(^)和一个美元符号($)。这些都是正则表达式符号，并且有特定的含义： <strong>上箭头要求表达式对字符串的头部进行匹配，美元符号则要求表达式对字符串的尾部进行匹配</strong>。</p>
<p>最好还是用范例来说明一下这个概念。 如果我们用尾部不是$的模式<code>’^hello/’</code>，那么任何以<code>/hello/</code>开头的URL将会匹配，例如：<code>/hello/foo</code>和<code>/hello/bar</code>，而不仅仅是<code>/hello/</code>。类似地，如果我们忽略了尖号(^)，即<code>’hello/$’</code>，那么任何以<code>hello/</code>结尾的URL将会匹配，例如：<code>/foo/bar/hello/</code>。如果我们简单使用<code>hello/</code>，即没有^开头和$结尾，那么任何包含<code>hello/</code>的URL将会匹配，如：<code>/foo/hello/bar</code>。因此，我们使用这两个符号以确保只有<code>/hello/</code>匹配，不多也不少。</p>
<p>你大多数的URL模式会以<code>^</code>开始、以<code>$</code>结束，但是拥有复杂匹配的灵活性会更好。</p>
<p>你可能会问：如果有人申请访问/hello（尾部没有斜杠/）会怎样。 因为我们的URL模式要求尾部有一个斜杠(/)，那个申请URL将不匹配。 <strong>然而，默认地，任何不匹配或尾部没有斜杠(/)的申请URL，将被重定向至尾部包含斜杠的相同字眼的URL</strong>。 （这是受配置文件setting中APPEND_SLASH项控制的，参见django book附件D。）</p>
<p>如果你是喜欢所有URL都以’/’结尾的人（Django开发者的偏爱），那么你只需要在每个URL后添加斜杠，并且设置<code>”APPEND_SLASH”</code>为<code>”True”</code>. 如果不喜欢URL以斜杠结尾或者根据每个URL来决定，那么需要设置<code>”APPEND_SLASH”</code>为<code>”False”</code>,并且根据你自己的意愿来添加结尾斜杠/在URL模L模式后.</p>
<p>–《django book 2.0》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/04/15/URLconf的url匹配/" data-id="cj64uppye002rlraeikzjbxax" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python的搜索路径" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/15/python的搜索路径/" class="article-date">
  <time datetime="2015-04-15T08:24:56.000Z" itemprop="datePublished">2015-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/15/python的搜索路径/">python的搜索路径</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Python 搜索路径 就是使用 import 语句时，Python 所查找的系统目录清单。</p>
<p>举例来说，假定你将 Python 路径设置为<code>[&#39;&#39;,&#39;/usr/lib/python2.4/site-packages&#39;,&#39;/home/username/djcode/&#39;]</code>。如果执行代码 <code>from foo import bar</code> ，Python 将会首先在当前目录查找 foo.py 模块( Python 路径第一项的空字符串表示当前目录)。 如果文件不存在，Python将查找 <code>/usr/lib/python2.4/site-packages/foo.py</code> 文件。</p>
<p>如果你想看Python搜索路径的值，运行Python交互解释器，然后输入：</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; print sys.path
</code></pre><p>通常，你不必关心 Python 搜索路径的设置。 Python 和 Django 会在后台自动帮你处理好。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/04/15/python的搜索路径/" data-id="cj64upq2g007klraei0aalk2g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python路径操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/14/python路径操作/" class="article-date">
  <time datetime="2015-04-14T06:32:19.000Z" itemprop="datePublished">2015-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/14/python路径操作/">python路径操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##<code>__file__</code><br><code>__file__</code>可以获取当前的脚本</p>
<p>在/root/michael/目录下创建一个脚本为test.py</p>
<p>在脚本里写下</p>
<pre><code>#!/usr/bin/env python

import os

print __file__
print os.path.abspath(__file__)
print os.path.dirname(os.path.abspath(__file__))
</code></pre><p>运行结果为</p>
<pre><code>[root@pc105 michael]# ./test.py 
./test.py
/root/michael/test.py
/root/michael
</code></pre><ul>
<li><p><code>__file__</code>是取当前脚本的路径，是相对路径，所以一般要在前面加上<code>abspath</code>来取绝对路径</p>
</li>
<li><p><code>os.path.dirname</code>获得当前目录的上级目录</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/04/14/python路径操作/" data-id="cj64upq2j007wlraeq4kb52ck" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-scp不能拷贝符号链接" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/13/scp不能拷贝符号链接/" class="article-date">
  <time datetime="2015-04-13T01:42:34.000Z" itemprop="datePublished">2015-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/13/scp不能拷贝符号链接/">scp不能拷贝符号链接</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天把一个web目录直接scp -r到另一台机器上，发现起不来，后来发现是在配置目录下的一些符号连接都没有拷贝过来。</p>
<p>如果要将这些符号连接拷贝过来，不能直接scp -r这个文件夹，<strong>需要先将文件夹打包，然后拷贝</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/04/13/scp不能拷贝符号链接/" data-id="cj64upq2k007ylraeocck6kag" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python导入模块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/08/python导入模块/" class="article-date">
  <time datetime="2015-04-08T01:45:36.000Z" itemprop="datePublished">2015-04-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/08/python导入模块/">python导入模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#python导入模块</p>
<p>##使用from <strong> import </strong>不能节约内存</p>
<p>python导入模块和他们的属性有两种方法：</p>
<pre><code>import random
print random.choice(range(10))
</code></pre><p>和</p>
<pre><code>from random import choice
print choice(range(10))
</code></pre><p>第一种方法是将模块的名字设置为一个隐含的名字空间里的全局变量，这样你就可以好像访问全局属性那样访问choice函数。而在第二个例子里，我们是直接把choice引入到全局名字空间里来（而非模块的名字）。因此不再需要把这个属性当成是模块的成员了。实际上我们也只拥有了这个属性而已。</p>
<p><strong>Python新手之间经常有一种误解，以为第二种方法只导入了一个函数，而没有导入整个模块。这是不对的。整个模块其实已经被导入了，但是只有那个函数的引用被保存了起来。所以from-import这种语法并不能带来性能上的差异，也没有节省什么内存。</strong></p>
<p>##能不能重复导入一个模块</p>
<p>新手经常会担忧的一个问题是他们有两个模块m.py和n.py都导入了foo.py模块。当m导入n时，foo岂不是会被导入两次？简单的来说，没错，是这样的，但是和你想的有点不一样。</p>
<p>Python有<code>导入模块</code>（importing）和<code>加载模块</code>（loading）之分。一个模块可以被导入任意多次，但是它<strong>只会被加载一次</strong>。就是说，当Python碰到一个已经被加载的模块又被导入时，它会跳过加载的过程，所以你无需担心额外消耗内存的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/04/08/python导入模块/" data-id="cj64upq290079lraefxhlky7a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-i-的线程安全性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/28/i-的线程安全性/" class="article-date">
  <time datetime="2015-03-28T10:25:29.000Z" itemprop="datePublished">2015-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/28/i-的线程安全性/">i++的线程安全性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自<a href="http://blog.csdn.net/sapair/archive/2009/06/05/4243974.aspx" target="_blank" rel="external">这里</a></p>
<p>i++的线程安全性可以总结如下：</p>
<ol>
<li>如果i是局部变量，那么是可重入的，也就是线程安全的。</li>
<li>如果i是全局变量，则同一进程的不同线程都可能访问到该变量，因而是线程不安全的。</li>
</ol>
<p>上面这两点比较清晰，具体原因我将在下面解释：</p>
<p>本质上来讲，i并不是因为是全局变量才说是线程不安全的。其实其本质原因是i++这个操作并不是原子的，如果这是原子操作的话，具有不可分特性，那么即便是所有线程都能访问到，也都是线程安全的。</p>
<p>i++最终被编译后的反汇编代码大概如下：</p>
<pre><code>mov eax，[xxxxxxxx]
inc   eax
</code></pre><p>一条c语句已经被分为两条操作指令，那么在这两条操作指令执行之间，可能由于中断而被调度到不同线程，于是，不安全性就产生了。当然了，这并不是说单条汇编语句就是线程安全的，这取决于CPU架构，因为单条汇编指令可能在多个CPU时钟周期内进行，有些CPU架构可以在任何一个时钟周期内响应中断，对于这样的CPU，就是单条指令都不是安全的。当然了，现在的CPU大部分都是一条指令执行完后才能响应中断的。想要进行原子操作，方法有很多种，其中一种比较简单的是在原子语句之间先关闭中断，然后进行原子操作后再打开中断就OK了。</p>
<p>##原子操作</p>
<p>所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程），不能被更高等级中断抢夺优先。</p>
<p>由于操作系统大部分时间处于开中断状态，所以，一个程序在执行的时候可能被优先级更高的线程中断。而有些操作是不能被中断的，不然会出现无法还原的后果，这时候，这些操作就需要原子操作。就是不能被中断的操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/28/i-的线程安全性/" data-id="cj64upq0u005hlraeu7smw5ts" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-malloc和free的实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/27/malloc和free的实现原理/" class="article-date">
  <time datetime="2015-03-27T11:56:38.000Z" itemprop="datePublished">2015-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/27/malloc和free的实现原理/">malloc和free的实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前写过一篇<a href="http://michaelyou.github.io/2015/03/20/%E4%B8%BA%E4%BB%80%E4%B9%88malloc%E6%97%B6%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9Asize%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84free%E6%97%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9Asize/" target="_blank" rel="external">为什么free函数不需要指定需要释放的内存大小</a>，这个问题算是解释清楚了，但是针对malloc的实现又不怎么记得了，抽空又把《深入理解计算机系统》相关段落看了一遍，真的是好书啊！浅显易懂，真是适合我。</p>
<hr>
<p>内存分配是按照<code>堆块</code>实现的，<strong>一个堆块是由头部和有效载荷量组成，其中的有效载荷量就是我们申请的堆的大小</strong>。<br>头部块包括 块大小和是否可用这两个部分组成。</p>
<p><strong>在内存中这些堆块以链表形式组成</strong></p>
<p>malloc函数的实质体现在：它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿<code>连接表</code>寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。</p>
<blockquote>
<p>这里注意，malloc找到的内存块大小一定是会大于等于我们需要的内存大小，下面会提到如果所有的内存块都比要求的小会怎么办？</p>
</blockquote>
<p>调用free函数时，它将用户释放的内存块连接到空闲链上。<strong><em>到最后，空闲链会被切成很多的小内存片段</em></strong>，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，<strong>将相邻的小空闲块合并成较大的内存块</strong>。</p>
<p>glibc维护了<code>不止一个</code>不定长的内存块链表，而是好几个，每一个这种链表负责一个大小范围，这种做法有效<strong>减少了分配大内存时的遍历开销</strong>，类似于<code>哈希</code>的方式，将很大的范围的数据散列到有限的几个小的范围内而不是所有数据都放在一起，虽然最终还是要在小的范围内查找，但是最起码省去了很多的开销，如果只有一个不定长链表那么就要全部遍历，如果分成3个，就省去了2/3的开销，总之这个策略十分类似于散列。</p>
<p>glibc另外的策略就是不止维护一类空闲链表，而是另外再维护一个缓冲链表和一个高速缓冲链表，在分配的时候首先在高速缓存中查找，失败之后再在空闲链表查找，如果找到的内存块比较大，那么将切割之后的剩余内存块插入到缓存链表，如果空闲链表查找失败那么就往缓存链表中查找. 如果还是没有合适的空闲块，就向内存申请比请求数更大的内存块，然后把剩下的内存放入链表中。</p>
<p>在对内存块进行了 free 调用之后，我们需要做的是诸如将它们标记为未被使用的等事情，并且，在调用 malloc 时，我们要能够定位未被使用的内存块。因此， <strong>malloc返回的每块内存的起始处首先要有这个结构</strong>：</p>
<p>这就解释了，为什么在程序中free之后，但是堆的内存还是没有释放。</p>
<pre><code>内存控制块结构定义
struct mem_control_block {
    int is_available;
    int size;
};
</code></pre><p>现在，您可能会认为当程序调用 malloc 时这会引发问题 —— 它们如何知道这个结构？答案是它们不必知道；在返回指针之前，我们会将其移动到这个结构之后，把它隐藏起来。这使得返回的指针指向没有用于任何其他用途的内存。那样，从调用程序的角度来看，它们所得到的全部是空闲的、开放的内存。然后，当通过 free() 将该指针传递回来时，<strong>我们只需要倒退几个内存字节就可以再次找到这个结构</strong>。</p>
<p>在讨论分配内存之前，我们将先讨论释放，因为它更简单。为了释放内存，我们必须要做的惟一一件事情就是，获得我们给出的指针，回退 sizeof(struct mem_control_block) 个字节，并将其标记为可用的。这里是对应的代码：</p>
<pre><code>解除分配函数
void free(void *firstbyte) {
        struct mem_control_block *mcb;
        /* Backup from the given pointer to find the
         * mem_control_block
         */
       mcb = firstbyte - sizeof(struct mem_control_block);
        /* Mark the block as being available */
          mcb-&gt;is_available = 1;
        /* That&apos;&apos;s It!  We&apos;&apos;re done. */
       return;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/27/malloc和free的实现原理/" data-id="cj64upq1g006alrae8nw7u5ld" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python的装饰器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/26/python的装饰器/" class="article-date">
  <time datetime="2015-03-26T14:06:05.000Z" itemprop="datePublished">2015-03-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/26/python的装饰器/">python的装饰器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>openstack的代码大量地使用了python的这个高级特性，之前看书的时候就没看明白，今天重新看了一遍，稍微懂一些了，记录一下。</p>
<hr>
<p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的<strong>雷同代码</strong>并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<p>注意这一句</p>
<blockquote>
<p>抽离出大量函数中与函数功能本身无关的<strong>雷同代码</strong>并继续重用</p>
</blockquote>
<ol>
<li>装饰器是用来装饰函数的</li>
<li>装饰器是将很多函数都有的代码提取出来，写在装饰器里面，这样用装饰器装饰函数的时候，就赋予了函数一些新功能</li>
</ol>
<p>举个例子</p>
<p>我希望在每个函数执行之前都能够将函数名打出来，大家知道函数有一个<code>__name__</code>属性是可以打印函数名的，那我每次定义函数都要这么写</p>
<pre><code>def fun():
    print fun.__name__
    ...
</code></pre><p>只有一行代码大家可能不以为然，就加上这行代码能费多大事情呢，但是在实际使用中往往不止一行代码这么简单，比如我还想知道这个函数有没有文档，那就要调用<code>__doc__</code>属性，我想在函数执行的时候捕获异常，有了异常要写入log，那你就要加上<code>try-except</code>，还需要加上写log，这样加起来就多了5,6行代码，每个函数都多这么重复代码简直是种折磨，<code>修饰器@</code>就是为了解决这个问题。</p>
<pre><code>&gt;&gt;&gt; def deco(func):
...     print(&quot;before myfunc() called.&quot;)
...     func()
...     print(&quot;after myfunc() called.&quot;)
... 
&gt;&gt;&gt; @deco
... def myfunc():
...     print(&quot;myfunc() called.&quot;)
... 
before myfunc() called.
myfunc() called.
after myfunc() called.
</code></pre><p>只要在每个函数的定义之前加上<code>@deco</code>，就会在每次调用之前和调用之后打出代码中的字符串。</p>
<p>这里大家有没有发现一个问题，我在这里根本没有调用函数，但是竟然有了输出，这不合理啊？</p>
<p>这样写的话其实只是执行了初始化装饰器导致的输出，和我们对装饰器的要求是不一样的，<strong>正确的应该这么写</strong></p>
<pre><code> 1 #!/usr/bin/python
 2 
 3 def deco(func):
 4     def wrapper():
 5         print(&quot;before myfunc() called.&quot;)
 6         func()
 7         print(&quot;after myfunc() called.&quot;)
 8     return wrapper
 9 
10 @deco
11 def myfunc():
12     print(&quot;myfunc() called.&quot;)
13 
14 myfunc()
</code></pre><p>我们在 deco 里面返回了一个 wrapper 函数对象。可以试着这么理解，deco的作用是给 func 进行装饰，wrapper 就是被装饰过的func。我们以后调用func就是在调用wrapper这个函数</p>
<p>##装饰一个需要传参的函数</p>
<p>##装饰参数列表不一样的多个函数</p>
<p>未完待续…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/26/python的装饰器/" data-id="cj64upq2f007ilraejwb9sl0o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-fork和exec" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/25/fork和exec/" class="article-date">
  <time datetime="2015-03-25T13:06:20.000Z" itemprop="datePublished">2015-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/25/fork和exec/">fork和exec</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##fork（）<br>一个程序调用fork函数。首先，系统让新的进程与旧的进程使用同一个代码段，因为它们的程序还是相同的，对于数据段和堆栈段，系统则复制一份给新的进程，这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。而如果两个进程要共享什么数据的话，就要使用另一套函数（shmget，shmat，shmdt等）来操作。现在，已经是两个进程了，对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零，这样，对于程序，只要判断fork函数的返回值，就知道自己是处于父进程还是子进程中。</p>
<p>事实上，目前大多数的unix系统在实现上并没有作真正的copy。一般的，CPU都是以“页”为单位分配空间的，象INTEL的CPU，其一页在通常情况下是4K字节大小，而无论是数据段还是堆栈段都是由许多“页”构成的，fork函数复制这两个段，只是“逻辑”上的，并非“物理”上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的“页”从物理上也分开。系统在空间上的开销就可以达到最小。 </p>
<p>##exec系列函数<br><strong>一个进程一旦调用exec类函数，它本身就“死亡”了</strong>，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。不过exec类函数中有的还允许继承环境变量之类的信息，这个通过exec系列函数中的一部分函数的参数可以得到。</p>
<p>##对于fork（）： </p>
<ol>
<li>子进程复制父进程的所有进程内存到其内存地址空间中。父、子进程的<br>“数据段”，“堆栈段”和“代码段”完全相同，即子进程中的每一个字节都<br>和父进程一样。 </li>
<li>子进程的当前工作目录、umask掩码值和父进程相同，fork（）之前父进程<br>打开的文件描述符，在子进程中同样打开，并且都指向相同的文件表项。 </li>
<li>子进程拥有自己的进程ID。</li>
</ol>
<p>##对于exec（）： </p>
<ol>
<li>进程调用exec（）后，将在同一块进程内存里用一个新程序来代替调用<br>exec（）的那个进程，新程序代替当前进程映像，当前进程的“数据段”，<br>“堆栈段”和“代码段”被新程序改写。 </li>
<li>新程序会保持调用exec（）进程的ID不变。 </li>
<li>调用exec（）之前打开打开的描述字继续打开（好像有什么参数可以令打开<br>的描述字在新程序中关闭）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/25/fork和exec/" data-id="cj64upq0k0052lraecv9bn2pf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TCP是一种流协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/24/TCP是一种流协议/" class="article-date">
  <time datetime="2015-03-24T02:58:19.000Z" itemprop="datePublished">2015-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TCP-IP/">TCP/IP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/24/TCP是一种流协议/">TCP是一种流协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前写过一篇是<a href="http://michaelyou.github.io/2015/03/13/tcp%E6%98%AF%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83-%E6%8B%86%E5%8C%85%E5%92%8C%E7%B2%98%E5%8C%85/" target="_blank" rel="external">tcp是流的一些思考–拆包和粘包</a>，是我自己对这个问题的一些认识，毕竟见识浅薄，所言不成系统。今天看到了之前看过的一篇文章，正是对这个问题的一些深入解释，特转载于此，与大家共享。</p>
<p>转载自《TCP/IP高效编程 改善网络程序的44个技巧》–技巧6：记住TCP是一种流协议</p>
<hr>
<p>TCP是一种流协议（stream protocol）。这就意味着数据是以字节流的形式传递给接收者的，没有固有的”报文”或”报文边界”的概念。从这方面来说，读取TCP数据就像从串行端口读取数据一样–无法预先得知在一次指定的读调用中会返回多少字节。</p>
<p>为了说明这一点，我们假设在主机A和主机B的应用程序之间有一条TCP连接，主机A上的应用程序向主机B发送一条报文。进一步假设主机A有两条报文要发送，并两次调用send来发送，每条报文调用一次。很自然就会想到从主机A向主机B发送的两条报文是作为两个独立实体，在各自的分组中发送的，如图2-25所示。</p>
<p><img src="/img/发送两条报文的错误类型.png" alt="图2-25　发送两条报文的错误模型"></p>
<p>但不幸的是，实际的数据传输过程很可能不会遵循这个模型。主机A上的应用程序会调用send，我们假设这条写操作的数据被封装在一个分组中传送给B。实际上，send通常只是将数据复制到主机A的TCP/IP栈中，就返回了。由TCP来决定（如果有的话）需要立即发送多少数据。做这种决定的过程很复杂，取决于很多因素，比如发送窗口（当时主机B能够接收的数据量），拥塞窗口（对网络拥塞的估计），路径上的最大传输单元（沿着主机A和B之间的网络路径一次可以传输的最大数据量），以及连接的输出队列中有多少数据。更多与此有关的内容请参见技巧15。图2-26只显示了主机A的TCP封装数据时可能使用的诸多方法中的4种。在图2-26中，M11和M12表示M1的第一和第二部分，M21和M22与之类似。如图2-26所示，TCP不一定会将一条报文的全部内容都放在一个分组中传送出去。</p>
<p><img src="/img/封装两条报文可能采用的4种方式.png" alt="图2-26　封装两条报文可能采用的4种方式"></p>
<p>现在，我们从主机B应用程序的角度来看这种情形。总的来说，主机B应用程序任意一次调用recv时，都不会对TCP发送给它的数据量做任何假设。比如，当主机B应用程序读取第一条报文时，可能会出现下列4种结果。</p>
<blockquote>
<p>　实际上，可能的结果不止4种，但我们忽略了出错和EOF之类的结果。我们还假设应用程序读取了所有可读的数据。</p>
</blockquote>
<ol>
<li><p>没有数据可读，应用程序阻塞，或者recv返回一条指示说明没有数据可读。到底会发生什么情况取决于套接字是否标识为阻塞，以及主机B的操作系统为系统调用recv指定了什么样的语义。</p>
</li>
<li><p>应用程序获取了报文M1中的部分而不是全部数据。比如，发送端TCP像图2-26D那样对数据进行分组就会发生这种情况。</p>
</li>
<li><p>应用程序获取了报文M1中所有的数据，除此之外没有任何其他内容。如果像图2-26A那样对数据分组就会发生这种情况。</p>
</li>
<li><p>应用程序获取了报文M1的所有数据，以及报文M2的部分或全部数据。如果像图2-26B或图2-26C那样对数据进行分组就会发生这种情况。</p>
</li>
</ol>
<p>注意，这里还有一个定时问题。如果主机B的应用程序在主机A发送了第二条报文之后一段时间内都没有读取第一条报文，那么这两条报文都会成为可读的。这就和图2-26B所示情况相同了。这些描述说明，通常，在任意指定时刻，可读的数据量都是不确定的。</p>
<p>需要再次说明的是，TCP是一个流协议（stream protocol），尽管数据是以IP分组的形式传输的，但<strong>分组中的数据量与send调用中传送给TCP多少数据并没有直接关系</strong>。而且，接收程序也没有什么可靠的方法可以判断数据是如何分组的，因为在两次recv调用之间可能会有多个分组到来。</p>
<blockquote>
<p>即使接收端应用程序的响应非常及时，也可能会发生这种情况。例如，一个分组丢失了（参见技巧12，在当今的因特网中，这是非常常见的情况），而且后继分组都安全到达，TCP会将后继分组中的数据保存起来，直到重传第一个分组并正确收到为止。此时，所有数据对应用程序都是可用的。</p>
</blockquote>
<p>TCP会记录它发送了多少字节，以及确认的字节，但它不会记录这些字节是如何分组的。实际上，有些实现在重传丢失分组的时候传送的数据可能比原来的多一些或少一些。这就足以支撑下面再次重复说明的内容了。</p>
<blockquote>
<p>对TCP应用程序来说，就没有”分组”这种概念。如果应用程序的设计与TCP对数据的分组方式有所关联，就应该考虑重新设计这个应用程序了。</p>
</blockquote>
<p>既然任意一次指定的读操作中返回的数据量都是不可预测的，就必须在应用程序中做好应对这种情况的准备。通常这不是什么问题。比如说，我们可能在用fgets这样标准的I/O库程序读取数据。在这种情况下，fgets会将字节流划分成行。图3-6显示了一个这样的例子。在其他情况下的确需要关注报文边界问题，而这些情况下边界都是由应用程序级维护的。</p>
<p><strong>最简单的情况就是定长报文</strong>。在这种情况下，只需要读取报文中固定数量的字节就可以了。根据前面的讨论，读操作返回的字节数可能小于sizeof(msg)（图2-26D），所以只进行</p>
<pre><code>recv(s, msg, sizeof(msg), 0); 
</code></pre><p>这样的简单调用是不够的。图2-27显示了处理这种情况的标准方法。</p>
<p><img src="/img/函数readn.png" alt=""></p>
<p><img src="/img/函数readn续.png" alt="图2-27　函数readn"></p>
<p>函数readn的用法与read非常相似，但在读到len字节，并从对等实体收到EOF，或出现错误之前，它是不会返回的。我们将其定义如下。</p>
<pre><code>#include &quot;etcp.h&quot;  

int readn( SOCKET s, char *buf, size_t len );  

                                                            返回：读取的字节数，出错时返回-1  
</code></pre><p>readn使用的逻辑与从串行端口，或者从其他基于流的、在任意指定时间内可读取数据量都未知的源端，读取指定数量的字节所使用的逻辑一样，这不足为奇。实际上，在所有这些情况下都可以，也经常使用readn（用int代替SOCKET，用read代替recv）。</p>
<p>如果recv调用被信号中断，第11行和第12行的if语句</p>
<pre><code>if ( error == EINTR)        /* interrupted? */   
    continue;               /* restart the read*/  
</code></pre><p>会重启recv调用。有些系统会自动重启被中断的系统调用，这种系统就不需要这两行程序了。从另一个角度来看，这两行代码也不会带来什么问题，因此为了实现最大限度的可移植性，最好还是把它们放在那里。</p>
<p>对必须支持可变长报文的应用程序来说，有两种可用的方法。第一种，可以用记录结束标记来分隔记录。如前所述，使用fgets这样标准的I/O程序将报文分成单个行时，就会发生这种情况。使用标准I/O程序时，很自然地会将新行作为记录结束标记使用。但使用这种方法通常会有一些问题。首先，除非在报文主体中从未用到记录结束标记，否则发送程序就要在报文中扫描这些标记，对其进行转义，或者编码，以免将其误认作记录结束标记。比如，如果将记录分隔字符RS作为记录结束标记使用，发送端就要搜索报文主体，找到所有RS字符，并对其进行转义，比如在前面加上一个\。这就意味着要转移数据以便为转义字符腾出位置。当然，还要对出现的所有转义字符进行转义。因此，如果用\作转义字符的话，就要将报文主体中出现的所有\都改成\。</p>
<p>在接收端，必须再次对整条报文进行扫描，这次要移除转义字符，并搜索（未转义的）记录结束标记。使用记录结束标记要对整条报文扫描两次，所以最好只在那些有”自然”记录结束标记的情况下使用，比如用换行符分隔文本行记录的时候。</p>
<p>另外一种处理可变记录的方法是在每条报文前面加上一个首部，这个首部（至少）包含下面的报文长度，如图2-28所示。</p>
<p><img src="/img/可变长记录的格式.png" alt="图2-28　可变长记录的格式"></p>
<p>接收端应用程序分两部分读取报文。首先读取定长的报文首部，从首部解析出可变部分的长度，然后读取可变长部分。图2-29显示了一种简单的情况，其中首部只包含了记录的长度。</p>
<p><img src="/img/读取可变长记录的函数.png" alt="图2-29　读取可变长记录的函数readvrec"></p>
<p><strong>读取记录长度</strong></p>
<p><strong>6-8</strong>  将记录长度读入reclen中，如果readn返回的长度不等于interger类型的大小，readvrec就返回0（EOF），如果出错就返回 1。</p>
<p><strong>9</strong>  将记录长度从网络字节序转换为主机字节序。更多相关内容请参见技巧28。</p>
<p><strong>查看是否装得下记录</strong></p>
<p><strong>10-27</strong> 查看调用程序的缓冲区大小，验证它能否装下整条记录。如果缓冲区中没有足够的空间，就依次将长度为len的片段读入缓冲区，并将记录丢弃。丢弃记录之后，将errno设置为EMSGSIZE，readvrec返回 1。</p>
<p><strong>读取记录</strong></p>
<p><strong>29-32</strong> 最后，读取记录本身。根据readn返回的是错误、不足计数还是成功返回，readvrec会向调用程序返回 1、0或者reclen。</p>
<p>readvrec是个很有用的函数，会在其他一些技巧中用到，所以将其定义记录如下。</p>
<pre><code>#include &quot;etcp. h&quot;  

int readvrec( SOCKET s, char *buf, size_t len );  

                                                        返回：读取的字节数，或者在出错时返回-1  
</code></pre><p>图2-30显示了一个用readvrec从TCP连接中读取变长记录，并将其写入stdout的简单服务器代码。</p>
<p><img src="/img/说明readvrec用法的服务器程序.png" alt=""></p>
<p><img src="/img/说明readvrec用法的服务器程序.png" alt="图2-30　vrs--说明readvrec用法的服务器程序"></p>
<p><strong>10-17</strong> 初始化服务器，并接受一个连接。</p>
<p><strong>20-24</strong> 调用readvrec读取下一个变长记录。如果出错，打印一条诊断信息，并读取下一条记录。如果readvrec返回一个EOF，就打印一条提示消息，服务器退出。</p>
<p><strong>26</strong> 将记录写入stdout。</p>
<p>图2-31显示了对应的客户端程序，这个程序从其标准输入读取报文，附加上报文长度，然后将其发送给服务器。</p>
<p><img src="/img/发送可变长报文的客户端程序.png" alt="图2-31　vrc--发送可变长报文的客户端程序"></p>
<p><strong>定义分组结构</strong></p>
<p><strong>6-10</strong> 定义packet结构，调用send时用它来装载报文及其长度。数据类型u_int32_t是一个无符号的32比特整数。由于Windows没有定义这种数据类型，所以在Windows版本的skel.h中有它的typedef。</p>
<blockquote>
<p>对这个例子来说，还应该弄清楚另一个潜在的问题。假定编译器会严格按照我们的指令没有任何填充地将数据封装在一个结构中。因为第二个元素是一个字节数组，所以在大多数系统中这种假设都是有效的，但要小心，对编译器封装数据的方式进行的假设可能会引发一些问题。技巧24对其他一些同时发送两个或多个不同数据段的方法进行了讨论，那时会再次讨论这个问题。</p>
</blockquote>
<p><strong>连接、读取并逐行发送</strong></p>
<p><strong>12</strong> 客户端通过调用tcp_client连接到服务器。</p>
<p><strong>13-21</strong> 调用fgets从stdin中读取一行数据，并将其放入报文分组的buf字段中。行的长度由对strlen的调用决定，将这个值转换成网络字节序后，放入报文分组的reclen字段中。最后，调用send向服务器发送分组。</p>
<p>发送这些由两个或多个部分组成的报文的另一种方法请参见技巧24。</p>
<p>在sparc上启动服务器vrs，然后在bsd上启动客户端vrc，来测试这些程序。将程序的运行并排显示出来，就可以看到客户端的输入，以及相应的服务器输出了。第4行还对错误消息进行了换行显示。</p>
<p><img src="/img/shiyanjieguo.png" alt=""></p>
<p>服务器缓冲区有10字节，所以发送11字节1, …, 0, <lf>时，readvrec会返回一条错误。</lf></p>
<p>##小结</p>
<p>初级网络程序员最常犯的错误之一就是无法理解TCP传送的是一个没有记录边界概念的字节流。这一点很重要，可以总结为TCP中没有用户可见的”分组”概念，它只是传送了一个字节流，我们无法准确地预测在一个特定的读操作中会返回多少字节。在这个技巧中，还对应用程序处理这种情况时所使用的几种策略进行了研究。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/24/TCP是一种流协议/" data-id="cj64uppy1002flrae52xgqmiv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/9/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Django/">Django</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/">TCP/IP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jQuery/">jQuery</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/openstack/">openstack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scrapy/">scrapy</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/twisted/">twisted</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/unix网络编程/">unix网络编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编译原理/">编译原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/长知识/">长知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/bash/">bash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openstack/">openstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scrapy/">scrapy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp-ip/">tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unicode/">unicode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/urllib/">urllib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步编程/">异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序/">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络基础/">网络基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/bash/" style="font-size: 10px;">bash</a> <a href="/tags/c/" style="font-size: 19px;">c</a> <a href="/tags/http/" style="font-size: 14px;">http</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/linux/" style="font-size: 17px;">linux</a> <a href="/tags/mac/" style="font-size: 11px;">mac</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/openstack/" style="font-size: 10px;">openstack</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/scrapy/" style="font-size: 16px;">scrapy</a> <a href="/tags/shell/" style="font-size: 13px;">shell</a> <a href="/tags/socket/" style="font-size: 11px;">socket</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/tcp-ip/" style="font-size: 13px;">tcp/ip</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/unicode/" style="font-size: 10px;">unicode</a> <a href="/tags/urllib/" style="font-size: 10px;">urllib</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/异步编程/" style="font-size: 18px;">异步编程</a> <a href="/tags/排序/" style="font-size: 10px;">排序</a> <a href="/tags/操作系统/" style="font-size: 11px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 12px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/网络基础/" style="font-size: 10px;">网络基础</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/09/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/12/19/Django外键赋值/">Django外键赋值</a>
          </li>
        
          <li>
            <a href="/2016/11/03/Django-redis如何支持存取整型和布尔值/">Django-redis如何支持存取整型和布尔值</a>
          </li>
        
          <li>
            <a href="/2016/10/17/Django-model去掉unique_together报错/">Django model去掉unique_together报错</a>
          </li>
        
          <li>
            <a href="/2016/07/10/python-string-intern/">python_string_intern</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>