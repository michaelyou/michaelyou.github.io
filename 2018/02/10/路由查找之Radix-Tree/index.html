<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="go," />








  <link rel="shortcut icon" type="image/x-icon" href="/img/lufei.ico?v=5.1.2" />






<meta name="description" content="什么是Radix Tree 在计算机科学中，基数树，或称Patricia trie/tree，或crit bit tree，压缩前缀树，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。   golang的web框架echo和gin都使用了radix tree作为路由查找的算法，我们以gin的实现来分析一下。 在gin的路由中，每一个Http">
<meta name="keywords" content="go">
<meta property="og:type" content="article">
<meta property="og:title" content="路由查找之Radix Tree">
<meta property="og:url" content="http://yoursite.com/2018/02/10/路由查找之Radix-Tree/index.html">
<meta property="og:site_name" content="Youmai の Blog">
<meta property="og:description" content="什么是Radix Tree 在计算机科学中，基数树，或称Patricia trie/tree，或crit bit tree，压缩前缀树，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。   golang的web框架echo和gin都使用了radix tree作为路由查找的算法，我们以gin的实现来分析一下。 在gin的路由中，每一个Http">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/img/radix_tree.png">
<meta property="og:updated_time" content="2018-02-10T10:59:42.097Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="路由查找之Radix Tree">
<meta name="twitter:description" content="什么是Radix Tree 在计算机科学中，基数树，或称Patricia trie/tree，或crit bit tree，压缩前缀树，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。   golang的web框架echo和gin都使用了radix tree作为路由查找的算法，我们以gin的实现来分析一下。 在gin的路由中，每一个Http">
<meta name="twitter:image" content="http://yoursite.com/img/radix_tree.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/02/10/路由查找之Radix-Tree/"/>





  <title>路由查找之Radix Tree | Youmai の Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63551049-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Youmai の Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/10/路由查找之Radix-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="You Wangqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/lufei.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youmai の Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">路由查找之Radix Tree</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-10T18:50:34+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="什么是Radix-Tree"><a href="#什么是Radix-Tree" class="headerlink" title="什么是Radix Tree"></a>什么是Radix Tree</h2><blockquote>
<p>在计算机科学中，基数树，或称Patricia trie/tree，或crit bit tree，压缩前缀树，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。</p>
</blockquote>
<p><img src="/img/radix_tree.png" alt=""></p>
<p>golang的web框架<a href="https://github.com/labstack/echo" target="_blank" rel="external">echo</a>和<a href="https://github.com/gin-gonic/gin" target="_blank" rel="external">gin</a>都使用了<code>radix tree</code>作为路由查找的算法，我们以gin的实现来分析一下。</p>
<p>在gin的路由中，每一个<code>Http Method</code>(GET, PUT, POST…)都对应了一棵 <code>radix tree</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (engine *Engine) addRoute(method, path string, handlers HandlersChain) &#123;</div><div class="line">    // ...</div><div class="line">    </div><div class="line">    // 获取method对应的树，如果没有就创建</div><div class="line">    root := engine.trees.get(method)</div><div class="line">    if root == nil &#123;</div><div class="line">        // 创建radix tree，只有根节点</div><div class="line">        root = new(node)</div><div class="line">        engine.trees = append(engine.trees, methodTree&#123;method: method, root: root&#125;)</div><div class="line">    &#125;</div><div class="line">    root.addRoute(path, handlers)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>radix tree</code>可以被认为是一棵简洁版的前缀树。拥有共同前缀的节点也共享同一个父节点。下面是一个<code>GET</code>方法对应的路由树的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Priority   Path             Handle</div><div class="line">9          \                *&lt;1&gt;</div><div class="line">3          ├s               nil</div><div class="line">2          |├earch\         *&lt;2&gt;</div><div class="line">1          |└upport\        *&lt;3&gt;</div><div class="line">2          ├blog\           *&lt;4&gt;</div><div class="line">1          |    └:post      nil</div><div class="line">1          |         └\     *&lt;5&gt;</div><div class="line">2          ├about-us\       *&lt;6&gt;</div><div class="line">1          |        └team\  *&lt;7&gt;</div><div class="line">1          └contact\        *&lt;8&gt;</div></pre></td></tr></table></figure>
<p><code>*&lt;num&gt;</code>是方法（handler）对应的指针，从根节点遍历到叶子节点我们就能得到完整的路由表，图中的示例实现了以下路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET(&quot;/&quot;, func1)</div><div class="line">GET(&quot;/search/&quot;, func2)</div><div class="line">GET(&quot;/support/&quot;, func3)</div><div class="line">GET(&quot;/blog/&quot;, func4)</div><div class="line">GET(&quot;/blog/:post/&quot;, func5)</div><div class="line">GET(&quot;/about-us/&quot;, func6)</div><div class="line">GET(&quot;/about-us/team/&quot;, func7)</div><div class="line">GET(&quot;/contact/&quot;, func8)</div></pre></td></tr></table></figure>
<p><code>:post</code>是真实的<code>post name</code>的一个占位符（就是一个参数）。这里体现了radix tree相较于hash-map的一个优点，树结构允许我们的路径中存在动态的部分（参数）,因为我们匹配的是路由的模式而不是hash值</p>
<p>为了更具扩展性，每一层的节点按照priority排序，priority是节点的子节点（儿子节点，孙子节点等）注册的handler的数量，这样做有两个好处：</p>
<ol>
<li>被最多路径包含的节点会被最先评估。这样可以让尽量多的路由快速被定位。</li>
<li>有点像成本补偿。最长的路径可以被最先评估，补偿体现在最长的路径需要花费更长的时间来定位，如果最长路径的节点能被优先评估（即每次拿子节点都命中），那么所花时间不一定比短路径的路由长。下面展示了节点（每个<code>-</code>可以看做一个节点）评估的路径：从左到右，从上到下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">├------------</div><div class="line">├---------</div><div class="line">├-----</div><div class="line">├----</div><div class="line">├--</div><div class="line">├--</div><div class="line">└-</div></pre></td></tr></table></figure>
<h2 id="节点数据结构"><a href="#节点数据结构" class="headerlink" title="节点数据结构"></a>节点数据结构</h2><p>节点的数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">type node struct &#123;</div><div class="line">    // 节点路径，比如上面的s，earch，和upport</div><div class="line">    path      string</div><div class="line">    // 节点是否是参数节点，比如上面的:post</div><div class="line">    wildChild bool</div><div class="line">    // 节点类型，包括static, root, param, catchAll</div><div class="line">    // static: 静态节点，比如上面的s，earch等节点</div><div class="line">    // root: 树的根节点</div><div class="line">    // catchAll: 有*匹配的节点</div><div class="line">    // param: 参数节点</div><div class="line">    nType     nodeType</div><div class="line">    // 路径上最大参数个数</div><div class="line">    maxParams uint8</div><div class="line">    // 和children字段对应, 保存的是分裂的分支的第一个字符</div><div class="line">    // 例如search和support, 那么s节点的indices对应的&quot;eu&quot;</div><div class="line">    // 代表有两个分支, 分支的首字母分别是e和u</div><div class="line">    indices   string</div><div class="line">    // 儿子节点</div><div class="line">    children  []*node</div><div class="line">    // 处理函数</div><div class="line">    handlers  HandlersChain</div><div class="line">    // 优先级，子节点注册的handler数量</div><div class="line">    priority  uint32</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line">func (n *node) addRoute(path string, handlers HandlersChain) &#123;</div><div class="line">    fullPath := path</div><div class="line">    n.priority++</div><div class="line">    numParams := countParams(path)</div><div class="line"></div><div class="line">    // non-empty tree</div><div class="line">    if len(n.path) &gt; 0 || len(n.children) &gt; 0 &#123;</div><div class="line">    walk:</div><div class="line">        for &#123;</div><div class="line">            // Update maxParams of the current node</div><div class="line">            if numParams &gt; n.maxParams &#123;</div><div class="line">                n.maxParams = numParams</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Find the longest common prefix.</div><div class="line">            // This also implies that the common prefix contains no &apos;:&apos; or &apos;*&apos;</div><div class="line">            // since the existing key can&apos;t contain those chars.</div><div class="line">            i := 0</div><div class="line">            max := min(len(path), len(n.path))</div><div class="line">            for i &lt; max &amp;&amp; path[i] == n.path[i] &#123;</div><div class="line">                i++</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Split edge</div><div class="line">            // 开始分裂，比如一开始path是search，新来了support，s是他们匹配的部分，</div><div class="line">            // 那么会将s拿出来作为parent节点，增加earch和upport作为child节点</div><div class="line">            if i &lt; len(n.path) &#123;</div><div class="line">                child := node&#123;</div><div class="line">                    path:      n.path[i:],  // 不匹配的部分作为child节点</div><div class="line">                    wildChild: n.wildChild,</div><div class="line">                    indices:   n.indices,</div><div class="line">                    children:  n.children,</div><div class="line">                    handlers:  n.handlers,</div><div class="line">                    priority:  n.priority - 1,  // 降级成子节点，priority减1</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Update maxParams (max of all children)</div><div class="line">                for i := range child.children &#123;</div><div class="line">                    if child.children[i].maxParams &gt; child.maxParams &#123;</div><div class="line">                        child.maxParams = child.children[i].maxParams</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                // 当前节点的子节点变成刚刚分裂的出来的节点</div><div class="line">                n.children = []*node&#123;&amp;child&#125;</div><div class="line">                // []byte for proper unicode char conversion, see #65</div><div class="line">                n.indices = string([]byte&#123;n.path[i]&#125;)</div><div class="line">                n.path = path[:i]</div><div class="line">                n.handlers = nil</div><div class="line">                n.wildChild = false</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Make new node a child of this node</div><div class="line">            // 将新来的节点插入新的parent节点作为子节点</div><div class="line">            if i &lt; len(path) &#123;</div><div class="line">                path = path[i:]</div><div class="line"></div><div class="line">					// 如果是参数节点（包含:或*）</div><div class="line">                if n.wildChild &#123;</div><div class="line">                    n = n.children[0]</div><div class="line">                    n.priority++</div><div class="line"></div><div class="line">                    // Update maxParams of the child node</div><div class="line">                    if numParams &gt; n.maxParams &#123;</div><div class="line">                        n.maxParams = numParams</div><div class="line">                    &#125;</div><div class="line">                    numParams--</div><div class="line"></div><div class="line">                    // Check if the wildcard matches</div><div class="line">                    // 例如：/blog/:pp 和 /blog/:ppp，需要检查更长的通配符</div><div class="line">                    if len(path) &gt;= len(n.path) &amp;&amp; n.path == path[:len(n.path)] &#123;</div><div class="line">                        // check for longer wildcard, e.g. :name and :names</div><div class="line">                        if len(n.path) &gt;= len(path) || path[len(n.path)] == &apos;/&apos; &#123;</div><div class="line">                            continue walk</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    panic(&quot;path segment &apos;&quot; + path +</div><div class="line">                        &quot;&apos; conflicts with existing wildcard &apos;&quot; + n.path +</div><div class="line">                        &quot;&apos; in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">					// 首字母，用来与indices做比较</div><div class="line">                c := path[0]</div><div class="line"></div><div class="line">                // slash after param</div><div class="line">                if n.nType == param &amp;&amp; c == &apos;/&apos; &amp;&amp; len(n.children) == 1 &#123;</div><div class="line">                    n = n.children[0]</div><div class="line">                    n.priority++</div><div class="line">                    continue walk</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Check if a child with the next path byte exists</div><div class="line">                // 判断子节点中是否有和当前path有匹配的，只需要查看子节点path的第一个字母即可，即indices</div><div class="line">                // 比如s的子节点现在是earch和upport，indices为eu</div><div class="line">                // 如果新来的路由为super，那么就是和upport有匹配的部分u，将继续分类现在的upport节点</div><div class="line">                for i := 0; i &lt; len(n.indices); i++ &#123;</div><div class="line">                    if c == n.indices[i] &#123;</div><div class="line">                        i = n.incrementChildPrio(i)</div><div class="line">                        n = n.children[i]</div><div class="line">                        continue walk</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Otherwise insert it</div><div class="line">                if c != &apos;:&apos; &amp;&amp; c != &apos;*&apos; &#123;</div><div class="line">                    // []byte for proper unicode char conversion, see #65</div><div class="line">                    // 记录第一个字符，放在indices中</div><div class="line">                    n.indices += string([]byte&#123;c&#125;)</div><div class="line">                    child := &amp;node&#123;</div><div class="line">                        maxParams: numParams,</div><div class="line">                    &#125;</div><div class="line">                    // 增加子节点</div><div class="line">                    n.children = append(n.children, child)</div><div class="line">                    n.incrementChildPrio(len(n.indices) - 1)</div><div class="line">                    n = child</div><div class="line">                &#125;</div><div class="line">                n.insertChild(numParams, path, fullPath, handlers)</div><div class="line">                return</div><div class="line"></div><div class="line">            &#125; else if i == len(path) &#123; // Make node a (in-path) leaf</div><div class="line">                // 路径相同，如果已有handler就报错，没有就赋值</div><div class="line">                if n.handlers != nil &#123;</div><div class="line">                    panic(&quot;handlers are already registered for path &apos;&apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">                &#125;</div><div class="line">                n.handlers = handlers</div><div class="line">            &#125;</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123; // Empty tree，空树，插入节点，节点种类是root</div><div class="line">        n.insertChild(numParams, path, fullPath, handlers)</div><div class="line">        n.nType = root</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此函数的主要目的是找到插入节点的位置，如果和现有节点存在相同的前缀，那么要将现有节点进行分裂，然后再插入，下面是<code>insertChild</code>函数</p>
<h2 id="插入子节点"><a href="#插入子节点" class="headerlink" title="插入子节点"></a>插入子节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line">// @1: 参数个数</div><div class="line">// @2: 路径</div><div class="line">// @3: 完整路径</div><div class="line">// @4: 处理函数</div><div class="line">func (n *node) insertChild(numParams uint8, path string, fullPath string, handlers HandlersChain) &#123;</div><div class="line">    var offset int // already handled bytes of the path</div><div class="line"></div><div class="line">    // find prefix until first wildcard (beginning with &apos;:&apos;&apos; or &apos;*&apos;&apos;)</div><div class="line">    // 找到前缀，只要匹配到wildcard</div><div class="line">    for i, max := 0, len(path); numParams &gt; 0; i++ &#123;</div><div class="line">        c := path[i]</div><div class="line">        if c != &apos;:&apos; &amp;&amp; c != &apos;*&apos; &#123;</div><div class="line">            continue</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // find wildcard end (either &apos;/&apos; or path end)</div><div class="line">        end := i + 1</div><div class="line">        for end &lt; max &amp;&amp; path[end] != &apos;/&apos; &#123;</div><div class="line">            switch path[end] &#123;</div><div class="line">            // the wildcard name must not contain &apos;:&apos; and &apos;*&apos;</div><div class="line">            case &apos;:&apos;, &apos;*&apos;:</div><div class="line">                panic(&quot;only one wildcard per path segment is allowed, has: &apos;&quot; +</div><div class="line">                    path[i:] + &quot;&apos; in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">            default:</div><div class="line">                end++</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // check if this Node existing children which would be</div><div class="line">        // unreachable if we insert the wildcard here</div><div class="line">        if len(n.children) &gt; 0 &#123;</div><div class="line">            panic(&quot;wildcard route &apos;&quot; + path[i:end] +</div><div class="line">                &quot;&apos; conflicts with existing children in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // check if the wildcard has a name</div><div class="line">        if end-i &lt; 2 &#123;</div><div class="line">            panic(&quot;wildcards must be named with a non-empty name in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if c == &apos;:&apos; &#123; // param</div><div class="line">            // split path at the beginning of the wildcard</div><div class="line">            if i &gt; 0 &#123;</div><div class="line">                n.path = path[offset:i]</div><div class="line">                offset = i</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            child := &amp;node&#123;</div><div class="line">                nType:     param,</div><div class="line">                maxParams: numParams,</div><div class="line">            &#125;</div><div class="line">            n.children = []*node&#123;child&#125;</div><div class="line">            n.wildChild = true</div><div class="line">            n = child</div><div class="line">            n.priority++</div><div class="line">            numParams--</div><div class="line"></div><div class="line">            // if the path doesn&apos;t end with the wildcard, then there</div><div class="line">            // will be another non-wildcard subpath starting with &apos;/&apos;</div><div class="line">            if end &lt; max &#123;</div><div class="line">                n.path = path[offset:end]</div><div class="line">                offset = end</div><div class="line">                </div><div class="line">                child := &amp;node&#123;</div><div class="line">                    maxParams: numParams,</div><div class="line">                    priority:  1,</div><div class="line">                &#125;</div><div class="line">                n.children = []*node&#123;child&#125;</div><div class="line">                // 下次循环这个新的child节点</div><div class="line">                n = child</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; else &#123; // catchAll</div><div class="line">            if end != max || numParams &gt; 1 &#123;</div><div class="line">                panic(&quot;catch-all routes are only allowed at the end of the path in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if len(n.path) &gt; 0 &amp;&amp; n.path[len(n.path)-1] == &apos;/&apos; &#123;</div><div class="line">                panic(&quot;catch-all conflicts with existing handle for the path segment root in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // currently fixed width 1 for &apos;/&apos;</div><div class="line">            i--</div><div class="line">            if path[i] != &apos;/&apos; &#123;</div><div class="line">                panic(&quot;no / before catch-all in path &apos;&quot; + fullPath + &quot;&apos;&quot;)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            n.path = path[offset:i]</div><div class="line"></div><div class="line">            // first node: catchAll node with empty path</div><div class="line">            child := &amp;node&#123;</div><div class="line">                wildChild: true,</div><div class="line">                nType:     catchAll,</div><div class="line">                maxParams: 1,</div><div class="line">            &#125;</div><div class="line">            n.children = []*node&#123;child&#125;</div><div class="line">            n.indices = string(path[i])</div><div class="line">            n = child</div><div class="line">            n.priority++</div><div class="line"></div><div class="line">            // second node: node holding the variable</div><div class="line">            child = &amp;node&#123;</div><div class="line">                path:      path[i:],</div><div class="line">                nType:     catchAll,</div><div class="line">                maxParams: 1,</div><div class="line">                handlers:  handlers,</div><div class="line">                priority:  1,</div><div class="line">            &#125;</div><div class="line">            n.children = []*node&#123;child&#125;</div><div class="line"></div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // insert remaining path part and handle to the leaf</div><div class="line">    n.path = path[offset:]</div><div class="line">    n.handlers = handlers</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>insertChild</code>函数是根据<code>path</code>本身进行分割, 将<code>/</code>分开的部分分别作为节点保存, 形成一棵树结构. 注意参数匹配中的<code>:</code>和<code>*</code>的区别, 前者是匹配一个字段, 后者是匹配后面所有的路径</p>
<h2 id="路径查找"><a href="#路径查找" class="headerlink" title="路径查找"></a>路径查找</h2><p>匹配每个children的path，最长匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line">// Returns the handle registered with the given path (key). The values of</div><div class="line">// wildcards are saved to a map.</div><div class="line">// If no handle can be found, a TSR (trailing slash redirect) recommendation is</div><div class="line">// made if a handle exists with an extra (without the) trailing slash for the</div><div class="line">// given path.</div><div class="line">func (n *node) getValue(path string, po Params, unescape bool) (handlers HandlersChain, p Params, tsr bool) &#123;</div><div class="line">    p = po</div><div class="line">walk: // Outer loop for walking the tree</div><div class="line">    for &#123;</div><div class="line">        // 尚未到达path的终点</div><div class="line">        if len(path) &gt; len(n.path) &#123;</div><div class="line">            // 前面一段需要一致</div><div class="line">            if path[:len(n.path)] == n.path &#123;</div><div class="line">                path = path[len(n.path):]</div><div class="line">                // If this node does not have a wildcard (param or catchAll)</div><div class="line">                // child,  we can just look up the next child node and continue</div><div class="line">                // to walk down the tree</div><div class="line">                if !n.wildChild &#123;</div><div class="line">                    c := path[0]</div><div class="line">                    for i := 0; i &lt; len(n.indices); i++ &#123;</div><div class="line">                        if c == n.indices[i] &#123;</div><div class="line">                            n = n.children[i]</div><div class="line">                            continue walk</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // Nothing found.</div><div class="line">                    // We can recommend to redirect to the same URL without a</div><div class="line">                    // trailing slash if a leaf exists for that path.</div><div class="line">                    tsr = (path == &quot;/&quot; &amp;&amp; n.handlers != nil)</div><div class="line">                    return</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // handle wildcard child</div><div class="line">                n = n.children[0]</div><div class="line">                switch n.nType &#123;</div><div class="line">                case param:</div><div class="line">                    // find param end (either &apos;/&apos; or path end)</div><div class="line">                    end := 0</div><div class="line">                    for end &lt; len(path) &amp;&amp; path[end] != &apos;/&apos; &#123;</div><div class="line">                        end++</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // save param value</div><div class="line">                    if cap(p) &lt; int(n.maxParams) &#123;</div><div class="line">                        p = make(Params, 0, n.maxParams)</div><div class="line">                    &#125;</div><div class="line">                    i := len(p)</div><div class="line">                    p = p[:i+1] // expand slice within preallocated capacity</div><div class="line">                    p[i].Key = n.path[1:]</div><div class="line">                    val := path[:end]</div><div class="line">                    if unescape &#123;</div><div class="line">                        var err error</div><div class="line">                        if p[i].Value, err = url.QueryUnescape(val); err != nil &#123;</div><div class="line">                            p[i].Value = val // fallback, in case of error</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        p[i].Value = val</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // we need to go deeper!</div><div class="line">                                        if end &lt; len(path) &#123;</div><div class="line">                        if len(n.children) &gt; 0 &#123;</div><div class="line">                            path = path[end:]</div><div class="line">                            n = n.children[0]</div><div class="line">                            continue walk</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        // ... but we can&apos;t</div><div class="line">                        tsr = (len(path) == end+1)</div><div class="line">                        return</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if handlers = n.handlers; handlers != nil &#123;</div><div class="line">                        return</div><div class="line">                    &#125;</div><div class="line">                    if len(n.children) == 1 &#123;</div><div class="line">                        // No handle found. Check if a handle for this path + a</div><div class="line">                        // trailing slash exists for TSR recommendation</div><div class="line">                        n = n.children[0]</div><div class="line">                        tsr = (n.path == &quot;/&quot; &amp;&amp; n.handlers != nil)</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    return</div><div class="line"></div><div class="line">                case catchAll:</div><div class="line">                    // save param value</div><div class="line">                    if cap(p) &lt; int(n.maxParams) &#123;</div><div class="line">                        p = make(Params, 0, n.maxParams)</div><div class="line">                    &#125;</div><div class="line">                    i := len(p)</div><div class="line">                    p = p[:i+1] // expand slice within preallocated capacity</div><div class="line">                    p[i].Key = n.path[2:]</div><div class="line">                    if unescape &#123;</div><div class="line">                        var err error</div><div class="line">                        if p[i].Value, err = url.QueryUnescape(path); err != nil &#123;</div><div class="line">                            p[i].Value = path // fallback, in case of error</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        p[i].Value = path</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    handlers = n.handlers</div><div class="line">                    return</div><div class="line"></div><div class="line">                default:</div><div class="line">                    panic(&quot;invalid node type&quot;)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else if path == n.path &#123;</div><div class="line">            // We should have reached the node containing the handle.</div><div class="line">            // Check if this node has a handle registered.</div><div class="line">            if handlers = n.handlers; handlers != nil &#123;</div><div class="line">                return</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if path == &quot;/&quot; &amp;&amp; n.wildChild &amp;&amp; n.nType != root &#123;</div><div class="line">                tsr = true</div><div class="line">                return</div><div class="line">            &#125;</div><div class="line">            // No handle found. Check if a handle for this path + a</div><div class="line">            // trailing slash exists for trailing slash recommendation</div><div class="line">            for i := 0; i &lt; len(n.indices); i++ &#123;</div><div class="line">                if n.indices[i] == &apos;/&apos; &#123;</div><div class="line">                    n = n.children[i]</div><div class="line">                    tsr = (len(n.path) == 1 &amp;&amp; n.handlers != nil) ||</div><div class="line">                        (n.nType == catchAll &amp;&amp; n.children[0].handlers != nil)</div><div class="line">                    return</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Nothing found. We can recommend to redirect to the same URL with an</div><div class="line">        // extra trailing slash if a leaf exists for that path</div><div class="line">        tsr = (path == &quot;/&quot;) ||</div><div class="line">            (len(n.path) == len(path)+1 &amp;&amp; n.path[len(path)] == &apos;/&apos; &amp;&amp;</div><div class="line">                path == n.path[:len(n.path)-1] &amp;&amp; n.handlers != nil)</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前总听大家说数据结构与算法有什么用，工作中又用不到，上面就是一个很好的示例。我们平时还是要多关注底层原理，做后端的同学多看看框架的代码，一定受益匪浅~</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/go/" rel="tag"># go</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/06/go-pprof-采样何时进行/" rel="next" title="go pprof 采样何时进行">
                <i class="fa fa-chevron-left"></i> go pprof 采样何时进行
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/lufei.jpeg"
               alt="You Wangqiu" />
          <p class="site-author-name" itemprop="name">You Wangqiu</p>
           
              <p class="site-description motion-element" itemprop="description">世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">164</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/michaelyou" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhi-yu-65-2" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="michaelseu2011@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Radix-Tree"><span class="nav-number">1.</span> <span class="nav-text">什么是Radix Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节点数据结构"><span class="nav-number">2.</span> <span class="nav-text">节点数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加路由"><span class="nav-number">3.</span> <span class="nav-text">添加路由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入子节点"><span class="nav-number">4.</span> <span class="nav-text">插入子节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路径查找"><span class="nav-number">5.</span> <span class="nav-text">路径查找</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Wangqiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
